File: D:\Documents\E_Plus_2030_py\idf_objects\ventilation\ventilation_overrides_from_excel.py
============================================================
# ventilation/ventilation_overrides_from_excel.py

import pandas as pd
import copy
import math

def read_ventilation_overrides_from_excel(excel_path):
    """
    Reads an Excel file with columns:
        - calibration_stage
        - main_key
        - sub_key
        - param_name
        - min_val
        - max_val
        - fixed_value

    Returns a nested dict: override_data[stage][main_key][sub_key][param_name] = ...
    
    Where the "..." can be:
      - a tuple (min, max) if numeric
      - a single string or numeric if 'fixed_value' is provided and is non-NaN
        (we store it as (val, val) if numeric, or keep as a plain string if textual).
    
    This can override infiltration ranges, year_factor ranges, OR new schedule info.
    For schedule overrides, 'main_key' might be "schedule_info",
    sub_key might be e.g. "residential", param_name might be "default_infiltration_schedule",
    and fixed_value could be e.g. "InfilResSched".

    Example row:
        calibration_stage = "pre_calibration"
        main_key          = "schedule_info"
        sub_key           = "residential"
        param_name        = "default_infiltration_schedule"
        min_val           = NaN
        max_val           = NaN
        fixed_value       = "MyInfilResSched"

    The resulting override_data will have:
        override_data["pre_calibration"]["schedule_info"]["residential"]["default_infiltration_schedule"] = "MyInfilResSched"
    """
    df = pd.read_excel(excel_path)

    required_cols = ["calibration_stage","main_key","sub_key","param_name","min_val","max_val","fixed_value"]
    for c in required_cols:
        if c not in df.columns:
            raise ValueError(f"Missing column '{c}' in {excel_path}")

    override_data = {}

    for _, row in df.iterrows():
        stage = str(row["calibration_stage"]).strip()
        mkey  = str(row["main_key"]).strip()       # e.g. "residential_infiltration_range" or "schedule_info"
        skey  = str(row["sub_key"]).strip()        # e.g. "A_corner" or "residential" or ""
        pname = str(row["param_name"]).strip()     # e.g. "f_ctrl_range", "default_infiltration_schedule", or ""

        fv = row["fixed_value"]  # could be numeric or string
        mn = row["min_val"]      # typically numeric or NaN
        mx = row["max_val"]      # typically numeric or NaN

        if stage not in override_data:
            override_data[stage] = {}
        if mkey not in override_data[stage]:
            override_data[stage][mkey] = {}

        # Decide how to store
        # 1) If fixed_value is not NaN => store that
        #    - If it's purely numeric, we store as (fv,fv) for consistency with min,max range
        #    - If it's a string, we'll store it as a plain string override
        # 2) Else if min_val and max_val are numeric => store as (min_val,max_val)
        # 3) Otherwise skip if all are NaN

        # Helper to test if something is numeric
        def is_number(x):
            try:
                float(x)
                return True
            except (ValueError, TypeError):
                return False

        if pd.notna(fv):
            # If the fixed_value is numeric => store as a numeric tuple (fv,fv)
            if is_number(fv):
                val_tuple = (float(fv), float(fv))
                final_value = val_tuple
            else:
                # It's likely a string => store it directly as that string
                final_value = str(fv).strip()
        elif pd.notna(mn) and pd.notna(mx) and is_number(mn) and is_number(mx):
            val_tuple = (float(mn), float(mx))
            final_value = val_tuple
        else:
            # skip if no valid data
            continue

        # Insert into override_data
        # Cases:
        #    (a) skey == "" and pname == "" => override_data[stage][mkey] = final_value
        #    (b) skey != "" and pname == "" => override_data[stage][mkey][skey] = final_value
        #    (c) skey + pname => override_data[stage][mkey][skey][pname] = final_value
        if skey == "" and pname == "":
            override_data[stage][mkey] = final_value
        elif skey != "" and pname == "":
            if not isinstance(override_data[stage][mkey], dict):
                override_data[stage][mkey] = {}
            override_data[stage][mkey][skey] = final_value
        else:
            # if we have a param_name => store in stage[mkey][skey][pname]
            if skey not in override_data[stage][mkey] or not isinstance(override_data[stage][mkey][skey], dict):
                override_data[stage][mkey][skey] = {}
            override_data[stage][mkey][skey][pname] = final_value

    return override_data


def apply_ventilation_overrides_to_lookup(default_lookup, override_data):
    """
    Merges override_data into default_lookup (similar to ventilation_lookup).
    
    override_data structure:
      override_data[stage][main_key][sub_key][param_name] = final_value
        (final_value can be a tuple (min,max), or a string for schedules)

    For each stage in override_data:
      - If stage doesn't exist in default_lookup, we create it.
      - For each main_key in override_data => if it's a tuple or string, override
        directly. If it's a dict => merge deeper.
    
    Example usage:
      new_lookup = apply_ventilation_overrides_to_lookup(ventilation_lookup, override_data)
    """
    # If you prefer not to mutate default_lookup in place, do a copy
    new_lookup = copy.deepcopy(default_lookup)

    for stage, stage_dict in override_data.items():
        if stage not in new_lookup:
            new_lookup[stage] = {}

        for mkey, val_mkey in stage_dict.items():
            # val_mkey might be:
            #   - a numeric tuple or string => direct override
            #   - a dict => deeper merges (subkeys, param_names)

            if not isinstance(val_mkey, dict):
                # So if it's a tuple or a string => direct override
                new_lookup[stage][mkey] = val_mkey
                continue

            # if it's a dict => we merge it
            if mkey not in new_lookup[stage]:
                new_lookup[stage][mkey] = {}

            for subk, subv in val_mkey.items():
                # subv might be a tuple, string, or another dict
                if not isinstance(subv, dict):
                    # direct override
                    new_lookup[stage][mkey][subk] = subv
                else:
                    # deeper dict => e.g. {param_name: (min,max) or string}
                    if subk not in new_lookup[stage][mkey]:
                        new_lookup[stage][mkey][subk] = {}
                    for param_key, param_val in subv.items():
                        # param_val could be tuple or string
                        new_lookup[stage][mkey][subk][param_key] = param_val

    return new_lookup

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\ventilation\ventilation_lookup.py
============================================================
# ventilation_lookup.py

"""
This file defines a large nested dictionary called `ventilation_lookup`
that organizes infiltration/ventilation parameters AND the chosen system type
by:
  1) scenario ("scenario1" or "scenario2")
  2) calibration stage ("pre_calibration" or "post_calibration")

Within each stage, we have:
  - residential_infiltration_range
  - non_res_infiltration_range
  - year_factor_range
  - system_control_range_res
  - system_control_range_nonres
  - fan_pressure_range (optional)
  - hrv_sensible_eff_range
  - system_type_map (dictating system A/B/C/D)
"""

ventilation_lookup = {
    # -------------------------------------------------------------------------
    # SCENARIO 1
    # -------------------------------------------------------------------------
    "scenario1": {
        # =====================================================================
        # A) PRE-CALIBRATION
        # =====================================================================
        "pre_calibration": {
            # -----------------------------------------------------------
            # 1) Infiltration ranges (for Residential sub‐types)
            # -----------------------------------------------------------
            "residential_infiltration_range": {
                "Corner House": (1.2, 1.4),
                "Apartment": (0.8, 1.0),
                "Terrace or Semi-detached House": (1.0, 1.2),
                "Detached House": (1.2, 1.5),
                "Two-and-a-half-story House": (1.1, 1.3),
                "other_res": (1.0, 1.2)
            },

            # -----------------------------------------------------------
            # 2) Infiltration ranges (for Non-Residential sub‐types)
            # -----------------------------------------------------------
            "non_res_infiltration_range": {
                "Meeting Function": (0.5, 0.7),
                "Healthcare Function": (0.6, 0.8),
                "Sport Function": (0.4, 0.6),
                "Cell Function": (0.5, 0.7),
                "Retail Function": (0.6, 0.8),
                "Industrial Function": (0.6, 0.9),
                "Accommodation Function": (0.5, 0.7),
                "Office Function": (0.6, 0.8),
                "Education Function": (0.6, 0.8),
                "Other Use Function": (0.5, 0.7),
                "other_nonres": (0.5, 0.7)
            },

            # -----------------------------------------------------------
            # 3) Year-of-construction factor ranges (7 age bands)
            # -----------------------------------------------------------
            "year_factor_range": {
                "< 1945": (2.0, 2.3),
                "1945 - 1964": (1.8, 2.0),
                "1965 - 1974": (1.5, 1.7),
                "1975 - 1991": (1.3, 1.5),
                "1992 - 2005": (1.1, 1.3),
                "2006 - 2014": (0.9, 1.1),
                "2015 and later": (0.7, 0.9)
            },

            # -----------------------------------------------------------
            # 4) System control factors (f_ctrl range) for each system
            # -----------------------------------------------------------
            "system_control_range_res": {
                "A": {"f_ctrl_range": (0.90, 1.00)},
                "B": {"f_ctrl_range": (0.50, 0.60)},
                "C": {"f_ctrl_range": (0.80, 0.90)},
                "D": {"f_ctrl_range": (0.95, 1.05)}
            },
            "system_control_range_nonres": {
                "A": {"f_ctrl_range": (0.90, 1.00)},
                "B": {"f_ctrl_range": (0.80, 0.90)},
                "C": {"f_ctrl_range": (0.60, 0.70)},
                "D": {"f_ctrl_range": (0.75, 0.85)}
            },

            # -----------------------------------------------------------
            # 5) Optional fan pressure ranges (if used)
            # -----------------------------------------------------------
            "fan_pressure_range": {
                "res_mech": (40, 60),
                "nonres_intake": (90, 110),
                "nonres_exhaust": (140, 160)
            },

            # -----------------------------------------------------------
            # 6) HRV sensible efficiency
            # -----------------------------------------------------------
            "hrv_sensible_eff_range": (0.70, 0.80),

            # -----------------------------------------------------------
            # 7) system_type_map - new table picking A/B/C/D
            # -----------------------------------------------------------
            "system_type_map": {
                "residential": {
                    "< 1945": {
                        "Corner House": "A",
                        "Apartment": "C",
                        "Terrace or Semi-detached House": "B",
                        "Detached House": "C",
                        "Two-and-a-half-story House": "A"
                    },
                    "1945 - 1964": {
                        "Corner House": "B",
                        "Apartment": "A",
                        "Terrace or Semi-detached House": "C",
                        "Detached House": "D",
                        "Two-and-a-half-story House": "C"
                    },
                    "1965 - 1974": {
                        "Corner House": "A",
                        "Apartment": "B",
                        "Terrace or Semi-detached House": "C",
                        "Detached House": "D",
                        "Two-and-a-half-story House": "C"
                    },
                    "1975 - 1991": {
                        "Corner House": "C",
                        "Apartment": "C",
                        "Terrace or Semi-detached House": "B",
                        "Detached House": "C",
                        "Two-and-a-half-story House": "A"
                    },
                    "1992 - 2005": {
                        "Corner House": "B",
                        "Apartment": "A",
                        "Terrace or Semi-detached House": "C",
                        "Detached House": "D",
                        "Two-and-a-half-story House": "D"
                    },
                    "2006 - 2014": {
                        "Corner House": "D",
                        "Apartment": "D",
                        "Terrace or Semi-detached House": "C",
                        "Detached House": "C",
                        "Two-and-a-half-story House": "A"
                    },
                    "2015 and later": {
                        "Corner House": "D",
                        "Apartment": "C",
                        "Terrace or Semi-detached House": "A",
                        "Detached House": "B",
                        "Two-and-a-half-story House": "D"
                    }
                },
                "non_residential": {
                    "< 1945": {
                        "Meeting Function": "A",
                        "Healthcare Function": "D",
                        "Sport Function": "C",
                        "Cell Function": "C",
                        "Retail Function": "B",
                        "Industrial Function": "B",
                        "Accommodation Function": "A",
                        "Office Function": "C",
                        "Education Function": "A",
                        "Other Use Function": "B"
                    },
                    "1945 - 1964": {
                        "Meeting Function": "C",
                        "Healthcare Function": "D",
                        "Sport Function": "B",
                        "Cell Function": "C",
                        "Retail Function": "B",
                        "Industrial Function": "A",
                        "Accommodation Function": "D",
                        "Office Function": "D",
                        "Education Function": "B",
                        "Other Use Function": "A"
                    },
                    "1965 - 1974": {
                        "Meeting Function": "B",
                        "Healthcare Function": "C",
                        "Sport Function": "B",
                        "Cell Function": "C",
                        "Retail Function": "C",
                        "Industrial Function": "C",
                        "Accommodation Function": "B",
                        "Office Function": "B",
                        "Education Function": "D",
                        "Other Use Function": "A"
                    },
                    "1975 - 1991": {
                        "Meeting Function": "C",
                        "Healthcare Function": "D",
                        "Sport Function": "B",
                        "Cell Function": "C",
                        "Retail Function": "B",
                        "Industrial Function": "A",
                        "Accommodation Function": "D",
                        "Office Function": "D",
                        "Education Function": "B",
                        "Other Use Function": "A"
                    },
                    "1992 - 2005": {
                        "Meeting Function": "A",
                        "Healthcare Function": "D",
                        "Sport Function": "C",
                        "Cell Function": "C",
                        "Retail Function": "B",
                        "Industrial Function": "B",
                        "Accommodation Function": "A",
                        "Office Function": "C",
                        "Education Function": "A",
                        "Other Use Function": "B"
                    },
                    "2006 - 2014": {
                        "Meeting Function": "C",
                        "Healthcare Function": "D",
                        "Sport Function": "B",
                        "Cell Function": "C",
                        "Retail Function": "B",
                        "Industrial Function": "A",
                        "Accommodation Function": "D",
                        "Office Function": "D",
                        "Education Function": "B",
                        "Other Use Function": "A"
                    },
                    "2015 and later": {
                        "Meeting Function": "A",
                        "Healthcare Function": "D",
                        "Sport Function": "C",
                        "Cell Function": "C",
                        "Retail Function": "B",
                        "Industrial Function": "B",
                        "Accommodation Function": "A",
                        "Office Function": "C",
                        "Education Function": "A",
                        "Other Use Function": "B"
                    }
                }
            }
        },  # end pre_calibration






























        # =====================================================================
        # B) POST-CALIBRATION
        # =====================================================================
        "post_calibration": {
            "residential_infiltration_range": {
                "Corner House": (1.3, 1.3),
                "Apartment": (0.9, 0.9),
                "Terrace or Semi-detached House": (1.1, 1.1),
                "Detached House": (1.3, 1.3),
                "Two-and-a-half-story House": (1.2, 1.2),
                "other_res": (1.1, 1.1)
            },

            "non_res_infiltration_range": {
                "Meeting Function": (0.6, 0.6),
                "Healthcare Function": (0.7, 0.7),
                "Sport Function": (0.5, 0.5),
                "Cell Function": (0.6, 0.6),
                "Retail Function": (0.7, 0.7),
                "Industrial Function": (0.7, 0.7),  # example if you like
                "Accommodation Function": (0.6, 0.6),
                "Office Function": (0.6, 0.6),
                "Education Function": (0.6, 0.6),
                "Other Use Function": (0.6, 0.6),
                "other_nonres": (0.6, 0.6)
            },

            "year_factor_range": {
                "< 1945": (2.2, 2.2),
                "1945 - 1964": (1.9, 1.9),
                "1965 - 1974": (1.6, 1.6),
                "1975 - 1991": (1.4, 1.4),
                "1992 - 2005": (1.2, 1.2),
                "2006 - 2014": (1.0, 1.0),
                "2015 and later": (0.8, 0.8)
            },

            "system_control_range_res": {
                "A": {"f_ctrl_range": (1.0, 1.0)},
                "B": {"f_ctrl_range": (0.57, 0.57)},
                "C": {"f_ctrl_range": (0.85, 0.85)},
                "D": {"f_ctrl_range": (1.0, 1.0)}
            },
            "system_control_range_nonres": {
                "A": {"f_ctrl_range": (1.0, 1.0)},
                "B": {"f_ctrl_range": (0.85, 0.85)},
                "C": {"f_ctrl_range": (0.65, 0.65)},
                "D": {"f_ctrl_range": (0.8, 0.8)}
            },

            "fan_pressure_range": {
                "res_mech": (50, 50),
                "nonres_intake": (100, 100),
                "nonres_exhaust": (150, 150)
            },
            "hrv_sensible_eff_range": (0.75, 0.75),

            "system_type_map": {
                "residential": {
                    "< 1945": {
                        "Corner House": "B",
                        "Apartment": "C",
                        "Terrace or Semi-detached House": "C",
                        "Detached House": "D",
                        "Two-and-a-half-story House": "A"
                    },
                    "1945 - 1964": {
                        "Corner House": "A",
                        "Apartment": "C",
                        "Terrace or Semi-detached House": "D",
                        "Detached House": "D",
                        "Two-and-a-half-story House": "C"
                    },
                    "1965 - 1974": {
                        "Corner House": "C",
                        "Apartment": "B",
                        "Terrace or Semi-detached House": "C",
                        "Detached House": "D",
                        "Two-and-a-half-story House": "A"
                    },
                    "1975 - 1991": {
                        "Corner House": "B",
                        "Apartment": "C",
                        "Terrace or Semi-detached House": "B",
                        "Detached House": "C",
                        "Two-and-a-half-story House": "A"
                    },
                    "1992 - 2005": {
                        "Corner House": "C",
                        "Apartment": "A",
                        "Terrace or Semi-detached House": "C",
                        "Detached House": "D",
                        "Two-and-a-half-story House": "D"
                    },
                    "2006 - 2014": {
                        "Corner House": "D",
                        "Apartment": "D",
                        "Terrace or Semi-detached House": "C",
                        "Detached House": "C",
                        "Two-and-a-half-story House": "A"
                    },
                    "2015 and later": {
                        "Corner House": "D",
                        "Apartment": "C",
                        "Terrace or Semi-detached House": "A",
                        "Detached House": "B",
                        "Two-and-a-half-story House": "D"
                    }
                },
                "non_residential": {
                    "< 1945": {
                        "Meeting Function": "D",
                        "Healthcare Function": "D",
                        "Sport Function": "C",
                        "Cell Function": "C",
                        "Retail Function": "B",
                        "Industrial Function": "B",
                        "Accommodation Function": "A",
                        "Office Function": "C",
                        "Education Function": "A",
                        "Other Use Function": "B"
                    },
                    "1945 - 1964": {
                        "Meeting Function": "C",
                        "Healthcare Function": "D",
                        "Sport Function": "B",
                        "Cell Function": "C",
                        "Retail Function": "B",
                        "Industrial Function": "A",
                        "Accommodation Function": "D",
                        "Office Function": "D",
                        "Education Function": "B",
                        "Other Use Function": "A"
                    },
                    "1965 - 1974": {
                        "Meeting Function": "B",
                        "Healthcare Function": "C",
                        "Sport Function": "B",
                        "Cell Function": "C",
                        "Retail Function": "C",
                        "Industrial Function": "C",
                        "Accommodation Function": "B",
                        "Office Function": "B",
                        "Education Function": "D",
                        "Other Use Function": "A"
                    },
                    "1975 - 1991": {
                        "Meeting Function": "C",
                        "Healthcare Function": "D",
                        "Sport Function": "B",
                        "Cell Function": "C",
                        "Retail Function": "B",
                        "Industrial Function": "A",
                        "Accommodation Function": "D",
                        "Office Function": "D",
                        "Education Function": "B",
                        "Other Use Function": "A"
                    },
                    "1992 - 2005": {
                        "Meeting Function": "A",
                        "Healthcare Function": "D",
                        "Sport Function": "C",
                        "Cell Function": "C",
                        "Retail Function": "B",
                        "Industrial Function": "B",
                        "Accommodation Function": "A",
                        "Office Function": "C",
                        "Education Function": "A",
                        "Other Use Function": "B"
                    },
                    "2006 - 2014": {
                        "Meeting Function": "C",
                        "Healthcare Function": "D",
                        "Sport Function": "B",
                        "Cell Function": "C",
                        "Retail Function": "B",
                        "Industrial Function": "A",
                        "Accommodation Function": "D",
                        "Office Function": "D",
                        "Education Function": "B",
                        "Other Use Function": "A"
                    },
                    "2015 and later": {
                        "Meeting Function": "A",
                        "Healthcare Function": "D",
                        "Sport Function": "C",
                        "Cell Function": "C",
                        "Retail Function": "B",
                        "Industrial Function": "B",
                        "Accommodation Function": "A",
                        "Office Function": "C",
                        "Education Function": "A",
                        "Other Use Function": "B"
                    }
                }
            }
        }
    },

    # -------------------------------------------------------------------------
    # SCENARIO 2
    # -------------------------------------------------------------------------
    # -------------------------------------------------------------------------
    # SCENARIO 2 (fully populated, no placeholders)
    # -------------------------------------------------------------------------
    "scenario2": {
        # =====================================================================
        # A) PRE-CALIBRATION
        # =====================================================================
        "pre_calibration": {
            # -----------------------------------------------------------
            # 1) Infiltration ranges (for Residential sub‐types)
            # -----------------------------------------------------------
            "residential_infiltration_range": {
                "Corner House": (1.2, 1.4),
                "Apartment": (0.8, 1.0),
                "Terrace or Semi-detached House": (1.0, 1.2),
                "Detached House": (1.2, 1.5),
                "Two-and-a-half-story House": (1.1, 1.3),
                "other_res": (1.0, 1.2)
            },

            # -----------------------------------------------------------
            # 2) Infiltration ranges (for Non-Residential sub‐types)
            # -----------------------------------------------------------
            "non_res_infiltration_range": {
                "Meeting Function": (0.6, 0.8),
                "Healthcare Function": (0.7, 0.9),
                "Sport Function": (0.5, 0.7),
                "Cell Function": (0.6, 0.8),
                "Retail Function": (0.7, 0.9),
                "Industrial Function": (0.7, 1.0),
                "Accommodation Function": (0.5, 0.7),
                "Office Function": (0.6, 0.8),
                "Education Function": (0.6, 0.8),
                "Other Use Function": (0.6, 0.8),
                "other_nonres": (0.6, 0.8)
            },

            # -----------------------------------------------------------
            # 3) Year-of-construction factor ranges (7 age bands)
            # -----------------------------------------------------------
            "year_factor_range": {
                "< 1945": (2.1, 2.5),
                "1945 - 1964": (1.8, 2.2),
                "1965 - 1974": (1.6, 1.8),
                "1975 - 1991": (1.4, 1.6),
                "1992 - 2005": (1.2, 1.4),
                "2006 - 2014": (1.0, 1.2),
                "2015 and later": (0.8, 1.0)
            },

            # -----------------------------------------------------------
            # 4) System control factors (f_ctrl range) for each system
            # -----------------------------------------------------------
            "system_control_range_res": {
                "A": {"f_ctrl_range": (0.85, 0.95)},
                "B": {"f_ctrl_range": (0.45, 0.55)},
                "C": {"f_ctrl_range": (0.70, 0.80)},
                "D": {"f_ctrl_range": (0.90, 1.00)}
            },
            "system_control_range_nonres": {
                "A": {"f_ctrl_range": (0.85, 0.95)},
                "B": {"f_ctrl_range": (0.75, 0.85)},
                "C": {"f_ctrl_range": (0.55, 0.65)},
                "D": {"f_ctrl_range": (0.70, 0.80)}
            },

            # -----------------------------------------------------------
            # 5) Optional fan pressure ranges (if used)
            # -----------------------------------------------------------
            "fan_pressure_range": {
                "res_mech": (45, 65),
                "nonres_intake": (95, 115),
                "nonres_exhaust": (145, 165)
            },

            # -----------------------------------------------------------
            # 6) HRV sensible efficiency
            # -----------------------------------------------------------
            "hrv_sensible_eff_range": (0.65, 0.75),

            # -----------------------------------------------------------
            # 7) system_type_map - new table picking A/B/C/D
            # -----------------------------------------------------------
            "system_type_map": {
                "residential": {
                    "< 1945": {
                        "Corner House": "A",
                        "Apartment": "C",
                        "Terrace or Semi-detached House": "B",
                        "Detached House": "C",
                        "Two-and-a-half-story House": "A"
                    },
                    "1945 - 1964": {
                        "Corner House": "C",
                        "Apartment": "B",
                        "Terrace or Semi-detached House": "C",
                        "Detached House": "D",
                        "Two-and-a-half-story House": "C"
                    },
                    "1965 - 1974": {
                        "Corner House": "B",
                        "Apartment": "C",
                        "Terrace or Semi-detached House": "A",
                        "Detached House": "D",
                        "Two-and-a-half-story House": "C"
                    },
                    "1975 - 1991": {
                        "Corner House": "C",
                        "Apartment": "C",
                        "Terrace or Semi-detached House": "B",
                        "Detached House": "C",
                        "Two-and-a-half-story House": "A"
                    },
                    "1992 - 2005": {
                        "Corner House": "B",
                        "Apartment": "A",
                        "Terrace or Semi-detached House": "C",
                        "Detached House": "D",
                        "Two-and-a-half-story House": "D"
                    },
                    "2006 - 2014": {
                        "Corner House": "D",
                        "Apartment": "D",
                        "Terrace or Semi-detached House": "C",
                        "Detached House": "C",
                        "Two-and-a-half-story House": "A"
                    },
                    "2015 and later": {
                        "Corner House": "D",
                        "Apartment": "C",
                        "Terrace or Semi-detached House": "A",
                        "Detached House": "B",
                        "Two-and-a-half-story House": "D"
                    }
                },
                "non_residential": {
                    "< 1945": {
                        "Meeting Function": "D",
                        "Healthcare Function": "C",
                        "Sport Function": "C",
                        "Cell Function": "C",
                        "Retail Function": "B",
                        "Industrial Function": "B",
                        "Accommodation Function": "A",
                        "Office Function": "C",
                        "Education Function": "A",
                        "Other Use Function": "B"
                    },
                    "1945 - 1964": {
                        "Meeting Function": "C",
                        "Healthcare Function": "D",
                        "Sport Function": "B",
                        "Cell Function": "C",
                        "Retail Function": "B",
                        "Industrial Function": "A",
                        "Accommodation Function": "D",
                        "Office Function": "D",
                        "Education Function": "B",
                        "Other Use Function": "A"
                    },
                    "1965 - 1974": {
                        "Meeting Function": "B",
                        "Healthcare Function": "C",
                        "Sport Function": "B",
                        "Cell Function": "C",
                        "Retail Function": "C",
                        "Industrial Function": "C",
                        "Accommodation Function": "B",
                        "Office Function": "B",
                        "Education Function": "D",
                        "Other Use Function": "A"
                    },
                    "1975 - 1991": {
                        "Meeting Function": "C",
                        "Healthcare Function": "D",
                        "Sport Function": "B",
                        "Cell Function": "C",
                        "Retail Function": "B",
                        "Industrial Function": "A",
                        "Accommodation Function": "D",
                        "Office Function": "D",
                        "Education Function": "B",
                        "Other Use Function": "A"
                    },
                    "1992 - 2005": {
                        "Meeting Function": "A",
                        "Healthcare Function": "D",
                        "Sport Function": "C",
                        "Cell Function": "C",
                        "Retail Function": "B",
                        "Industrial Function": "B",
                        "Accommodation Function": "A",
                        "Office Function": "C",
                        "Education Function": "A",
                        "Other Use Function": "B"
                    },
                    "2006 - 2014": {
                        "Meeting Function": "C",
                        "Healthcare Function": "D",
                        "Sport Function": "B",
                        "Cell Function": "C",
                        "Retail Function": "B",
                        "Industrial Function": "A",
                        "Accommodation Function": "D",
                        "Office Function": "D",
                        "Education Function": "B",
                        "Other Use Function": "A"
                    },
                    "2015 and later": {
                        "Meeting Function": "A",
                        "Healthcare Function": "D",
                        "Sport Function": "C",
                        "Cell Function": "C",
                        "Retail Function": "B",
                        "Industrial Function": "B",
                        "Accommodation Function": "A",
                        "Office Function": "C",
                        "Education Function": "A",
                        "Other Use Function": "B"
                    }
                }
            }
        },  # end pre_calibration

        # =====================================================================
        # B) POST-CALIBRATION
        # =====================================================================
        "post_calibration": {
            "residential_infiltration_range": {
                "Corner House": (1.3, 1.3),
                "Apartment": (0.9, 0.9),
                "Terrace or Semi-detached House": (1.1, 1.1),
                "Detached House": (1.3, 1.3),
                "Two-and-a-half-story House": (1.2, 1.2),
                "other_res": (1.1, 1.1)
            },

            "non_res_infiltration_range": {
                "Meeting Function": (0.7, 0.7),
                "Healthcare Function": (0.8, 0.8),
                "Sport Function": (0.6, 0.6),
                "Cell Function": (0.7, 0.7),
                "Retail Function": (0.8, 0.8),
                "Industrial Function": (0.8, 0.8),
                "Accommodation Function": (0.7, 0.7),
                "Office Function": (0.7, 0.7),
                "Education Function": (0.7, 0.7),
                "Other Use Function": (0.7, 0.7),
                "other_nonres": (0.7, 0.7)
            },

            "year_factor_range": {
                "< 1945": (2.3, 2.3),
                "1945 - 1964": (2.0, 2.0),
                "1965 - 1974": (1.7, 1.7),
                "1975 - 1991": (1.5, 1.5),
                "1992 - 2005": (1.3, 1.3),
                "2006 - 2014": (1.1, 1.1),
                "2015 and later": (0.9, 0.9)
            },

            "system_control_range_res": {
                "A": {"f_ctrl_range": (1.0, 1.0)},
                "B": {"f_ctrl_range": (0.60, 0.60)},
                "C": {"f_ctrl_range": (0.80, 0.80)},
                "D": {"f_ctrl_range": (0.95, 0.95)}
            },
            "system_control_range_nonres": {
                "A": {"f_ctrl_range": (1.0, 1.0)},
                "B": {"f_ctrl_range": (0.80, 0.80)},
                "C": {"f_ctrl_range": (0.60, 0.60)},
                "D": {"f_ctrl_range": (0.75, 0.75)}
            },

            "fan_pressure_range": {
                "res_mech": (55, 55),
                "nonres_intake": (105, 105),
                "nonres_exhaust": (155, 155)
            },
            "hrv_sensible_eff_range": (0.70, 0.70),

            "system_type_map": {
                "residential": {
                    "< 1945": {
                        "Corner House": "B",
                        "Apartment": "C",
                        "Terrace or Semi-detached House": "C",
                        "Detached House": "D",
                        "Two-and-a-half-story House": "A"
                    },
                    "1945 - 1964": {
                        "Corner House": "A",
                        "Apartment": "B",
                        "Terrace or Semi-detached House": "D",
                        "Detached House": "D",
                        "Two-and-a-half-story House": "C"
                    },
                    "1965 - 1974": {
                        "Corner House": "C",
                        "Apartment": "B",
                        "Terrace or Semi-detached House": "C",
                        "Detached House": "D",
                        "Two-and-a-half-story House": "A"
                    },
                    "1975 - 1991": {
                        "Corner House": "B",
                        "Apartment": "C",
                        "Terrace or Semi-detached House": "B",
                        "Detached House": "C",
                        "Two-and-a-half-story House": "A"
                    },
                    "1992 - 2005": {
                        "Corner House": "C",
                        "Apartment": "A",
                        "Terrace or Semi-detached House": "C",
                        "Detached House": "D",
                        "Two-and-a-half-story House": "D"
                    },
                    "2006 - 2014": {
                        "Corner House": "D",
                        "Apartment": "D",
                        "Terrace or Semi-detached House": "C",
                        "Detached House": "C",
                        "Two-and-a-half-story House": "A"
                    },
                    "2015 and later": {
                        "Corner House": "D",
                        "Apartment": "C",
                        "Terrace or Semi-detached House": "A",
                        "Detached House": "B",
                        "Two-and-a-half-story House": "D"
                    }
                },
                "non_residential": {
                    "< 1945": {
                        "Meeting Function": "D",
                        "Healthcare Function": "C",
                        "Sport Function": "C",
                        "Cell Function": "C",
                        "Retail Function": "B",
                        "Industrial Function": "B",
                        "Accommodation Function": "A",
                        "Office Function": "C",
                        "Education Function": "A",
                        "Other Use Function": "B"
                    },
                    "1945 - 1964": {
                        "Meeting Function": "C",
                        "Healthcare Function": "D",
                        "Sport Function": "B",
                        "Cell Function": "C",
                        "Retail Function": "B",
                        "Industrial Function": "A",
                        "Accommodation Function": "D",
                        "Office Function": "D",
                        "Education Function": "B",
                        "Other Use Function": "A"
                    },
                    "1965 - 1974": {
                        "Meeting Function": "B",
                        "Healthcare Function": "C",
                        "Sport Function": "B",
                        "Cell Function": "C",
                        "Retail Function": "C",
                        "Industrial Function": "C",
                        "Accommodation Function": "B",
                        "Office Function": "B",
                        "Education Function": "D",
                        "Other Use Function": "A"
                    },
                    "1975 - 1991": {
                        "Meeting Function": "C",
                        "Healthcare Function": "D",
                        "Sport Function": "B",
                        "Cell Function": "C",
                        "Retail Function": "B",
                        "Industrial Function": "A",
                        "Accommodation Function": "D",
                        "Office Function": "D",
                        "Education Function": "B",
                        "Other Use Function": "A"
                    },
                    "1992 - 2005": {
                        "Meeting Function": "A",
                        "Healthcare Function": "D",
                        "Sport Function": "C",
                        "Cell Function": "C",
                        "Retail Function": "B",
                        "Industrial Function": "B",
                        "Accommodation Function": "A",
                        "Office Function": "C",
                        "Education Function": "A",
                        "Other Use Function": "B"
                    },
                    "2006 - 2014": {
                        "Meeting Function": "C",
                        "Healthcare Function": "D",
                        "Sport Function": "B",
                        "Cell Function": "C",
                        "Retail Function": "B",
                        "Industrial Function": "A",
                        "Accommodation Function": "D",
                        "Office Function": "D",
                        "Education Function": "B",
                        "Other Use Function": "A"
                    },
                    "2015 and later": {
                        "Meeting Function": "A",
                        "Healthcare Function": "D",
                        "Sport Function": "C",
                        "Cell Function": "C",
                        "Retail Function": "B",
                        "Industrial Function": "B",
                        "Accommodation Function": "A",
                        "Office Function": "C",
                        "Education Function": "A",
                        "Other Use Function": "B"
                    }
                }
            }
        }
    }
}

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\ventilation\schedules.py
============================================================
# ventilation/schedules.py

from typing import List, Tuple, Optional, Any # Keep Any for type hints

# Import IDF class for type hinting (assuming geomeppy is used)
try:
    from geomeppy import IDF
    # We cannot reliably get the IDFObject type at module level without an instance.
    # Use Any or a more generic type hint for IDF objects within function signatures if needed.
except ImportError:
    IDF = Any # Fallback if geomeppy not available

# Helper function to ensure ScheduleTypeLimits exist
def ensure_schedule_type_limits(idf: IDF, limits_name: str, numeric_type: str = "Continuous", unit_type: Optional[str] = None):
    """Checks if ScheduleTypeLimits exists, creates it if not."""
    # Use uppercase for case-insensitive check with getobject
    if not idf.getobject("SCHEDULETYPELIMITS", limits_name.upper()):
        print(f"[INFO] Creating ScheduleTypeLimits: {limits_name}")
        try:
            lims = idf.newidfobject("SCHEDULETYPELIMITS")
            lims.Name = limits_name
            lims.Numeric_Type = numeric_type
            if unit_type:
                lims.Unit_Type = unit_type
            # Set default lower/upper limits (often left blank in E+ for defaults)
            # Example: lims.Lower_Limit_Value = 0.0
            # Example: lims.Upper_Limit_Value = 1.0 # For Fraction type
            return lims
        except Exception as e:
            print(f"[ERROR] Failed to create SCHEDULETYPELIMITS {limits_name}: {e}")
            return None # Return None if creation failed
    return idf.getobject("SCHEDULETYPELIMITS", limits_name.upper())


def create_always_on_schedule(idf: IDF, sched_name: str = "AlwaysOnSched") -> Optional[Any]: # Return type hint Any or specific eppy/geomeppy type if known
    """
    Creates or retrieves a SCHEDULE:CONSTANT representing a value of 1.0 (Fraction).

    Args:
        idf: The geomeppy IDF object.
        sched_name: The desired name for the schedule.

    Returns:
        The schedule object or None if creation fails.
    """
    # Ensure the required ScheduleTypeLimits exists
    limits_obj = ensure_schedule_type_limits(idf, "Fraction", numeric_type="Continuous", unit_type="Dimensionless")
    if not limits_obj:
        print(f"[ERROR] Could not ensure ScheduleTypeLimits 'Fraction' for {sched_name}.")
        return None # Cannot create schedule without limits

    # Check if schedule already exists (case-insensitive check)
    existing = idf.getobject("SCHEDULE:CONSTANT", sched_name.upper())
    if existing:
        return existing

    try:
        schedule = idf.newidfobject("SCHEDULE:CONSTANT")
        schedule.Name = sched_name
        schedule.Schedule_Type_Limits_Name = "Fraction" # Reference the limits object
        schedule.Hourly_Value = 1.0
        return schedule
    except Exception as e:
        print(f"[ERROR] Failed to create SCHEDULE:CONSTANT {sched_name}: {e}")
        return None


def create_day_night_schedule(idf: IDF, sched_name: str = "VentSched_DayNight") -> Optional[Any]:
    """
    Creates or retrieves a SCHEDULE:COMPACT for Day/Night operation.
    Example: 0.5 fraction at night (22:00-06:00), 1.0 during the day (06:00-22:00).

    Args:
        idf: The geomeppy IDF object.
        sched_name: The desired name for the schedule.

    Returns:
        The schedule object or None if creation fails.
    """
    limits_obj = ensure_schedule_type_limits(idf, "Fraction", numeric_type="Continuous", unit_type="Dimensionless")
    if not limits_obj:
        print(f"[ERROR] Could not ensure ScheduleTypeLimits 'Fraction' for {sched_name}.")
        return None

    existing = idf.getobject("SCHEDULE:COMPACT", sched_name.upper())
    if existing:
        return existing

    try:
        schedule = idf.newidfobject("SCHEDULE:COMPACT")
        schedule.Name = sched_name
        schedule.Schedule_Type_Limits_Name = "Fraction"

        # Define the schedule profile
        schedule.Field_1 = "Through: 12/31"     # Apply for the whole year
        schedule.Field_2 = "For: AllDays"        # Apply to all days
        schedule.Field_3 = "Until: 06:00,0.5"    # Value from midnight until 6:00 is 0.5
        schedule.Field_4 = "Until: 22:00,1.0"    # Value from 6:00 until 22:00 is 1.0
        schedule.Field_5 = "Until: 24:00,0.5"    # Value from 22:00 until midnight is 0.5
        return schedule
    except Exception as e:
        print(f"[ERROR] Failed to create SCHEDULE:COMPACT {sched_name}: {e}")
        return None


def create_workhours_schedule(idf: IDF, sched_name: str = "WorkHoursSched") -> Optional[Any]:
    """
    Creates or retrieves a SCHEDULE:COMPACT for typical Work Hours.
      - Weekdays: 0.2 (unoccupied), 1.0 (09:00-17:00), 0.2 (unoccupied)
      - Weekends/Holidays: 0.2 all day

    Args:
        idf: The geomeppy IDF object.
        sched_name: The desired name for the schedule.

    Returns:
        The schedule object or None if creation fails.
    """
    limits_obj = ensure_schedule_type_limits(idf, "Fraction", numeric_type="Continuous", unit_type="Dimensionless")
    if not limits_obj:
        print(f"[ERROR] Could not ensure ScheduleTypeLimits 'Fraction' for {sched_name}.")
        return None

    existing = idf.getobject("SCHEDULE:COMPACT", sched_name.upper())
    if existing:
        return existing

    try:
        schedule = idf.newidfobject("SCHEDULE:COMPACT")
        schedule.Name = sched_name
        schedule.Schedule_Type_Limits_Name = "Fraction"

        # Define the schedule profile
        schedule.Field_1 = "Through: 12/31"                 # Apply for the whole year
        schedule.Field_2 = "For: Weekdays"                   # Rules for weekdays
        schedule.Field_3 = "Until: 09:00,0.2"                # Value until 9:00 is 0.2
        schedule.Field_4 = "Until: 17:00,1.0"                # Value until 17:00 is 1.0
        schedule.Field_5 = "Until: 24:00,0.2"                # Value until midnight is 0.2
        schedule.Field_6 = "For: Saturday Sunday Holiday"  # Rules for weekends/holidays
        schedule.Field_7 = "Until: 24:00,0.2"                # Value all day is 0.2
        return schedule
    except Exception as e:
        print(f"[ERROR] Failed to create SCHEDULE:COMPACT {sched_name}: {e}")
        return None


# Define type hint for the pattern tuples
SchedulePattern = List[Tuple[int, int, float]]

def create_schedule_from_pattern(
    idf: IDF,
    sched_name: str,
    pattern: SchedulePattern,
    schedule_type_limits: str = "Fraction"
) -> Optional[Any]:
    """
    Creates or retrieves a SCHEDULE:COMPACT from a single pattern applied to AllDays.

    Args:
        idf: geomeppy IDF instance.
        sched_name: Name for the schedule in EnergyPlus.
        pattern: List of (start_hour, end_hour, value) tuples defining the daily profile.
                 Hours are 0-24. The pattern should cover the full 24 hours.
                 Example: [(0, 6, 0.5), (6, 22, 1.0), (22, 24, 0.5)]
                 Note: start_hour is inclusive, end_hour is exclusive in pattern logic,
                       but for "Until: HH:MM,Value", HH:MM is the end time of the period.
        schedule_type_limits: Name of the ScheduleTypeLimits object (e.g., "Fraction").

    Returns:
        The schedule object or None if creation fails.
    """
    # Ensure the ScheduleTypeLimits object exists (e.g., "Fraction", "Temperature")
    # Determine unit_type for ensure_schedule_type_limits based on common schedule_type_limits names
    limit_unit_type = "Dimensionless" # Default for Fraction
    if schedule_type_limits.lower() == "temperature":
        limit_unit_type = "Temperature"
    elif schedule_type_limits.lower() == "on/off": # Or "Control Type"
        limit_unit_type = "Dimensionless" # Or a specific control type unit if defined
    # Add other common types as needed

    limits_obj = ensure_schedule_type_limits(idf, schedule_type_limits, unit_type=limit_unit_type) # Ensure limits exist
    if not limits_obj:
        print(f"[ERROR] Could not ensure ScheduleTypeLimits '{schedule_type_limits}' for {sched_name}.")
        return None

    existing = idf.getobject("SCHEDULE:COMPACT", sched_name.upper())
    if existing:
        return existing

    if not pattern:
        print(f"[ERROR] Empty pattern provided for schedule {sched_name}. Cannot create.")
        return None

    try:
        sched_obj = idf.newidfobject("SCHEDULE:COMPACT")
        sched_obj.Name = sched_name
        sched_obj.Schedule_Type_Limits_Name = schedule_type_limits

        field_idx = 1
        sched_obj[f"Field_{field_idx}"] = "Through: 12/31"
        field_idx += 1
        sched_obj[f"Field_{field_idx}"] = "For: AllDays"
        field_idx += 1

        # Sort pattern by end_hour just in case, though E+ compact schedule fields are sequential.
        # The pattern [(0,6,0.5), (6,22,1.0), (22,24,0.5)] means:
        # Until 06:00, value is 0.5 (covers 00:00 to 06:00)
        # Until 22:00, value is 1.0 (covers 06:00 to 22:00)
        # Until 24:00, value is 0.5 (covers 22:00 to 24:00)
        sorted_pattern = sorted(pattern, key=lambda x: x[1]) # x[1] is end_hr

        last_pattern_end_hour = 0
        for (start_hr, end_hr, val) in sorted_pattern:
            # Basic validation for pattern elements
            if not (isinstance(start_hr, int) and isinstance(end_hr, int) and isinstance(val, (int, float))):
                print(f"[WARNING] Invalid data types in pattern segment ({start_hr}, {end_hr}, {val}) for {sched_name}. Skipping.")
                continue
            # Ensure chronological order and valid hour ranges (0-24 for end_hr)
            if end_hr <= last_pattern_end_hour or end_hr > 24 or start_hr < 0 or start_hr >= end_hr:
                print(f"[WARNING] Invalid time segment ({start_hr}-{end_hr}) in pattern for {sched_name}. Last end hour was {last_pattern_end_hour}. Skipping segment.")
                continue

            # Format "Until: HH:MM,Value"
            # Ensure HH is zero-padded if less than 10.
            line_str = f"Until: {end_hr:02d}:00,{val:.4f}" # Format value for consistency (e.g., 4 decimal places)
            
            # Dynamically assign fields; geomeppy/eppy usually handle field count limits.
            sched_obj[f"Field_{field_idx}"] = line_str
            field_idx += 1
            last_pattern_end_hour = end_hr

        # Check if the pattern covers the full 24 hours based on the last segment's end_hr.
        if last_pattern_end_hour < 24:
            print(f"[WARNING] Pattern for schedule {sched_name} does not cover until 24:00. Last segment ended at {last_pattern_end_hour}:00. EnergyPlus might fill with the last value or error.")

        return sched_obj
    except Exception as e:
        print(f"[ERROR] Failed to create SCHEDULE:COMPACT {sched_name} from pattern: {e}")
        return None

def create_schedule_from_weekday_weekend_pattern(
    idf: IDF,
    sched_name: str,
    weekday_pattern: SchedulePattern,
    weekend_pattern: SchedulePattern, # Can be the same as weekday_pattern if only one profile needed for all days
    schedule_type_limits="Fraction"
) -> Optional[Any]:
    """
    Creates or retrieves a SCHEDULE:COMPACT with different profiles for
    Weekdays and Weekends/Holidays.

    Args:
        idf: geomeppy IDF instance.
        sched_name: Name for the schedule in EnergyPlus.
        weekday_pattern: List of (start_hr, end_hr, value) for Weekdays.
        weekend_pattern: List of (start_hr, end_hr, value) for Sat/Sun/Holiday.
        schedule_type_limits: Name of the ScheduleTypeLimits object.

    Returns:
        The schedule object or None if creation fails.
    """
    limit_unit_type = "Dimensionless"
    if schedule_type_limits.lower() == "temperature": limit_unit_type = "Temperature"
    # Add more type mappings as needed

    limits_obj = ensure_schedule_type_limits(idf, schedule_type_limits, unit_type=limit_unit_type)
    if not limits_obj:
        print(f"[ERROR] Could not ensure ScheduleTypeLimits '{schedule_type_limits}' for {sched_name}.")
        return None

    existing = idf.getobject("SCHEDULE:COMPACT", sched_name.upper())
    if existing:
        return existing

    if not weekday_pattern or not weekend_pattern: # Both patterns must be provided
        print(f"[ERROR] Weekday or weekend pattern missing for schedule {sched_name}. Cannot create.")
        return None

    try:
        sched_obj = idf.newidfobject("SCHEDULE:COMPACT")
        sched_obj.Name = sched_name
        sched_obj.Schedule_Type_Limits_Name = schedule_type_limits

        field_idx = 1
        sched_obj[f"Field_{field_idx}"] = "Through: 12/31"
        field_idx += 1

        # --- Weekday Rules ---
        sched_obj[f"Field_{field_idx}"] = "For: Weekdays"
        field_idx += 1
        sorted_weekday = sorted(weekday_pattern, key=lambda x: x[1])
        last_end_hour_wd = 0
        for (start_hr, end_hr, val) in sorted_weekday:
            if not (isinstance(start_hr, int) and isinstance(end_hr, int) and isinstance(val, (int, float))): continue # Skip malformed
            if end_hr <= last_end_hour_wd or end_hr > 24 or start_hr < 0 or start_hr >= end_hr: continue # Basic validation
            sched_obj[f"Field_{field_idx}"] = f"Until: {end_hr:02d}:00,{val:.4f}"
            field_idx += 1
            last_end_hour_wd = end_hr
        if last_end_hour_wd < 24: print(f"[WARNING] Weekday pattern for {sched_name} doesn't cover 24h. Last segment ended at {last_end_hour_wd}:00.")

        # --- Weekend/Holiday Rules ---
        # Note: EnergyPlus allows "For: Weekends", "For: Holidays", "For: AllOtherDays" etc.
        # "Saturday Sunday Holiday" is a common combination.
        sched_obj[f"Field_{field_idx}"] = "For: Saturday Sunday Holiday"
        field_idx += 1
        sorted_weekend = sorted(weekend_pattern, key=lambda x: x[1])
        last_end_hour_we = 0
        for (start_hr, end_hr, val) in sorted_weekend:
            if not (isinstance(start_hr, int) and isinstance(end_hr, int) and isinstance(val, (int, float))): continue
            if end_hr <= last_end_hour_we or end_hr > 24 or start_hr < 0 or start_hr >= end_hr: continue # Basic validation
            sched_obj[f"Field_{field_idx}"] = f"Until: {end_hr:02d}:00,{val:.4f}"
            field_idx += 1
            last_end_hour_we = end_hr
        if last_end_hour_we < 24: print(f"[WARNING] Weekend pattern for {sched_name} doesn't cover 24h. Last segment ended at {last_end_hour_we}:00.")

        return sched_obj
    except Exception as e:
        print(f"[ERROR] Failed to create SCHEDULE:COMPACT {sched_name} from weekday/weekend patterns: {e}")
        return None


def ensure_dynamic_schedule(
    idf: IDF,
    sched_name: str,
    weekday_pattern: Optional[SchedulePattern] = None,
    weekend_pattern: Optional[SchedulePattern] = None, # If None, and weekday_pattern is given, could apply weekday to AllDays
    schedule_type_limits="Fraction"
) -> Optional[Any]:
    """
    Convenience function to create/retrieve a schedule:
      - If only weekday_pattern is provided (and weekend_pattern is None), applies it to AllDays.
      - If both weekday_pattern and weekend_pattern are provided, creates a Weekday/Weekend schedule.
      - If neither pattern is provided, falls back to creating an AlwaysOn schedule with the given sched_name.

    Args:
        idf: geomeppy IDF instance.
        sched_name: Desired name for the schedule.
        weekday_pattern: Optional pattern for weekdays.
        weekend_pattern: Optional pattern for weekends. If None, weekday_pattern is used for AllDays.
        schedule_type_limits: Name of the limits object.

    Returns:
        The created or retrieved schedule object, or None on failure.
    """
    # Check if schedule already exists (case-insensitive for both Compact and Constant)
    existing_compact = idf.getobject("SCHEDULE:COMPACT", sched_name.upper())
    if existing_compact:
        return existing_compact
    existing_constant = idf.getobject("SCHEDULE:CONSTANT", sched_name.upper())
    if existing_constant:
        # If a Constant schedule exists with this name:
        # - If no patterns were provided, this is the intended AlwaysOn, so return it.
        # - If patterns *were* provided, it's a conflict. Warn and return the Constant.
        if not weekday_pattern and not weekend_pattern: # No new pattern, existing constant is fine
            return existing_constant
        else: # New patterns provided, but a constant with same name exists.
            print(f"[WARNING] Dynamic patterns provided for '{sched_name}', but a SCHEDULE:CONSTANT with this name already exists. Returning the existing Constant schedule. Consider using a different name for the dynamic schedule.")
            return existing_constant

    # Create new schedule based on provided patterns
    if weekday_pattern and weekend_pattern:
        # Both weekday and weekend patterns are distinct
        return create_schedule_from_weekday_weekend_pattern(
            idf, sched_name, weekday_pattern, weekend_pattern, schedule_type_limits
        )
    elif weekday_pattern: # Only weekday pattern provided (weekend_pattern is None or implicitly same)
        # Apply weekday_pattern to AllDays
        return create_schedule_from_pattern(
            idf, sched_name, weekday_pattern, schedule_type_limits
        )
    else: # No patterns provided, fallback to AlwaysOn (or Always Off if value is 0)
        # This implies an "always 1.0" schedule if type limits are Fraction.
        # If a different constant value is needed, this function would need modification or
        # create_always_on_schedule would need a value parameter.
        print(f"[INFO] No patterns provided for '{sched_name}'. Falling back to creating/retrieving an AlwaysOn (value 1.0) schedule.")
        return create_always_on_schedule(idf, sched_name) # Assumes "Fraction" and value 1.0
------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\ventilation\schedule_lookup.py
============================================================
# ventilation/schedule_lookup.py

"""
This file defines SCHEDULE_LOOKUP, a dictionary organizing realistic, ranged
schedule patterns for building archetypes, suitable for energy modeling.

Rationale for Improvement:
1.  More Detailed Time Slices: Schedules are broken down into more granular periods,
    including morning/evening peaks, daytime setbacks, lunch breaks, and janitorial
    hours to better capture building dynamics.
2.  Logic-Driven Ranges: The (min, max) value ranges are not arbitrary.
    - A low minimum (e.g., 0.0-0.1) during unoccupied hours reflects Demand-Controlled
      Ventilation (DCV) providing minimal background airflow.
    - A tight, high range (e.g., 0.95-1.0) during peak occupancy represents the
      system running at full design capacity.
    - Broader ranges during shoulder periods represent operational uncertainty.
3.  Clearer Ventilation vs. Infiltration Logic:
    - Ventilation (Mechanical): This schedule is a proxy for occupancy and internal
      loads. It is significantly reduced or turned off when the building is empty.
    - Infiltration (Natural): This schedule represents the 'availability' of leakage
      paths. For non-residential buildings, it is modeled as being higher when the
      mechanical ventilation is off (no pressurization) and lower during operational
      hours. For residential buildings, it remains high, proxying for occupant presence
      and window-opening behavior.

Structure:
SCHEDULE_LOOKUP[building_function][archetype_key][purpose][day_type]
"""

SCHEDULE_LOOKUP = {
    # =====================================================================
    # Residential Building Schedules
    # =====================================================================
    "residential": {
        "default": {  # Fallback: A typical family home pattern
            "ventilation": {
                # Weekday: People leave for work/school.
                "weekday": [(0, 6, (0.30, 0.50)),    # Night setback
                            (6, 9, (0.80, 1.00)),    # Morning peak (showers, breakfast)
                            (9, 16, (0.40, 0.60)),   # Daytime low (unoccupied/less active)
                            (16, 22, (0.90, 1.00)),  # Evening peak (cooking, activity)
                            (22, 24, (0.30, 0.50))], # Night setback
                # Weekend: People are home more often and activity is spread out.
                "weekend": [(0, 8, (0.40, 0.60)),    # Later night setback
                            (8, 23, (0.85, 1.00)),   # Broad, high daytime activity
                            (23, 24, (0.40, 0.60))], # Night setback
            },
            "infiltration": {
                # Potential for infiltration and window opening is always high when occupied.
                "allday": [(0, 24, (0.90, 1.00))],
            }
        },
        "Apartment": { # Often smaller, with quicker temperature/air quality changes.
            "ventilation": {
                "weekday": [(0, 6, (0.25, 0.40)), (6, 9, (0.85, 1.00)), (9, 17, (0.30, 0.50)), (17, 23, (0.95, 1.00)), (23, 24, (0.25, 0.40))],
                "weekend": [(0, 8, (0.40, 0.60)), (8, 23, (0.90, 1.00)), (23, 24, (0.40, 0.60))],
            },
            "infiltration": {
                "allday": [(0, 24, (0.90, 1.00))],
            }
        },
    },

    # =====================================================================
    # Non-Residential Building Schedules
    # =====================================================================
    "non_residential": {
        "default": {  # Fallback: Generic 9-5 Office.
            "ventilation": {
                "weekday": [(0, 7, (0.00, 0.10)), (7, 18, (0.90, 1.00)), (18, 24, (0.00, 0.10))],
                "weekend": [(0, 24, (0.00, 0.05))],
            },
            "infiltration": {
                "weekday": [(0, 7, (0.80, 1.00)), (7, 18, (0.30, 0.50)), (18, 24, (0.80, 1.00))],
                "weekend": [(0, 24, (0.90, 1.00))]
            }
        },
        "Office Function": {
            "ventilation": {
                "weekday": [(0, 7, (0.05, 0.15)),    # Night/unoccupied DCV rate
                            (7, 9, (0.95, 1.00)),    # Morning arrival peak
                            (9, 12, (0.90, 1.00)),   # Core morning work
                            (12, 14, (0.70, 0.85)),  # Lunch period dip
                            (14, 17, (0.90, 1.00)),  # Core afternoon work
                            (17, 18, (0.60, 0.80)),  # People leaving
                            (18, 20, (0.20, 0.30)),  # Cleaning crew period
                            (20, 24, (0.05, 0.15))], # Unoccupied
                "weekend": [(0, 24, (0.00, 0.10))],  # Weekend (minimal/off)
            },
            "infiltration": {
                "weekday": [(0, 7, (0.80, 1.00)), (7, 18, (0.25, 0.45)), (18, 24, (0.80, 1.00))], # Suppressed by HVAC pressure during day
                "weekend": [(0, 24, (0.90, 1.00))],
            }
        },
        "Retail Function": { # Assumes a store in a shopping street or mall
            "ventilation": {
                "weekday": [(0, 8, (0.05, 0.10)),    # Pre-opening
                            (8, 10, (0.70, 0.90)),   # Opening/stocking
                            (10, 19, (0.95, 1.00)),  # Peak customer hours
                            (19, 21, (0.40, 0.60)),  # Closing/cleaning
                            (21, 24, (0.05, 0.10))], # Closed
                "weekend": [(0, 9, (0.05, 0.15)),    # Saturday/Sunday opening prep
                            (9, 18, (0.95, 1.00)),   # Peak weekend customers
                            (18, 20, (0.40, 0.60)),  # Closing
                            (20, 24, (0.05, 0.15))], # Closed
            },
            "infiltration": { # Dominated by door openings
                "weekday": [(0, 9, (0.40, 0.60)), (9, 20, (0.80, 1.00)), (20, 24, (0.40, 0.60))],
                "weekend": [(0, 9, (0.40, 0.60)), (9, 19, (0.90, 1.00)), (19, 24, (0.40, 0.60))],
            }
        },
        "Education Function": { # School
            "ventilation": {
                "weekday": [(0, 7, (0.00, 0.10)),    # Unoccupied
                            (7, 12, (0.95, 1.00)),   # Morning classes
                            (12, 13, (0.50, 0.70)),  # Lunch break (less classroom occupancy)
                            (13, 16, (0.95, 1.00)),  # Afternoon classes
                            (16, 18, (0.30, 0.50)),  # After-school care / activities
                            (18, 24, (0.00, 0.10))], # Closed
                "weekend": [(0, 24, (0.00, 0.05))],  # No regular activity
            },
            "infiltration": {
                "weekday": [(0, 7, (0.70, 0.90)), (7, 17, (0.40, 0.60)), (17, 24, (0.70, 0.90))],
                "weekend": [(0, 24, (0.80, 1.00))],
            }
        },
        "Healthcare Function": { # Hospital (24/7 operation)
            "ventilation": {
                # High minimum rates required at all times.
                "allday": [(0, 7, (0.65, 0.80)),    # Night (lower activity, but still high demand)
                           (7, 21, (0.90, 1.00)),   # Daytime (procedures, visitors)
                           (21, 24, (0.65, 0.80))], # Evening/early night
            },
            "infiltration": {
                # Often pressurized; infiltration is minimized and controlled.
                "allday": [(0, 24, (0.10, 0.25))]
            }
        },
        "Accommodation Function": { # Hotel
             "ventilation": {
                "allday": [(0, 6, (0.50, 0.70)),    # Night (occupied rooms)
                           (6, 10, (0.85, 1.00)),   # Morning checkout/breakfast peak
                           (10, 16, (0.40, 0.60)),  # Mid-day low (guests out, cleaning)
                           (16, 24, (0.90, 1.00))], # Evening check-in / guests returning
            },
            "infiltration": {
                "allday": [(0, 24, (0.60, 0.80))] # Higher quality construction than average residential
            }
        },
    }
}
------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\ventilation\mappings.py
============================================================
# ventilation/mappings.py
from typing import Optional, Dict, Any, Set

# Define type alias for building_row for clarity
BuildingRow = Dict[str, Any]

def safe_lower(val: Optional[Any]) -> str:
    """Helper to safely lowercase a string, returning empty string for non-strings."""
    if isinstance(val, str):
        return val.lower()
    return ""

def map_age_range_to_year_key(age_range_str: Optional[str]) -> str:
    """
    Converts a building_row's age_range string into one of the 7 standard keys
    used in ventilation_lookup (e.g., "< 1945", "1945 - 1964", etc.).

    Args:
        age_range_str: The age range string from the building data.

    Returns:
        The corresponding standard key, or "2015 and later" as a fallback.
    """
    # Explicitly define the valid keys expected by the lookup table
    valid_keys: Dict[str, str] = {
        "< 1945": "< 1945",
        "1945 - 1964": "1945 - 1964",
        "1965 - 1974": "1965 - 1974",
        "1975 - 1991": "1975 - 1991",
        "1992 - 2005": "1992 - 2005",
        "2006 - 2014": "2006 - 2014",
        "2015 and later": "2015 and later"
    }
    # Use .get() for safe lookup with a default fallback
    return valid_keys.get(str(age_range_str), "2015 and later")

def map_infiltration_key(building_row: BuildingRow) -> str:
    """
    Determines the appropriate key for looking up infiltration ranges based on
    the building's function and specific type.

    - Residential buildings use their 'residential_type' field.
    - Non-residential buildings use their 'non_residential_type' field.
    - Fallbacks ('other_res', 'other_nonres') are used if the specific type
      is not recognized or missing.

    Args:
        building_row: The dictionary containing building data.

    Returns:
        A string key matching those used in the ventilation_lookup dictionary's
        infiltration range sections.
    """
    bldg_func = safe_lower(building_row.get("building_function", "residential"))

    if bldg_func == "residential":
        res_type = building_row.get("residential_type")
        # Explicit set of known residential type keys used in the lookup
        valid_res_types: Set[str] = {
            "Corner House",
            "Apartment",
            "Terrace or Semi-detached House",
            "Detached House",
            "Two-and-a-half-story House"
            # Add any other specific keys expected in ventilation_lookup here
        }
        if res_type in valid_res_types:
            return res_type
        else:
            # print(f"[DEBUG] Unknown residential_type '{res_type}', using fallback 'other_res'.")
            return "other_res" # Fallback key
    else: # Non-residential
        nonres_type = building_row.get("non_residential_type")
        # Explicit set of known non-residential type keys used in the lookup
        valid_nonres_types: Set[str] = {
            "Meeting Function",
            "Healthcare Function",
            "Sport Function",
            "Cell Function",
            "Retail Function",
            "Industrial Function",
            "Accommodation Function",
            "Office Function",
            "Education Function",
            "Other Use Function"
             # Add any other specific keys expected in ventilation_lookup here
        }
        if nonres_type in valid_nonres_types:
            return nonres_type
        else:
            # print(f"[DEBUG] Unknown non_residential_type '{nonres_type}', using fallback 'other_nonres'.")
            return "other_nonres" # Fallback key

def map_usage_key(building_row: BuildingRow) -> Optional[str]:
    """
    Determines the appropriate key for looking up non-residential ventilation flow rates.

    Returns None for residential buildings.
    For non-residential, maps the 'non_residential_type' to a simplified usage key
    recognized by `calc_required_ventilation_flow`.

    Args:
        building_row: The dictionary containing building data.

    Returns:
        A string usage key (e.g., "office_area_based", "retail") for non-residential,
        or None for residential.
    """
    bldg_func = safe_lower(building_row.get("building_function", "residential"))

    if bldg_func == "residential":
        return None
    else:
        nonres_type = building_row.get("non_residential_type", "Other Use Function")
        # Define the mapping from detailed non-res types to the simplified keys
        # used in calc_required_ventilation_flow's 'usage_flow_map'.
        # This mapping should be consistent with the keys in that function.
        usage_map: Dict[str, str] = {
            "Meeting Function": "office_area_based",
            "Healthcare Function": "healthcare_function", # Example: Add if specific rate exists
            "Sport Function": "sport_function",         # Example: Add if specific rate exists
            "Cell Function": "office_area_based",       # Example mapping
            "Retail Function": "retail",
            "Industrial Function": "industrial_function", # Example: Add if specific rate exists
            "Accommodation Function": "accommodation_function", # Example: Add if specific rate exists
            "Office Function": "office_area_based",
            "Education Function": "education_function",     # Example: Add if specific rate exists
            "Other Use Function": "retail"                # Fallback usage type
        }
        # Use .get() for safe lookup with a default fallback usage type
        fallback_usage = "retail" # Or "office_area_based" might be safer default
        return usage_map.get(nonres_type, fallback_usage)
------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\ventilation\create_ventilation_systems.py
============================================================
# ventilation/create_ventilation_systems.py

import random
import math  # For isnan checks if needed
from typing import Optional, Any, Tuple

# Import IDF class for type hinting (assuming geomeppy is used)
try:
    from geomeppy import IDF
except ImportError:
    IDF = Any # Fallback if geomeppy not available

# Assuming SYSTEMS_CONFIG is defined in this module or imported correctly
try:
    from .config_systems import SYSTEMS_CONFIG
except ImportError:
    # Handle case where config might be structured differently
    print("[ERROR] Could not import SYSTEMS_CONFIG from .config_systems. Ensure it's defined.")
    SYSTEMS_CONFIG = {} # Provide an empty dict to avoid crashes later, but setup will likely fail


# ---------------------------------------------------------------------------
# Helper: Apply weather-dependent infiltration coefficients
# ---------------------------------------------------------------------------
def apply_weather_coefficients(
    infil_obj: Any,
    base_flow_per_area_m3_s_m2: float, # Renamed for clarity: this is now m3/s per m2
    typical_delta_t: float = 10.0,
    typical_wind: float = 3.0,
):
    """Configure infiltration coefficients so that the infiltration flow
    varies with temperature difference and wind speed.

    The ``base_flow_per_area_m3_s_m2`` value is assumed to correspond to the flow
    per m2 when ``typical_delta_t`` (degC) and ``typical_wind`` (m/s) occur.
    Coefficients are chosen so that the resulting design flow rate (per m2)
    equals ``base_flow_per_area_m3_s_m2`` under those typical conditions.
    """

    # Simple default coefficients that introduce dependence on ΔT and wind
    A = 0.5  # Constant term coefficient (base fraction)
    B = 0.02 # Temperature term coefficient (per degC)
    C = 0.04 # Velocity term coefficient (per m/s)
    D = 0.0  # Velocity squared term coefficient (per (m/s)^2)

    # Denominator for scaling the base flow rate
    denom = A + B * typical_delta_t + C * typical_wind + D * (typical_wind ** 2)
    if denom <= 1e-6: # Avoid division by zero or very small numbers leading to huge flows
        print(f"[WARNING] Denominator in apply_weather_coefficients is near zero ({denom}). Using 1.0 to avoid instability.")
        denom = 1.0

    # The Design_Flow_Rate field will now store the m3/s/m2 value that,
    # when multiplied by the coefficients at design conditions, yields the target flow.
    # Or, more directly, this is the 'k' in Q = k * (A + B*dT + C*v + D*v^2)
    # So, k = Q_target / (A + B*dT_typ + C*v_typ + D*v_typ^2)
    # where Q_target is base_flow_per_area_m3_s_m2
    infil_obj.Design_Flow_Rate = base_flow_per_area_m3_s_m2 / denom
    infil_obj.Constant_Term_Coefficient = A
    infil_obj.Temperature_Term_Coefficient = B
    infil_obj.Velocity_Term_Coefficient = C
    infil_obj.Velocity_Squared_Term_Coefficient = D


def create_ventilation_system(
    idf: IDF,
    building_function: str,     # 'residential' or 'non_residential'
    system_type: str,           # 'A', 'B', 'C', or 'D'
    zone_name: str,
    # --- Zone-specific flows ---
    infiltration_m3_s: float,     # TOTAL Calculated infiltration for THIS zone (m3/s)
    vent_flow_m3_s: float,        # TOTAL Calculated required ventilation for THIS zone (m3/s)
    zone_floor_area_m2: float,  # << NEW PARAMETER: Floor area of the current zone (m2)
    # --- Schedule names ---
    infiltration_sched_name: str = "AlwaysOnSched",
    ventilation_sched_name: str = "VentSched_DayNight", # Used for ZoneVentilation and IdealLoads Availability
    # --- Infiltration modelling ---
    infiltration_model: str = "constant",  # "constant" or "weather"
    typical_delta_t: float = 10.0,
    typical_wind: float = 3.0,
    # --- Strategy for picking from ranges (e.g., fan eff from SYSTEMS_CONFIG) ---
    pick_strategy: str = "midpoint",  # or "random"
    # --- Parameters specifically for System D (IdealLoads) ---
    dsoa_object_name: Optional[str] = None,  # Name of the DesignSpecification:OutdoorAir object
    hrv_sensible_effectiveness: float = 0.0,
    hrv_latent_effectiveness: float = 0.0,
    # --- Overrides for fan parameters (for Systems A, B, C primarily) ---
    fan_pressure_override_Pa: Optional[float] = None,
    fan_efficiency_override: Optional[float] = None,
) -> Tuple[Optional[Any], Optional[Any]]:  # Return type hint Any or specific eppy/geomeppy type
    """
    Creates EnergyPlus objects for infiltration and ventilation for a specific zone.

    Key Updates for "Flow Area":
    - Added `zone_floor_area_m2` parameter.
    - For ZONEINFILTRATION:DESIGNFLOWRATE and ZONEVENTILATION:DESIGNFLOWRATE:
        - Design_Flow_Rate_Calculation_Method is set to "Flow/Area".
        - Design_Flow_Rate is set to the flow rate per m2 of zone floor area (m3/s/m2).
    - `apply_weather_coefficients` now works with per-area flow rates.
    - IdealLoadsAirSystem (System D) continues to use DesignSpecification:OutdoorAir,
      which itself is configured with per-area rates in add_ventilation.py.
    """

    # --- 1) Get System Configuration from SYSTEMS_CONFIG ---
    config = None
    try:
        func_config = SYSTEMS_CONFIG.get(building_function)
        if not func_config:
            print(f"[WARNING] Building function '{building_function}' not found in SYSTEMS_CONFIG. Defaulting to 'residential'.")
            func_config = SYSTEMS_CONFIG.get("residential", {})

        config = func_config.get(system_type)
        if not config:
            print(f"[WARNING] System type '{system_type}' not found for '{building_function}'. Defaulting to 'A' for {building_function}.")
            config = func_config.get("A", {}) # Default to system A config for the given function
            if not config and building_function == "non_residential": # Further fallback if 'A' also not in func_config
                 config = SYSTEMS_CONFIG.get("residential", {}).get("A",{})
    except Exception as e:
        print(f"[ERROR] Failed to get system config for {building_function}/{system_type}: {e}")
        return None, None # Cannot proceed without config

    if not config: # Check if config retrieval failed completely
        print(f"[ERROR] System config for {building_function}/{system_type} is empty or invalid after fallbacks.")
        return None, None

    # --- 2) Helper to Pick Value from Range (from SYSTEMS_CONFIG if no override) ---
    def pick_val(rng_tuple):
        """Picks value from (min, max) tuple based on pick_strategy."""
        if not isinstance(rng_tuple, (list, tuple)) or len(rng_tuple) != 2:
            # print(f"[DEBUG] Invalid range tuple: {rng_tuple}. Returning 0.0.")
            return 0.0
        min_v, max_v = rng_tuple
        try:
            min_v = float(min_v)
            max_v = float(max_v)
            if math.isnan(min_v) or math.isnan(max_v): raise ValueError("NaN in range")
            if min_v > max_v: min_v = max_v # Ensure min <= max
        except (ValueError, TypeError):
            # print(f"[DEBUG] Invalid numeric values in range {rng_tuple}. Using 0.0.")
            return 0.0

        if pick_strategy == "random":
            return random.uniform(min_v, max_v)
        else: # Default to midpoint
            return (min_v + max_v) / 2.0

    # --- 3) Create Infiltration Object (Always created, flow can be zero) ---
    iobj = None
    try:
        iobj = idf.newidfobject("ZONEINFILTRATION:DESIGNFLOWRATE")
        base_name = f"Infil_{building_function[:4]}_{system_type}_{zone_name}"
        clean_base_name = "".join(c if c.isalnum() or c in ['-', '_', '.'] else '_' for c in base_name)[:100] # Max 100 chars
        iobj.Name = clean_base_name

        zone_field_assigned = False
        for field_name in ["Zone_or_ZoneList_Name", "Zone_Name", "Zone_or_ZoneList_or_Space_or_SpaceList_Name"]:
            if hasattr(iobj, field_name):
                setattr(iobj, field_name, zone_name)
                zone_field_assigned = True
                break
        if not zone_field_assigned:
            raise ValueError(f"Could not find or set Zone Name field for ZONEINFILTRATION:DESIGNFLOWRATE object '{iobj.Name}'.")

        iobj.Schedule_Name = infiltration_sched_name
        iobj.Design_Flow_Rate_Calculation_Method = "Flow/Area" # << CHANGED to Flow/Area

        # Calculate infiltration flow per unit area
        infiltration_flow_per_area_m3_s_m2 = 0.0
        if zone_floor_area_m2 > 1e-6: # Avoid division by zero for very small or zero area zones
            infiltration_flow_per_area_m3_s_m2 = infiltration_m3_s / zone_floor_area_m2
        elif infiltration_m3_s > 1e-9: # If there's flow but no area, it's an issue
             print(f"[WARNING] Zone '{zone_name}' has infiltration flow {infiltration_m3_s} m3/s but area is {zone_floor_area_m2} m2. Cannot calculate Flow/Area. Setting infiltration per area to 0.")


        if infiltration_model.lower() == "weather":
            # apply_weather_coefficients now expects base_flow_per_area_m3_s_m2
            apply_weather_coefficients(
                iobj,
                max(0.0, infiltration_flow_per_area_m3_s_m2), # Pass per-area rate
                typical_delta_t=typical_delta_t,
                typical_wind=typical_wind,
            )
        else: # "constant" model
            iobj.Design_Flow_Rate = max(0.0, infiltration_flow_per_area_m3_s_m2) # Set per-area rate
            iobj.Constant_Term_Coefficient = 1.0
            iobj.Temperature_Term_Coefficient = 0.0
            iobj.Velocity_Term_Coefficient = 0.0
            iobj.Velocity_Squared_Term_Coefficient = 0.0
            # For "constant" with "Flow/Area", the Design_Flow_Rate is simply the m3/s/m2 value.
            # The coefficients effectively make it Q = Design_Flow_Rate * 1.0

    except Exception as e:
        print(f"[ERROR] Failed to create ZONEINFILTRATION:DESIGNFLOWRATE for {zone_name}: {e}")
        # If iobj was partially created, it might be good to remove it, but geomeppy handles this.
        return None, None # Return None, None if infiltration object creation fails

    # --- 4) Prepare Chosen Parameter Values from Config (for fallback if no overrides) ---
    chosen_params_from_config = {} # Parameters like fan pressure/eff from SYSTEMS_CONFIG
    range_dict_from_config = config.get("range_params", {})
    for param_name, rng in range_dict_from_config.items():
        chosen_val = pick_val(rng)
        chosen_params_from_config[param_name] = chosen_val

    fixed_params_from_config = config.get("fixed_params", {})
    ventilation_type_options = config.get("ventilation_type_options", ["Natural"]) # Default to Natural
    chosen_vent_type_from_config = random.choice(ventilation_type_options) if pick_strategy == "random" and ventilation_type_options else ventilation_type_options[0]

    # --- 5) Create/Configure Ventilation System Object ---
    vent_obj_or_ideal_obj = None # Initialize

    if config.get("use_ideal_loads", False): # Typically System D
        # --- System D: Configure Existing IdealLoadsAirSystem ---
        # IdealLoadsAirSystem uses DesignSpecification:OutdoorAir, which is already set up
        # with per-area rates in add_ventilation.py. No direct "Flow/Area" change needed here for OA.
        possible_ideal_names = [
            f"{zone_name} Ideal Loads",
            f"{zone_name}_Ideal_Loads",
            f"IdealLoads_{zone_name}"
        ]
        ideal_obj_found = None
        for name_attempt in possible_ideal_names:
            ideal_obj_found = idf.getobject("ZONEHVAC:IDEALLOADSAIRSYSTEM", name_attempt.upper()) # Case-insensitive check
            if ideal_obj_found:
                break
        
        if not ideal_obj_found:
            print(f"[VENT WARNING] ZONEHVAC:IDEALLOADSAIRSYSTEM not found using patterns for System D in zone {zone_name}. Tried: {possible_ideal_names}. Cannot configure OA or HRV.")
            return iobj, None # Return infiltration obj, but None for vent/ideal obj
        else:
            vent_obj_or_ideal_obj = ideal_obj_found

            if hasattr(vent_obj_or_ideal_obj, "Availability_Schedule_Name"):
                vent_obj_or_ideal_obj.Availability_Schedule_Name = ventilation_sched_name
            else:
                print(f"[VENT WARNING] IdealLoads object {vent_obj_or_ideal_obj.Name} lacks 'Availability_Schedule_Name' field.")

            if dsoa_object_name:
                if hasattr(vent_obj_or_ideal_obj, "Design_Specification_Outdoor_Air_Object_Name"):
                    if idf.getobject("DESIGNSPECIFICATION:OUTDOORAIR", dsoa_object_name.upper()):
                        vent_obj_or_ideal_obj.Design_Specification_Outdoor_Air_Object_Name = dsoa_object_name
                    else:
                        print(f"[VENT WARNING] Specified DSOA object '{dsoa_object_name}' not found in IDF for IdealLoads '{vent_obj_or_ideal_obj.Name}'. Outdoor Air not linked via DSOA.")
                else:
                    print(f"[VENT WARNING] IdealLoads object {vent_obj_or_ideal_obj.Name} lacks 'Design_Specification_Outdoor_Air_Object_Name' field.")
            else:
                print(f"[VENT WARNING] DSOA object name not provided for System D configuration of IdealLoads '{vent_obj_or_ideal_obj.Name}'. Outdoor Air will not be enabled via DSOA method.")
                if hasattr(vent_obj_or_ideal_obj, "Design_Specification_Outdoor_Air_Object_Name"):
                    vent_obj_or_ideal_obj.Design_Specification_Outdoor_Air_Object_Name = ""

            for param_field, fixed_val in fixed_params_from_config.items():
                if param_field == "Design_Specification_Outdoor_Air_Object_Name": continue
                if hasattr(vent_obj_or_ideal_obj, param_field):
                    try:
                        setattr(vent_obj_or_ideal_obj, param_field, fixed_val)
                    except Exception as set_err:
                        print(f"[VENT WARNING] Failed to set IdealLoads {param_field} = {fixed_val} for {vent_obj_or_ideal_obj.Name}: {set_err}")

            sens_eff = max(0.0, hrv_sensible_effectiveness)
            lat_eff = max(0.0, hrv_latent_effectiveness)
            hr_type = "None"
            if sens_eff > 0.001 and lat_eff > 0.001:
                hr_type = "Enthalpy"
            elif sens_eff > 0.001:
                hr_type = "Sensible"
            elif lat_eff > 0.001:
                hr_type = "Enthalpy" # Or "Latent" if E+ version supports

            try:
                if hasattr(vent_obj_or_ideal_obj, "Heat_Recovery_Type"):
                    vent_obj_or_ideal_obj.Heat_Recovery_Type = hr_type
                if hasattr(vent_obj_or_ideal_obj, "Sensible_Heat_Recovery_Effectiveness"):
                    vent_obj_or_ideal_obj.Sensible_Heat_Recovery_Effectiveness = sens_eff if hr_type != "None" else 0.0
                if hasattr(vent_obj_or_ideal_obj, "Latent_Heat_Recovery_Effectiveness"):
                    vent_obj_or_ideal_obj.Latent_Heat_Recovery_Effectiveness = lat_eff if hr_type != "None" else 0.0
            except Exception as hr_err:
                print(f"[VENT WARNING] Failed to set Heat Recovery fields for {vent_obj_or_ideal_obj.Name}: {hr_err}")

    else: # Systems A, B, C: Create ZONEVENTILATION:DESIGNFLOWRATE
        try:
            vent_obj_type_from_config = config.get("ventilation_object_type", "ZONEVENTILATION:DESIGNFLOWRATE")
            vobj = idf.newidfobject(vent_obj_type_from_config)
            vent_obj_or_ideal_obj = vobj

            base_name = f"Vent_{building_function[:4]}_{system_type}_{zone_name}"
            clean_base_name = "".join(c if c.isalnum() or c in ['-', '_', '.'] else '_' for c in base_name)[:100]
            vobj.Name = clean_base_name

            zone_field_assigned = False
            for field_name in ["Zone_or_ZoneList_Name", "Zone_Name", "Zone_or_ZoneList_or_Space_or_SpaceList_Name"]:
                if hasattr(vobj, field_name):
                    setattr(vobj, field_name, zone_name)
                    zone_field_assigned = True
                    break
            if not zone_field_assigned:
                raise ValueError(f"Could not find or set Zone Name field for {vent_obj_type_from_config} object '{vobj.Name}'.")

            vobj.Schedule_Name = ventilation_sched_name
            vobj.Design_Flow_Rate_Calculation_Method = "Flow/Area" # << CHANGED to Flow/Area

            # Calculate ventilation flow per unit area
            ventilation_flow_per_area_m3_s_m2 = 0.0
            if zone_floor_area_m2 > 1e-6: # Avoid division by zero
                ventilation_flow_per_area_m3_s_m2 = vent_flow_m3_s / zone_floor_area_m2
            elif vent_flow_m3_s > 1e-9: # If there's flow but no area, it's an issue
                print(f"[WARNING] Zone '{zone_name}' has ventilation flow {vent_flow_m3_s} m3/s but area is {zone_floor_area_m2} m2. Cannot calculate Flow/Area. Setting ventilation per area to 0.")

            vobj.Design_Flow_Rate = max(0.0, ventilation_flow_per_area_m3_s_m2) # Set per-area rate

            if hasattr(vobj, "Ventilation_Type"):
                vobj.Ventilation_Type = chosen_vent_type_from_config

            current_fan_pressure = 0.0
            current_fan_efficiency = 0.01 # Avoid division by zero

            if chosen_vent_type_from_config != "Natural":
                if fan_pressure_override_Pa is not None and fan_pressure_override_Pa >= 0: # Allow 0 pressure
                    current_fan_pressure = fan_pressure_override_Pa
                else:
                    current_fan_pressure = chosen_params_from_config.get("Fan_Pressure_Rise", 0.0)

                if fan_efficiency_override is not None and 0.01 <= fan_efficiency_override <= 1.0:
                    current_fan_efficiency = fan_efficiency_override
                else:
                    current_fan_efficiency = chosen_params_from_config.get("Fan_Total_Efficiency", 0.7)
                    current_fan_efficiency = min(1.0, max(0.01, current_fan_efficiency))

                if hasattr(vobj, "Fan_Pressure_Rise"):
                    vobj.Fan_Pressure_Rise = max(0.0, current_fan_pressure)
                if hasattr(vobj, "Fan_Total_Efficiency"):
                    vobj.Fan_Total_Efficiency = current_fan_efficiency
            
            for param_field, fixed_val in fixed_params_from_config.items():
                if hasattr(vobj, param_field):
                    try: setattr(vobj, param_field, fixed_val)
                    except Exception as set_err: print(f"[VENT WARNING] Failed to set {vent_obj_type_from_config} {param_field} = {fixed_val}: {set_err}")

        except Exception as e:
            print(f"[ERROR] Failed to create {config.get('ventilation_object_type', 'UNKNOWN_VENT_OBJECT')} for {zone_name}: {e}")
            vent_obj_or_ideal_obj = None

    # --- 6) Return the created/modified objects ---
    return iobj, vent_obj_or_ideal_obj

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\ventilation\config_systems.py
============================================================
# ventilation/config_systems.py

"""
Defines SYSTEMS_CONFIG: a dictionary organizing ventilation system properties.

Structure:
  SYSTEMS_CONFIG[building_function][system_type]

Each system entry contains:
  - description: Short text label.
  - ventilation_object_type: The primary EnergyPlus object used for this system's
      ventilation component (e.g., 'ZONEVENTILATION:DESIGNFLOWRATE' or
      'ZONEHVAC:IDEALLOADSAIRSYSTEM').
  - ventilation_type_options: List of allowed values for the 'Ventilation Type'
      field if using ZONEVENTILATION:DESIGNFLOWRATE.
  - range_params: Dictionary holding (min, max) tuples for parameters that can vary
      (e.g., fan efficiency, HRV effectiveness). Final values are picked by
      create_ventilation_system.py using these ranges IF NOT OVERRIDDEN by
      parameters passed directly to that function.
  - fixed_params: Dictionary holding fixed values for parameters specific to this
      system type (e.g., Heat Recovery Type for System D, though this is also
      dynamically set in create_ventilation_system.py based on effectiveness).
  - use_ideal_loads: Boolean, True if System D uses IdealLoads for ventilation.

This config informs create_ventilation_systems.py how to build the IDF objects.
The parameters in 'range_params' act as DEFAULTS if more specific values
(e.g., from assign_ventilation_values.py) are not passed into create_ventilation_system.py.
"""

SYSTEMS_CONFIG = {
    "residential": {
        # -----------------------------------------------------------
        # System A: Natural Ventilation (Natural Supply + Natural Exhaust/Infiltration)
        # -----------------------------------------------------------
        "A": {
            "description": "Natural supply + Natural exhaust/infiltration",
            "ventilation_object_type": "ZONEVENTILATION:DESIGNFLOWRATE", # Models natural ventilation openings
            "ventilation_type_options": ["Natural"], # E+ calculates flow based on wind/temp diffs, modulated by schedule and design flow rate.
            "range_params": {
                # For "Natural" Ventilation_Type, Fan_Pressure_Rise and Fan_Total_Efficiency are ignored by E+.
                # Setting them to 0 and 1 respectively is good practice.
                "Fan_Pressure_Rise": (0.0, 0.0),    # Pa
                "Fan_Total_Efficiency": (1.0, 1.0), # Dimensionless (set to 1 to avoid potential div by zero if code tried to use it)
            },
            "fixed_params": {
                # No specific fixed params needed for ZONEVENTILATION with Natural type via this config.
            },
            "use_ideal_loads": False # Does not use IdealLoads for ventilation part
        },

        # -----------------------------------------------------------
        # System B: Mechanical Supply + Natural Exhaust/Infiltration
        # -----------------------------------------------------------
        "B": {
            "description": "Mechanical supply + Natural exhaust/infiltration",
            "ventilation_object_type": "ZONEVENTILATION:DESIGNFLOWRATE", # Models mechanical intake fan
            "ventilation_type_options": ["Intake"], # Represents supply fan
            "range_params": {
                "Fan_Pressure_Rise": (40.0, 60.0),    # Pa, typical for simple residential supply
                "Fan_Total_Efficiency": (0.65, 0.75) # Default fan efficiency range if not overridden
            },
            "fixed_params": {
                # No specific fixed params needed for ZONEVENTILATION with Intake type here.
            },
            "use_ideal_loads": False
        },

        # -----------------------------------------------------------
        # System C: Natural Supply/Infiltration + Mechanical Exhaust
        # -----------------------------------------------------------
        "C": {
            "description": "Natural supply/infiltration + Mechanical exhaust",
            "ventilation_object_type": "ZONEVENTILATION:DESIGNFLOWRATE", # Models mechanical exhaust fan
            "ventilation_type_options": ["Exhaust"], # Represents exhaust fan
            "range_params": {
                "Fan_Pressure_Rise": (40.0, 60.0),    # Pa, typical for simple residential exhaust
                "Fan_Total_Efficiency": (0.65, 0.75) # Default fan efficiency range if not overridden
            },
            "fixed_params": {
                # No specific fixed params needed for ZONEVENTILATION with Exhaust type here.
            },
            "use_ideal_loads": False
        },

        # -----------------------------------------------------------
        # System D: Balanced Mechanical (Supply + Exhaust) with HRV
        # Uses IdealLoadsAirSystem to represent this.
        # HRV effectiveness is passed directly to create_ventilation_system,
        # so these range_params are fallbacks if that mechanism fails or isn't used.
        # -----------------------------------------------------------
        "D": {
            "description": "Balanced mechanical (supply + exhaust), with HRV",
            "ventilation_object_type": "ZONEHVAC:IDEALLOADSAIRSYSTEM", # Ventilation handled by IdealLoads
            "ventilation_type_options": ["Balanced"], # Not directly used by IdealLoads but indicates intent
            "range_params": {
                # Note: Fan power for IdealLoads is not directly set using these pressure/efficiency values.
                # IdealLoads system has its own way of meeting loads ideally.
                # These might inform SFP calculations if done externally.
                # "Fan_Pressure_Rise": (50.0, 80.0), # Pa, (Commented out as IdealLoads is different)
                # "Fan_Total_Efficiency": (0.7, 0.85), # (Commented out)

                # HRV effectiveness ranges defined here are DEFAULTS if specific values are not
                # passed into create_ventilation_system.py. The primary path for HRV effectiveness
                # is via assign_ventilation_values.py -> add_ventilation.py -> create_ventilation_system.py args.
                "Sensible_Heat_Recovery_Effectiveness": (0.70, 0.80),
                "Latent_Heat_Recovery_Effectiveness": (0.0, 0.0) # Default assumes no latent recovery for residential
            },
            "fixed_params": {
                # These parameters are typically set on the IdealLoads object for System D ventilation.
                # Design_Specification_Outdoor_Air_Object_Name is set dynamically in create_ventilation_system.
                # EnergyPlus 22.x 'ZoneHVAC:IdealLoadsAirSystem' only supports
                # NoEconomizer, DifferentialDryBulb or DifferentialEnthalpy.
                # Use NoEconomizer for broad compatibility.
                "Outdoor_Air_Economizer_Type": "NoEconomizer", # Economizer disabled for compatibility
                "Economizer_Maximum_Limit_Dry_Bulb_Temperature": 18,  # DegC limit for economizer
                # Heat_Recovery_Type is set dynamically in create_ventilation_system based on actual effectiveness values.
                # "Heat_Recovery_Type": "Sensible" # Initial thought, but now dynamic
            },
            "use_ideal_loads": True # Confirms IdealLoads handles ventilation
        }
    }, # End residential

    "non_residential": {
        # -----------------------------------------------------------
        # System A: Natural Ventilation
        # -----------------------------------------------------------
        "A": {
            "description": "Natural supply + Natural exhaust/infiltration",
            "ventilation_object_type": "ZONEVENTILATION:DESIGNFLOWRATE",
            "ventilation_type_options": ["Natural"],
            "range_params": {
                "Fan_Pressure_Rise": (0.0, 0.0),
                "Fan_Total_Efficiency": (1.0, 1.0),
            },
            "fixed_params": {},
            "use_ideal_loads": False
        },

        # -----------------------------------------------------------
        # System B: Mechanical Supply
        # -----------------------------------------------------------
        "B": {
            "description": "Mechanical supply + Natural exhaust/infiltration",
            "ventilation_object_type": "ZONEVENTILATION:DESIGNFLOWRATE",
            "ventilation_type_options": ["Intake"],
            "range_params": {
                "Fan_Pressure_Rise": (90.0, 110.0),  # Pa, typically higher for non-res supply
                "Fan_Total_Efficiency": (0.65, 0.75) # Default if not overridden
            },
            "fixed_params": {},
            "use_ideal_loads": False
        },

        # -----------------------------------------------------------
        # System C: Mechanical Exhaust
        # -----------------------------------------------------------
        "C": {
            "description": "Natural supply/infiltration + Mechanical exhaust",
            "ventilation_object_type": "ZONEVENTILATION:DESIGNFLOWRATE",
            "ventilation_type_options": ["Exhaust"],
            "range_params": {
                "Fan_Pressure_Rise": (140.0, 160.0), # Pa, typically higher for non-res exhaust
                "Fan_Total_Efficiency": (0.70, 0.80)  # Default if not overridden
            },
            "fixed_params": {},
            "use_ideal_loads": False
        },

        # -----------------------------------------------------------
        # System D: Balanced Mechanical (Supply + Exhaust) with HRV/Economizer
        # Uses IdealLoadsAirSystem.
        # -----------------------------------------------------------
        "D": {
            "description": "Balanced mechanical supply & exhaust (with optional HRV/Economizer)",
            "ventilation_object_type": "ZONEHVAC:IDEALLOADSAIRSYSTEM",
            "ventilation_type_options": ["Balanced"], # Intent indicator
            "range_params": {
                # Default HRV effectiveness ranges if not overridden by values passed to create_ventilation_system.
                "Sensible_Heat_Recovery_Effectiveness": (0.75, 0.85),
                "Latent_Heat_Recovery_Effectiveness": (0.0, 0.0) # Default assumes no latent for non-res, can be overridden
                # Fan parameters for IdealLoads are not used directly for E+ fan energy.
                # "Fan_Pressure_Rise": (100.0, 120.0),
                # "Fan_Total_Efficiency": (0.65, 0.80),
            },
            "fixed_params": {
                # EnergyPlus 22.x does not allow 'FixedDryBulb' for IdealLoads
                # economizers. Default to NoEconomizer for reliability.
                "Outdoor_Air_Economizer_Type": "NoEconomizer", # Economizer disabled for compatibility
                "Economizer_Maximum_Limit_Dry_Bulb_Temperature": 18,  # DegC limit for economizer
                # Heat_Recovery_Type is set dynamically in create_ventilation_system.
            },
            "use_ideal_loads": True
        }
    } # End non_residential
} # End SYSTEMS_CONFIG
------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\ventilation\calc_functions.py
============================================================
# ventilation/calc_functions.py

import math

# Updated function name and docstring for clarity on units
def calc_infiltration_rate_at_1Pa_per_m2(
    infiltration_base_at_10Pa_per_m2,  # Base rate per m2 floor area @ 10 Pa (e.g., in L/s/m2 or m3/h/m2)
    year_factor,                       # Multiplier based on construction year
    flow_exponent                      # Typically 0.67 (standard infiltration exponent)
):
    """
    Calculates the infiltration rate at 1 Pa per m2 floor area.

    The output rate will be in the same volumetric units as the input
    'infiltration_base_at_10Pa_per_m2' (e.g., if input is L/s/m2, output is L/s/m2).
    This function adjusts for the construction year and converts the pressure basis from 10 Pa to 1 Pa.
    The final conversion to m3/s for EnergyPlus is handled in the calling script (e.g., add_ventilation.py).

    Steps:
      1) Apply year_factor to infiltration_base_at_10Pa_per_m2 => qv10_per_m2 (Rate per m2 @ 10 Pa).
      2) Convert qv10 => qv1 using the flow exponent: qv1 = qv10 * (1 Pa / 10 Pa)^n
      3) Return the result (e.g., in L/s per m2 @ 1Pa or m3/h per m2 @ 1Pa).

    NTA 8800 basis:
      - Table 11.2 prescribes n=0.67 for leak losses (infiltration).
      - Section 11.2.5 references converting from 10 Pa to 1 Pa.

    Args:
        infiltration_base_at_10Pa_per_m2 (float): Base infiltration rate per m2 floor area
                                                  at 10 Pa (e.g., in L/s/m2 or m3/h/m2).
        year_factor (float): Multiplier based on age range.
        flow_exponent (float): Flow exponent (typically 0.67).

    Returns:
        float: Infiltration rate per m2 floor area @ 1 Pa, in the same volumetric units
               as 'infiltration_base_at_10Pa_per_m2'.
               Returns 0.0 if inputs are invalid.
    """
    try:
        # Basic input validation
        if infiltration_base_at_10Pa_per_m2 < 0 or year_factor < 0 or flow_exponent <= 0:
            print(f"[WARNING] Invalid inputs to calc_infiltration_rate_at_1Pa_per_m2. "
                  f"base_rate={infiltration_base_at_10Pa_per_m2}, year_factor={year_factor}, exponent={flow_exponent}. Returning 0.")
            return 0.0

        # 1) Apply year factor => Rate per m2 @ 10 Pa, in original volumetric units
        qv10_effective_per_m2 = infiltration_base_at_10Pa_per_m2 * year_factor

        # 2) Convert from qv10 to qv1 using the exponent
        # The volumetric unit (e.g., L/s or m3/h) is preserved during this conversion.
        qv1_effective_per_m2 = qv10_effective_per_m2 * (1.0 / 10.0)**flow_exponent

        # 3) Return the rate per m2 floor area @ 1 Pa (in original volumetric units per m2)
        return qv1_effective_per_m2

    except Exception as e:
        print(f"[ERROR] Exception in calc_infiltration_rate_at_1Pa_per_m2: {e}")
        return 0.0


def calc_required_ventilation_flow(
    building_function,
    f_ctrl_val,          # Control factor (e.g., from lookup based on system type)
    floor_area_m2,       # TOTAL building floor area
    usage_key=None       # Specific usage type for non-residential (e.g., office, retail)
):
    """
    Calculate the TOTAL required mechanical ventilation flow (m3/s) for the building.

    Applies standard rates per m2 based on building function/usage, applies
    a control factor, and enforces a minimum for residential buildings.

    NTA 8800 basis:
      - Section 11.2.2.5 / Table 11.8 provide typical supply rates. This uses simplified examples.
      - Residential minimum often relates to dwelling size/occupancy (~35 L/s or 126 m3/h).

    Args:
        building_function (str): 'residential' or 'non_residential'.
        f_ctrl_val (float): Control factor multiplier.
        floor_area_m2 (float): Total building floor area.
        usage_key (str, optional): Key for non-residential usage type.

    Returns:
        float: Total required ventilation flow rate for the building in m3/s.
    """
    try:
        # Basic input validation
        if floor_area_m2 <= 0:
            print(f"[WARNING] Invalid floor_area_m2 ({floor_area_m2}) in calc_required_ventilation_flow. Returning 0.")
            return 0.0
        if f_ctrl_val < 0: # Allow f_ctrl_val == 0 (e.g. to turn off mech vent based on control)
            print(f"[WARNING] Negative f_ctrl_val ({f_ctrl_val}) in calc_required_ventilation_flow. Using 0.")
            f_ctrl_val = 0.0

        qv_oda_req_des_m3_h = 0.0 # Design required flow in m3/h, before control factor

        if building_function == "residential":
            # Base rate from NTA 8800 example for dwellings (0.9 dm3/s per m2 = 0.9 L/s per m2)
            qv_uspec_L_s_m2 = 0.9 # dm3/s is L/s
            # Total design required flow in L/s
            qv_oda_req_des_L_s = qv_uspec_L_s_m2 * floor_area_m2
            # Convert total design flow from L/s to m3/h (1 L/s = 3.6 m3/h)
            qv_oda_req_des_m3_h = qv_oda_req_des_L_s * 3.6

            # Apply control factor
            qv_oda_req_actual_m3_h = f_ctrl_val * qv_oda_req_des_m3_h

            # Enforce minimum ventilation rate for a dwelling (~126 m3/h = 35 L/s)
            # This minimum applies AFTER the control factor potentially reduces the calculated rate.
            residential_min_m3_h = 126.0
            if qv_oda_req_actual_m3_h < residential_min_m3_h and f_ctrl_val > 0: # Only apply minimum if control factor didn't intend to shut it off
                # print(f"[VENT INFO] Residential calculated vent {qv_oda_req_actual_m3_h:.1f} m3/h below minimum. Using {residential_min_m3_h} m3/h.")
                qv_oda_req_actual_m3_h = residential_min_m3_h
            elif f_ctrl_val == 0: # If control factor is zero, required flow is zero
                 qv_oda_req_actual_m3_h = 0.0


        else: # Non-residential
            # Base rates per m2 based on usage_key (examples, adjust as needed)
            # Rates in dm3/s per m2 (which is L/s per m2)
            usage_flow_map_L_s_m2 = {
                "office_area_based": 1.0,
                "childcare": 4.8,         # Example - high rate for childcare
                "retail": 0.6,
                # Add other keys from mappings.py if they need different rates
                # Ensure these keys match those produced by map_usage_key
                "meeting_function": 1.0,      # Example mapping (should match map_usage_key output)
                "healthcare_function": 1.2, # Example mapping
                "sport_function": 1.5,      # Example mapping
                "cell_function": 0.8,       # Example mapping
                "industrial_function": 0.5, # Example mapping
                "accommodation_function": 0.9,# Example mapping
                "education_function": 1.1,    # Example mapping
                "other_use_function": 0.6   # Example mapping (should match map_usage_key output)
            }
            # Use usage_key, fallback to a default non-res rate if key not found
            # A common default might be "office_area_based" or a generic "default_nonres"
            qv_usage_L_s_m2 = usage_flow_map_L_s_m2.get(usage_key, 1.0) # Default to 1.0 L/s/m2 if key unknown

            # Total design required flow in L/s
            qv_oda_req_des_L_s = qv_usage_L_s_m2 * floor_area_m2
            # Convert total design flow from L/s to m3/h
            qv_oda_req_des_m3_h = qv_oda_req_des_L_s * 3.6

            # Apply control factor
            qv_oda_req_actual_m3_h = f_ctrl_val * qv_oda_req_des_m3_h
            # Minimums for non-res are typically implicit in the design rates or specific to regulations,
            # but could be added here if needed per category.

        # Final conversion from calculated m3/h to m3/s
        total_vent_flow_m3_s = qv_oda_req_actual_m3_h / 3600.0
        return total_vent_flow_m3_s

    except Exception as e:
        print(f"[ERROR] Exception in calc_required_ventilation_flow: {e}")
        return 0.0


def calc_fan_power(fan_pressure_Pa, fan_total_efficiency, flow_rate_m3_s):
    """
    Compute fan power in Watts based on pressure rise, efficiency, and flow rate.

    Formula: P_fan = (fan_pressure_Pa * flow_rate_m3_s) / fan_total_efficiency

    Args:
        fan_pressure_Pa (float): Fan pressure rise in Pascals (Pa).
        fan_total_efficiency (float): Overall fan efficiency (0.0 < eff <= 1.0).
        flow_rate_m3_s (float): Air volume flow rate in m3/s.

    Returns:
        float: Fan power in Watts (W). Returns 0 if efficiency is invalid or flow is zero.
    """
    try:
        # Ensure inputs are numbers
        pressure = float(fan_pressure_Pa)
        flow = float(flow_rate_m3_s)
        efficiency = float(fan_total_efficiency)

        if efficiency <= 0 or efficiency > 1.0: # Efficiency must be a valid fraction
            print(f"[WARNING] Invalid fan_total_efficiency ({efficiency}) in calc_fan_power. Must be > 0 and <= 1.0. Returning 0 W.")
            return 0.0
        
        if flow == 0: # No flow, no power
            return 0.0
            
        if pressure < 0: # Negative pressure might imply energy recovery or error
             print(f"[WARNING] Negative fan_pressure_Pa ({pressure}) in calc_fan_power. Result may be unconventional.")
        if flow < 0: # Negative flow is physically problematic here
             print(f"[WARNING] Negative flow_rate_m3_s ({flow}) in calc_fan_power. Returning 0 W.")
             return 0.0

        fan_power_watts = (pressure * flow) / efficiency
        return fan_power_watts

    except Exception as e:
        print(f"[ERROR] Exception in calc_fan_power: {e}")
        return 0.0
------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\ventilation\assign_ventilation_values.py
============================================================
# ventilation/assign_ventilation_values.py

import random
import math # Import math for isnan check
from .ventilation_lookup import ventilation_lookup # Assuming ventilation_lookup is in the same directory

def find_vent_overrides(
    building_id,
    building_function,
    age_range,
    scenario,
    calibration_stage,
    user_config
):
    """
    Searches a user_config list/dict for any override entries matching the
    building_id, building_function, age_range, scenario, and calibration_stage.
    Returns a list of matching dict rows.

    Each 'row' in user_config can specify:
      - "building_id"
      - "building_function"
      - "age_range"
      - "scenario"
      - "calibration_stage"
      - plus override fields for infiltration_base, year_factor, system_type,
        fan_pressure, f_ctrl, hrv_eff, schedule names, etc. using either
        "fixed_value" or ("min_val", "max_val").

    If any of the filtering fields (building_id, function, age, scenario, stage)
    are present in the row and do not match the current building, that row is skipped.
    Otherwise, the row is considered a match and is returned in the list.
    """
    matches = []
    if not user_config: # Handle empty or None user_config
        return matches

    for row in user_config:
        # Ensure row is a dictionary
        if not isinstance(row, dict):
            continue

        # Check filters - skip if a filter exists and doesn't match
        if "building_id" in row and row["building_id"] != building_id:
            continue
        if "building_function" in row and row["building_function"] != building_function:
            continue
        if "age_range" in row and row["age_range"] != age_range:
            continue
        if "scenario" in row and row["scenario"] != scenario:
            continue
        if "calibration_stage" in row and row["calibration_stage"] != calibration_stage:
            continue

        # If all present filters match, add the row
        matches.append(row)

    return matches


def pick_val_with_range(
    rng_tuple,
    strategy="A",
    log_dict=None,
    param_name=None
):
    """
    Selects a value from a (min_val, max_val) range based on the strategy.

    Args:
        rng_tuple (tuple or None): (min_val, max_val) or None.
        strategy (str): "A"=>midpoint, "B"=>random uniform, "C"=>min.
        log_dict (dict, optional): Dictionary to store final picks if provided.
        param_name (str, optional): Name of the parameter (e.g., "infiltration_base") for logging.

    Returns:
        float: The chosen numeric value. Logs range and pick if log_dict provided.
    """
    chosen = 0.0 # Default fallback
    min_v, max_v = 0.0, 0.0 # Default range values

    if rng_tuple is not None and len(rng_tuple) == 2:
        try:
            min_v_in, max_v_in = rng_tuple
            min_v = float(min_v_in)
            max_v = float(max_v_in)
            if math.isnan(min_v) or math.isnan(max_v):
                raise ValueError("NaN in range tuple")
        except (ValueError, TypeError, IndexError): # More specific exception handling
            print(f"[WARNING] Invalid range values in tuple {rng_tuple} for {param_name}. Defaulting to (0.0, 0.0).")
            min_v, max_v = 0.0, 0.0 # Reset to default on error
    else:
        if rng_tuple is not None: # Log if rng_tuple was provided but invalid (e.g. not None, but not a 2-tuple)
             print(f"[WARNING] Invalid range tuple format: {rng_tuple} for {param_name}. Defaulting to (0.0, 0.0).")
        # Otherwise, if rng_tuple is None, min_v and max_v remain 0.0

    # Ensure min <= max
    if min_v > max_v:
        print(f"[WARNING] Min value > Max value in range ({min_v}, {max_v}) for {param_name}. Using min value for both.")
        max_v = min_v

    # Pick final value based on strategy
    if strategy == "A": # Midpoint
        chosen = (min_v + max_v) / 2.0
    elif strategy == "B": # Random
        chosen = random.uniform(min_v, max_v)
    elif strategy == "C": # Minimum
        chosen = min_v
    else: # Default fallback to Minimum if strategy is unknown
        print(f"[WARNING] Unknown pick strategy '{strategy}' for {param_name}. Defaulting to Minimum.")
        chosen = min_v

    # Log if requested
    if log_dict is not None and param_name:
        log_dict[f"{param_name}_range"] = (min_v, max_v) # Log the processed (and potentially corrected) range
        log_dict[param_name] = chosen

    return chosen


def override_range(current_range, row_override_spec, param_name_for_warning="parameter"):
    """
    Applies overrides from a user config row_override_spec to a parameter's (min, max) range.

    If row_override_spec has 'fixed_value', convert it to (val, val).
    If row_override_spec has 'min_val' and 'max_val', return that tuple.
    Otherwise return current_range.
    """
    if "fixed_value" in row_override_spec:
        val = row_override_spec["fixed_value"]
        try:
            # Attempt to convert to float, handle potential errors
            f = float(val)
            if math.isnan(f): # Check for NaN explicitly
                 print(f"[WARNING] Override 'fixed_value' {val} is NaN for {param_name_for_warning}. Using current range {current_range}.")
                 return current_range
            return (f, f)
        except (ValueError, TypeError):
            # If conversion fails (e.g., non-numeric string), keep original range
             print(f"[WARNING] Could not convert override 'fixed_value' {val} to float for {param_name_for_warning}. Using current range {current_range}.")
             return current_range
    elif "min_val" in row_override_spec and "max_val" in row_override_spec:
         try:
             min_ovr = float(row_override_spec["min_val"])
             max_ovr = float(row_override_spec["max_val"])
             if math.isnan(min_ovr) or math.isnan(max_ovr):
                  raise ValueError("Override range contains NaN")
             # Basic validation: min <= max
             if min_ovr > max_ovr:
                  print(f"[WARNING] Override min_val > max_val for {param_name_for_warning}. Using min_val for both.")
                  return (min_ovr, min_ovr)
             return (min_ovr, max_ovr)
         except (ValueError, TypeError):
             print(f"[WARNING] Could not convert override range ({row_override_spec['min_val']}, {row_override_spec['max_val']}) to floats for {param_name_for_warning}. Using current range {current_range}.")
             return current_range
    # If no valid override found in the row, return the original range
    return current_range


def assign_ventilation_params_with_overrides(
    building_id=None,
    building_function="residential",
    age_range="2015 and later",
    scenario="scenario1",
    calibration_stage="pre_calibration",
    strategy="A",           # "A" => midpoint, "B" => random, "C" => min, etc.
    random_seed=None,
    user_config_vent=None,      # List of user override dicts
    assigned_vent_log=None,     # Optional dict to store final building-level picks
    infiltration_key=None,      # e.g. "Corner House" or "Office Function"
    year_key=None,              # e.g. "1975 - 1991"
    is_residential=True,
    default_flow_exponent=0.67
):
    """
    Determines ventilation parameters based on lookups and user overrides.

    Returns a dictionary containing the final selected parameter values and their source ranges.

    Steps:
      1) Look up default ranges from ventilation_lookup based on scenario and stage.
      2) Apply user overrides found via find_vent_overrides.
      3) Use 'strategy' (via pick_val_with_range) to select final numeric values.
      4) Determine final system type and schedule names.
      5) Assemble and return the final dictionary of assigned parameters.
      6) Optionally log the assigned parameters to assigned_vent_log.
    """
    if random_seed is not None:
        random.seed(random_seed)

    # --- 1) Get Base Parameter Ranges from Lookup ---
    try:
        # Ensure scenario and calibration_stage exist, with fallbacks
        scenario_data = ventilation_lookup.get(scenario)
        if not scenario_data:
            print(f"[WARNING] Scenario '{scenario}' not found in ventilation_lookup. Defaulting to first available or 'scenario1'.")
            scenario = next(iter(ventilation_lookup)) if ventilation_lookup else "scenario1" # Fallback to first key or hardcoded
            scenario_data = ventilation_lookup.get(scenario, {}) # Get data for the (potentially fallback) scenario
        
        stage_dict = scenario_data.get(calibration_stage)
        if not stage_dict:
            print(f"[WARNING] Calibration stage '{calibration_stage}' not found for scenario '{scenario}'. Defaulting to first available or 'pre_calibration'.")
            calibration_stage = next(iter(scenario_data)) if scenario_data else "pre_calibration" # Fallback
            stage_dict = scenario_data.get(calibration_stage, {}) # Get data for the (potentially fallback) stage

    except Exception as e: # Broad exception for unforeseen issues with lookup structure
         raise ValueError(f"Error accessing ventilation_lookup for scenario='{scenario}', stage='{calibration_stage}'. Problem: {e}. Ensure lookup structure is correct.")

    # Initialize parameters with defaults or lookups
    # Unit assumption for infiltration_base: L/s/m2 @ 10Pa from ventilation_lookup.py
    infiltration_base_rng = (0.0, 0.0)  # (min_L/s/m2@10Pa, max_L/s/m2@10Pa)
    year_factor_rng = (1.0, 1.0)      # Default no factor
    fan_pressure_rng = (0.0, 0.0)     # Default no pressure (Pa)
    fan_total_efficiency_rng = (0.5, 0.7) # Default typical fan efficiency range
    f_ctrl_rng = (1.0, 1.0)           # Default no control factor adjustment
    hrv_sens_eff_rng = (0.0, 0.0)     # Default no sensible HRV
    hrv_latent_eff_rng = (0.0, 0.0)   # Default no latent HRV

    # Default system types and schedules (can be overridden by lookups or user_config)
    system_type_final = "A" if is_residential else "D" # Default system types
    infiltration_sched_name = "AlwaysOnSched" # Default schedule for infiltration
    ventilation_sched_name = "VentSched_DayNight" if is_residential else "WorkHoursSched" # Default schedules for mech vent

    # Lookup infiltration range based on function and specific building type (infiltration_key)
    try:
        if is_residential:
            res_infil_lookup = stage_dict.get("residential_infiltration_range", {})
            # Provide a more generic default if infiltration_key is not found in the specific lookup
            infiltration_base_rng = res_infil_lookup.get(infiltration_key, (0.8, 1.2)) # Example default residential range
            sys_ctrl_ranges_lookup = stage_dict.get("system_control_range_res", {})
        else: # Non-residential
            nonres_infil_lookup = stage_dict.get("non_res_infiltration_range", {})
            infiltration_base_rng = nonres_infil_lookup.get(infiltration_key, (0.4, 0.6)) # Example default non-res range
            sys_ctrl_ranges_lookup = stage_dict.get("system_control_range_nonres", {})
    except Exception as e: # Catch potential errors during lookup
         print(f"[WARNING] Error getting infiltration/control ranges from lookup: {e}. Using defaults.")
         sys_ctrl_ranges_lookup = {} # Ensure it's a dict to prevent further errors if lookup fails

    # Lookup year factor range based on construction period (year_key)
    year_factor_lookup = stage_dict.get("year_factor_range", {})
    year_factor_rng = year_factor_lookup.get(year_key, (1.0, 1.0)) # Default if year_key not in lookup

    # Lookup HRV effectiveness ranges and fan efficiency range from the stage_dict
    # These keys should exist in ventilation_lookup.py at the calibration_stage level
    hrv_sens_eff_rng = stage_dict.get("hrv_sensible_eff_range", hrv_sens_eff_rng) # Use initialized default if key missing
    hrv_latent_eff_rng = stage_dict.get("hrv_latent_eff_range", hrv_latent_eff_rng) # NEW
    # Fan pressure might be more nuanced (e.g., per system type in SYSTEMS_CONFIG, not a single range here)
    # For now, let's assume a general lookup if available, or it's primarily driven by SYSTEMS_CONFIG
    # and overrides are for specific cases.
    # fan_pressure_rng = stage_dict.get("fan_pressure_range", fan_pressure_rng)
    # A more plausible scenario for this file is to allow override of a fan_pressure_range
    # that might be sourced from a general section of ventilation_lookup OR be used to override
    # values that would otherwise come from SYSTEMS_CONFIG.
    # For simplicity, we'll allow "fan_pressure_range" to be specified in ventilation_lookup stage_dict.
    # If not found, the initialized default (0.0, 0.0) is used, implying it's set elsewhere or not applicable.
    # Example: if ventilation_lookup had a generic fan pressure range:
    # fan_pressure_rng = stage_dict.get("generic_fan_pressure_Pa_range", fan_pressure_rng)

    fan_total_efficiency_rng = stage_dict.get("fan_total_efficiency_range", fan_total_efficiency_rng) # NEW

    # Determine system type (A/B/C/D) based on the detailed lookup map
    try:
        system_type_map_lookup = stage_dict.get("system_type_map", {})
        func_key_for_map = "residential" if is_residential else "non_residential"
        # Graceful fallback: if keys are missing, system_type_final retains its default value
        year_map = system_type_map_lookup.get(func_key_for_map, {}).get(year_key, {})
        system_type_final = year_map.get(infiltration_key, system_type_final)
    except Exception as e:
         print(f"[WARNING] Error looking up system_type from map: {e}. Using default '{system_type_final}'.")

    # Lookup f_ctrl range based on the now-determined system_type_final
    if isinstance(sys_ctrl_ranges_lookup, dict):
        system_specific_ctrl_entry = sys_ctrl_ranges_lookup.get(system_type_final, {}) # Get specific entry for system type
        if isinstance(system_specific_ctrl_entry, dict): # Expecting a dict like {"f_ctrl_range": (min, max)}
            f_ctrl_rng = system_specific_ctrl_entry.get("f_ctrl_range", f_ctrl_rng) # Use initialized default if key missing
        else:
            # This handles cases where system_type_final might not have a sub-dict for f_ctrl_range
            print(f"[WARNING] Expected dict for sys_ctrl_ranges['{system_type_final}'], got {type(system_specific_ctrl_entry)}. Using default f_ctrl_range {f_ctrl_rng}.")
            # f_ctrl_rng remains its initialized default
    else:
        # This handles cases where sys_ctrl_ranges_lookup itself is not a dict (e.g., if initial lookup failed)
        print(f"[WARNING] System control ranges ('system_control_range_res' or '_nonres') not found or invalid type. Using default f_ctrl_range {f_ctrl_rng}.")
        # f_ctrl_rng remains its initialized default


    # --- 2) Apply User Overrides ---
    # `matches` will be a list of override rows applicable to this building/scenario/stage
    matches = find_vent_overrides(
        building_id or 0, # Use 0 if building_id is None, for matching rows that don't specify ID
        building_function, # Already defaulted if None
        age_range,         # Already defaulted if None
        scenario,          # Already defaulted
        calibration_stage, # Already defaulted
        user_config_vent
    )

    # Apply overrides to ranges and fixed values by iterating through matched rows
    for row in matches: # override_row
        pname = row.get("param_name", "") # param_name_in_override
        # Pass param_name to override_range for better warning messages
        if pname == "infiltration_base": # Assumed L/s/m2@10Pa
            infiltration_base_rng = override_range(infiltration_base_rng, row, "infiltration_base")
        elif pname == "year_factor":
            year_factor_rng = override_range(year_factor_rng, row, "year_factor")
        elif pname == "system_type":
            if "fixed_value" in row:
                system_type_final = str(row["fixed_value"]) # Directly override system type
                 # Re-lookup f_ctrl range based on potentially overridden system_type
                if isinstance(sys_ctrl_ranges_lookup, dict): # sys_ctrl_ranges
                     system_entry = sys_ctrl_ranges_lookup.get(system_type_final, {}) # system_specific_ctrl_entry
                     if isinstance(system_entry, dict): # Check if the entry itself is a dict
                         f_ctrl_rng = system_entry.get("f_ctrl_range", (1.0, 1.0)) # Default if "f_ctrl_range" not in sub-dict
                     else: f_ctrl_rng = (1.0, 1.0) # Default if system_entry is not a dict
                else: f_ctrl_rng = (1.0, 1.0) # Default if sys_ctrl_ranges_lookup is not a dict
        elif pname == "fan_pressure": # Pa
            fan_pressure_rng = override_range(fan_pressure_rng, row, "fan_pressure")
        elif pname == "fan_total_efficiency": # NEW
            fan_total_efficiency_rng = override_range(fan_total_efficiency_rng, row, "fan_total_efficiency")
        elif pname == "f_ctrl":
            f_ctrl_rng = override_range(f_ctrl_rng, row, "f_ctrl")
        elif pname == "hrv_eff": # Sensible HRV effectiveness
            hrv_sens_eff_rng = override_range(hrv_sens_eff_rng, row, "hrv_eff")
        elif pname == "hrv_latent_eff": # NEW - Latent HRV effectiveness
            hrv_latent_eff_rng = override_range(hrv_latent_eff_rng, row, "hrv_latent_eff")
        elif pname == "infiltration_schedule_name":
            if "fixed_value" in row:
                infiltration_sched_name = str(row["fixed_value"])
        elif pname == "ventilation_schedule_name":
            if "fixed_value" in row:
                ventilation_sched_name = str(row["fixed_value"])
        # Add elif for other parameters like "flow_exponent" if it needs to be configurable via overrides

    # --- 3) Pick Final Values from Ranges ---
    # This local_log will be used to build the `assigned` dictionary returned by the function.
    local_log = {} # Dictionary to hold final picks and ranges for assembly

    # Renaming for clarity on assumed units from lookup/override step for infiltration_base
    # The param_name here will be the key in the output dictionary
    infiltration_base_val = pick_val_with_range(infiltration_base_rng, strategy, local_log, "infiltration_base_L_s_m2_10Pa")
    year_factor_val       = pick_val_with_range(year_factor_rng,       strategy, local_log, "year_factor")
    fan_pressure_val      = pick_val_with_range(fan_pressure_rng,      strategy, local_log, "fan_pressure")
    fan_total_efficiency_val = pick_val_with_range(fan_total_efficiency_rng, strategy, local_log, "fan_total_efficiency") # NEW
    f_ctrl_val            = pick_val_with_range(f_ctrl_rng,            strategy, local_log, "f_ctrl")

    # Only pick HRV efficiency if system is D (balanced mechanical)
    if system_type_final == "D":
        hrv_sens_eff_val = pick_val_with_range(hrv_sens_eff_rng, strategy, local_log, "hrv_eff") # Sensible
        hrv_latent_eff_val = pick_val_with_range(hrv_latent_eff_rng, strategy, local_log, "hrv_lat_eff") # Latent - NEW
    else: # For non-D systems, HRV effectiveness is zero.
        hrv_sens_eff_val = 0.0
        hrv_latent_eff_val = 0.0 # NEW
        local_log["hrv_eff_range"] = (0.0, 0.0) # Log zero range for sensible
        local_log["hrv_eff"] = 0.0
        local_log["hrv_lat_eff_range"] = (0.0, 0.0) # Log zero range for latent - NEW
        local_log["hrv_lat_eff"] = 0.0

    # Store final schedule names and system type
    local_log["infiltration_schedule_name"] = infiltration_sched_name
    local_log["ventilation_schedule_name"]  = ventilation_sched_name
    local_log["system_type"] = system_type_final
    # Store flow exponent (currently default, but could be made configurable/overridable)
    local_log["flow_exponent"] = default_flow_exponent

    # --- 4) Assemble Final Dictionary ---
    # This is the dictionary that will be returned.
    assigned = {
        # Using keys from local_log directly to ensure consistency
        "infiltration_base_L_s_m2_10Pa": local_log["infiltration_base_L_s_m2_10Pa"],
        "infiltration_base_L_s_m2_10Pa_range": local_log["infiltration_base_L_s_m2_10Pa_range"],
        "year_factor": local_log["year_factor"],
        "year_factor_range": local_log["year_factor_range"],
        "fan_pressure": local_log["fan_pressure"], # Pa
        "fan_pressure_range": local_log["fan_pressure_range"],
        "fan_total_efficiency": local_log["fan_total_efficiency"], # NEW (fraction)
        "fan_total_efficiency_range": local_log["fan_total_efficiency_range"], # NEW
        "f_ctrl": local_log["f_ctrl"],
        "f_ctrl_range": local_log["f_ctrl_range"],
        "hrv_eff": local_log["hrv_eff"], # Sensible HRV effectiveness (fraction)
        "hrv_eff_range": local_log["hrv_eff_range"],
        "hrv_lat_eff": local_log["hrv_lat_eff"], # Latent HRV effectiveness (fraction) - NEW
        "hrv_lat_eff_range": local_log["hrv_lat_eff_range"], # NEW
        "infiltration_schedule_name": local_log["infiltration_schedule_name"],
        "ventilation_schedule_name": local_log["ventilation_schedule_name"],
        "system_type": local_log["system_type"],
        "flow_exponent": local_log["flow_exponent"]
    }

    # --- 5) Optionally Log Externally ---
    if assigned_vent_log is not None and isinstance(assigned_vent_log, dict): # Check type of log object
        # Ensure the building entry exists using a sensible key
        building_key_for_log = building_id if building_id is not None else "unknown_building"
        if building_key_for_log not in assigned_vent_log:
            assigned_vent_log[building_key_for_log] = {}
        # Store the entire assigned dictionary, using a copy to avoid modification issues
        assigned_vent_log[building_key_for_log]["building_params"] = assigned.copy() # Changed key to match add_ventilation.py

    return assigned
------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\ventilation\add_ventilation.py
============================================================
# ventilation/add_ventilation.py

import math # Import math for isnan check if needed
from typing import Optional, Dict, Any # Added typing

# Import specific objects/functions - ensure correct imports
try:
    from geomeppy import IDF
    # Attempt to get IDFObject types for more specific hinting if possible
    # This might require geomeppy to be fully initialized or might not be feasible at module level
    # from geomeppy.idfobjects.geometry import Zone  # Example
    # from geomeppy.idfobjects.surface import BuildingSurfaceDetailed # Example
except ImportError:
    IDF = Any 
    # Zone = Any
    # BuildingSurfaceDetailed = Any


from idf_objects.ventilation.assign_ventilation_values import (
    assign_ventilation_params_with_overrides
)
from idf_objects.ventilation.schedules import (
    create_always_on_schedule,
    create_day_night_schedule,
    create_workhours_schedule,
)
from idf_objects.ventilation.create_ventilation_systems import create_ventilation_system
from idf_objects.ventilation.calc_functions import (
    calc_infiltration_rate_at_1Pa_per_m2, 
    calc_required_ventilation_flow
)
from idf_objects.ventilation.mappings import (
    safe_lower,
    map_age_range_to_year_key,
    map_infiltration_key,
    map_usage_key
)

# Define type alias for clarity
BuildingRow = Dict[str, Any]
ZoneInfoMap = Dict[str, Dict[str, Any]] # e.g., {zone_name: {'area': float, 'is_core': bool}}
AssignedVentLog = Dict[Any, Dict[str, Any]]


def get_zone_floor_area_from_surfaces(idf: IDF, zone_name: str) -> float:
    """
    Calculates the zone's floor area by summing the areas of its 'floor' surfaces.
    This is a fallback if the ZONE object's Floor_Area is 'autocalculate' or not resolved.
    """
    total_floor_surface_area = 0.0
    # Ensure we are getting the correct collection of surfaces
    # geomeppy typically stores IDF objects in idf.idfobjects['BUILDINGSURFACE:DETAILED']
    # or idf.idfobjects.get('BUILDINGSURFACE:DETAILED', [])
    surfaces = idf.idfobjects.get("BUILDINGSURFACE:DETAILED", [])
    if not surfaces: # Fallback for older geomeppy or different structure
        surfaces = idf.idfobjects.get("BuildingSurface:Detailed", [])


    for surface in surfaces:
        try:
            # Ensure surface.Zone_Name exists and is a string before calling .upper()
            surface_zone_name = getattr(surface, 'Zone_Name', None)
            if surface_zone_name is None:
                continue # Skip if no zone name

            surface_type_attr = getattr(surface, 'Surface_Type', '').lower()
            
            if surface_zone_name.upper() == zone_name.upper() and surface_type_attr == 'floor':
                # geomeppy's surface.area property should give the calculated area
                # For IDF objects directly, it might be 'Gross_Area' or similar if not using geomeppy's calculated properties
                surface_area = getattr(surface, 'area', 0.0) # geomeppy property
                if surface_area <= 1e-6 and hasattr(surface, 'Gross_Area'): # Fallback to raw IDF field if 'area' is not helpful
                    try:
                        surface_area = float(surface.Gross_Area)
                    except (ValueError, TypeError):
                        surface_area = 0.0

                if isinstance(surface_area, (float, int)) and surface_area > 0:
                    total_floor_surface_area += surface_area
        except Exception as e:
            surface_id = getattr(surface, 'Name', 'UnknownSurface')
            print(f"[WARNING] Error accessing properties for surface '{surface_id}' in zone '{zone_name}': {e}")
            continue # Skip this surface if there's an issue
    
    if total_floor_surface_area > 1e-6: # Use a small threshold to consider it valid
        print(f"[VENT INFO] Calculated floor area for zone '{zone_name}' by summing floor surfaces: {total_floor_surface_area:.2f} m2.")
    return total_floor_surface_area


def add_ventilation_to_idf(
    idf: IDF,
    building_row: BuildingRow,
    calibration_stage: str ="pre_calibration",
    strategy: str ="A",
    random_seed: Optional[int] =None,
    user_config_vent: Optional[list] =None,
    assigned_vent_log: Optional[AssignedVentLog] =None,
    zone_details: Optional[ZoneInfoMap] =None, 
    system_d_infiltration_reduction_factor: float = 1.0,
    infiltration_model: str = "constant",
    typical_delta_t: float = 10.0,
    typical_wind: float = 3.0
):
    """
    Adds infiltration + ventilation to the IDF based on ``building_row`` data.
    
    ``infiltration_model`` selects how infiltration varies with weather:
    ``"constant"`` keeps a fixed design flow, while ``"weather"`` applies
    coefficients based on ``typical_delta_t`` and ``typical_wind``.

    Enhancements:
    - Attempts to sum floor surface areas if ZONE object area is 'autocalculate'.
    - Dynamically sets DSOA Outdoor_Air_Flow_per_Zone_Floor_Area for System D based on
      base ventilation rates and f_ctrl.
    - Passes zone_floor_area_m2 to create_ventilation_system for "Flow/Area" calculations.
    """

    # --- 1) Ensure key schedules exist ---
    create_always_on_schedule(idf, "AlwaysOnSched")
    create_day_night_schedule(idf, "VentSched_DayNight")
    create_workhours_schedule(idf, "WorkHoursSched")

    # --- 2) Extract building info ---
    bldg_id = building_row.get("ogc_fid", "UnknownBuildingID") 
    bldg_func = safe_lower(building_row.get("building_function", "residential"))
    if bldg_func not in ("residential", "non_residential"):
        bldg_func = "residential" 

    age_range_str = building_row.get("age_range", "2015 and later") 
    scenario = building_row.get("scenario", "scenario1") 
    total_bldg_floor_area_m2_input = building_row.get("area", 100.0) 
    
    if not isinstance(total_bldg_floor_area_m2_input, (int,float)) or total_bldg_floor_area_m2_input <= 0:
        print(f"[VENT WARNING] Building {bldg_id}: Invalid total building floor area attribute ('area': {total_bldg_floor_area_m2_input}). Defaulting to 100.0 m2.")
        total_bldg_floor_area_m2_input = 100.0

    # --- 3) Decide lookup keys ---
    infiltration_key = map_infiltration_key(building_row) 
    usage_key = map_usage_key(building_row) 
    year_key = map_age_range_to_year_key(age_range_str) 
    is_res = (bldg_func == "residential")

    # --- 4) Assign building-level ventilation parameters ---
    assigned_vent = assign_ventilation_params_with_overrides(
        building_id=bldg_id, building_function=bldg_func, age_range=age_range_str,
        scenario=scenario, calibration_stage=calibration_stage, strategy=strategy,
        random_seed=random_seed, user_config_vent=user_config_vent,
        infiltration_key=infiltration_key, year_key=year_key, is_residential=is_res,
        default_flow_exponent=0.67
    )

    # --- 5) Unpack chosen building-level parameters ---
    infiltration_base_L_s_m2_10Pa = assigned_vent["infiltration_base_L_s_m2_10Pa"]
    year_factor = assigned_vent["year_factor"]
    fan_pressure_Pa = assigned_vent.get("fan_pressure")
    fan_total_efficiency = assigned_vent.get("fan_total_efficiency")
    f_ctrl = assigned_vent["f_ctrl"] 
    hrv_sens_eff = assigned_vent["hrv_eff"] 
    hrv_lat_eff = assigned_vent.get("hrv_lat_eff", 0.0) 
    infiltration_sched_name = assigned_vent["infiltration_schedule_name"]
    ventilation_sched_name = assigned_vent["ventilation_schedule_name"]
    system_type = assigned_vent["system_type"] 
    flow_exponent = assigned_vent["flow_exponent"]

    # --- 6) Debug Print ---
    print(
        f"[VENT PARAMS] Bldg={bldg_id}, Func={bldg_func}, AgeKey='{year_key}', Sys={system_type}\n"
        f"  LookupKeys: Infil='{infiltration_key}', Usage='{usage_key if usage_key else 'N/A'}'\n"
        f"  InfilParams: Base(L/s/m2@10Pa)={infiltration_base_L_s_m2_10Pa:.4f}, YearFactor={year_factor:.3f}, Exp={flow_exponent}\n"
        f"  VentParams: f_ctrl={f_ctrl:.3f}, HRV_SensEff={hrv_sens_eff:.3f}, HRV_LatEff={hrv_lat_eff:.3f}\n"
        f"  FanParams: Pressure={fan_pressure_Pa if fan_pressure_Pa is not None else 'N/A'} Pa, Efficiency={fan_total_efficiency if fan_total_efficiency is not None else 'N/A'}\n"
        f"  Schedules: Infil='{infiltration_sched_name}', Vent='{ventilation_sched_name}'"
    )

    # --- 7) Calculate Base Infiltration Rate (@1Pa) per m2 floor area ---
    infiltration_rate_at_1Pa_L_s_per_m2_floor_area = calc_infiltration_rate_at_1Pa_per_m2(
        infiltration_base_at_10Pa_per_m2=infiltration_base_L_s_m2_10Pa,
        year_factor=year_factor,
        flow_exponent=flow_exponent
    )

    if system_type == "D" and system_d_infiltration_reduction_factor != 1.0:
        effective_rate_before_reduction = infiltration_rate_at_1Pa_L_s_per_m2_floor_area
        infiltration_rate_at_1Pa_L_s_per_m2_floor_area *= system_d_infiltration_reduction_factor
        print(f"  System D: Infiltration rate reduced by factor {system_d_infiltration_reduction_factor:.2f} from {effective_rate_before_reduction:.4f} to {infiltration_rate_at_1Pa_L_s_per_m2_floor_area:.4f} L/s/m2 @ 1Pa")

    # --- 8) Calculate Total Required Mechanical Ventilation Flow for the building ---
    vent_flow_m3_s_total_building = calc_required_ventilation_flow(
        building_function=bldg_func,
        f_ctrl_val=f_ctrl, # Note: f_ctrl is applied *here* to the total building flow
        floor_area_m2=total_bldg_floor_area_m2_input, 
        usage_key=usage_key
    )

    # --- 9) Determine DSOA object name and ensure it exists for System D ---
    dsoa_object_name_global = "DSOA_Global" 
    if system_type == "D":
        dsoa_obj = idf.getobject("DESIGNSPECIFICATION:OUTDOORAIR", dsoa_object_name_global.upper())
        if not dsoa_obj:
            print(f"[VENT INFO] Building {bldg_id}: Creating default DesignSpecification:OutdoorAir: {dsoa_object_name_global}")
            try:
                dsoa_obj = idf.newidfobject("DESIGNSPECIFICATION:OUTDOORAIR")
                dsoa_obj.Name = dsoa_object_name_global
                # For "Flow/Area" method, this is the primary method.
                dsoa_obj.Outdoor_Air_Method = "Flow/Area" # << CHANGED to Flow/Area for explicitness
            except Exception as e:
                print(f"[ERROR] Building {bldg_id}: Failed to create {dsoa_object_name_global}: {e}")
                dsoa_obj = None # Ensure dsoa_obj is None if creation fails

        if dsoa_obj: # Proceed only if DSOA object exists or was successfully created
            # Dynamically set DSOA Outdoor_Air_Flow_per_Zone_Floor_Area
            base_design_rate_L_s_m2 = 0.0
            if bldg_func == "residential":
                base_design_rate_L_s_m2 = 0.9 # Default L/s/m2 for residential
            else: # Non-residential
                usage_flow_map_L_s_m2 = { # Should match the map in calc_required_ventilation_flow
                    "office_area_based": 1.0, "childcare": 4.8, "retail": 0.6,
                    "meeting_function": 1.0, "healthcare_function": 1.2, "sport_function": 1.5,
                    "cell_function": 0.8, "industrial_function": 0.5, "accommodation_function": 0.9,
                    "education_function": 1.1, "other_use_function": 0.6
                }
                base_design_rate_L_s_m2 = usage_flow_map_L_s_m2.get(usage_key, 1.0) # Default if key unknown
            
            # Apply f_ctrl to this base per-m2 rate for DSOA
            # Convert L/s/m2 to m3/s/m2 for DSOA field
            dsoa_flow_per_area_m3_s_m2 = (base_design_rate_L_s_m2 * f_ctrl) / 1000.0
            
            # The field name in geomeppy is Outdoor_Air_Flow_per_Zone_Floor_Area.
            # EnergyPlus IDD for "Flow/Area" method expects "Outdoor Air Flow per Floor Area".
            # Assuming geomeppy maps this correctly or the field name is suitable.
            dsoa_obj.Outdoor_Air_Flow_per_Zone_Floor_Area = dsoa_flow_per_area_m3_s_m2
            # Set other DSOA rate fields to 0 as "Flow/Area" is the sole driver
            dsoa_obj.Outdoor_Air_Flow_per_Person = 0.0 
            dsoa_obj.Outdoor_Air_Flow_per_Zone = 0.0
            dsoa_obj.Outdoor_Air_Flow_Air_Changes_per_Hour = 0.0
            print(f"  System D: Set DSOA '{dsoa_obj.Name}' Outdoor_Air_Flow_per_Zone_Floor_Area to {dsoa_flow_per_area_m3_s_m2:.6f} m3/s-m2 (derived from base rate {base_design_rate_L_s_m2:.2f} L/s/m2 and f_ctrl {f_ctrl:.3f})")

            # Optional: Assign a fraction schedule to DSOA if OA flow should vary by time
            # dsoa_obj.Outdoor_Air_Flow_Rate_Fraction_Schedule_Name = "Name_Of_OA_Fraction_Schedule"


    # --- 10) Get Zones and Prepare Zone Information Map ---
    # Ensure we get the correct collection name for ZONE objects
    zones_in_idf = idf.idfobjects.get("ZONE", [])
    if not zones_in_idf: # Fallback for older geomeppy or different structure
        zones_in_idf = idf.idfobjects.get("Zone", [])

    if not zones_in_idf:
        print(f"[VENT ERROR] Building {bldg_id}: No ZONE objects found. Cannot proceed."); return

    num_zones = len(zones_in_idf)
    effective_zone_info_map: ZoneInfoMap = {}
    sum_of_individual_zone_areas = 0.0

    if zone_details: 
        valid_zone_details = True; temp_total_area = 0.0
        for zd_name, zd_props in zone_details.items():
            if not (isinstance(zd_props, dict) and 'area' in zd_props and 
                    isinstance(zd_props['area'], (float, int)) and zd_props['area'] >= 0 and 
                    'is_core' in zd_props and isinstance(zd_props['is_core'], bool)):
                valid_zone_details = False; break
            temp_total_area += zd_props['area']
        if valid_zone_details and temp_total_area > 1e-6: # Use a small threshold
            effective_zone_info_map = zone_details
            sum_of_individual_zone_areas = temp_total_area
        else: effective_zone_info_map = {}; sum_of_individual_zone_areas = 0.0 
    
    if not effective_zone_info_map or sum_of_individual_zone_areas <= 1e-6: 
        print(f"[VENT INFO] Bldg {bldg_id}: Calculating zone areas/core status from IDF (zone_details not provided, invalid, or zero area).")
        sum_of_individual_zone_areas = 0.0; effective_zone_info_map = {} 
        for zone_obj in zones_in_idf:
            zone_name_key = zone_obj.Name; area_val = 0.0; raw_field_value_str = ""
            try: # Try geomeppy's .floor_area property
                area_val = getattr(zone_obj, 'floor_area', 0.0) # Use getattr for safety
                if not isinstance(area_val, (float, int)) or area_val < 0: area_val = 0.0
            except Exception: area_val = 0.0
            
            if area_val < 1e-6: # If .floor_area didn't yield a positive area, try raw IDF field or summing surfaces
                area_val = 0.0 # Reset before trying next methods
                try: 
                    raw_field_value_str = str(getattr(zone_obj, 'Floor_Area', "")).strip().lower()
                    if raw_field_value_str == "autocalculate":
                        print(f"[VENT INFO] Bldg {bldg_id}: Zone '{zone_name_key}' Floor_Area is 'autocalculate'. Attempting to sum floor surfaces.")
                        area_val = get_zone_floor_area_from_surfaces(idf, zone_name_key)
                        if area_val < 1e-6:
                             print(f"[VENT WARNING] Bldg {bldg_id}: Zone '{zone_name_key}' - summing floor surfaces yielded {area_val:.4f} m2. Using 0 for this zone's area calculation.")
                             area_val = 0.0
                    elif raw_field_value_str: # If not autocalculate, try to convert
                        area_val = float(raw_field_value_str)
                        if area_val < 0: area_val = 0.0 
                except ValueError: 
                    print(f"[VENT WARNING] Bldg {bldg_id}: Zone '{zone_name_key}' Floor_Area field ('{raw_field_value_str}') is not 'autocalculate' and not a valid number. Using 0.")
                    area_val = 0.0
                except Exception as e_conv: 
                    print(f"[VENT WARNING] Bldg {bldg_id}: Error processing Floor_Area for zone '{zone_name_key}' (raw: '{raw_field_value_str}'): {e_conv}. Using 0.")
                    area_val = 0.0
            
            if area_val <= 1e-6 : # If still zero after all attempts
                 print(f"[VENT WARNING] Bldg {bldg_id}: Zone '{zone_name_key}' final determined area is {area_val:.4f} m2. This might cause issues if it's the only zone or all zones have zero area.")
            
            effective_zone_info_map[zone_name_key] = {'area': area_val, 'is_core': "_core" in safe_lower(zone_name_key)}
            sum_of_individual_zone_areas += area_val

    use_equal_split_fallback = False
    final_total_area_for_proportions = sum_of_individual_zone_areas

    if sum_of_individual_zone_areas <= 1e-6: # Use a small threshold
        print(f"[VENT ERROR] Bldg {bldg_id}: Sum of individual zone areas is {sum_of_individual_zone_areas}. Fallback active.")
        if total_bldg_floor_area_m2_input > 0 and num_zones > 0:
            use_equal_split_fallback = True
            average_zone_area_for_fallback = total_bldg_floor_area_m2_input / num_zones
            print(f"  Using total building area attribute {total_bldg_floor_area_m2_input}m2; average zone area for fallback: {average_zone_area_for_fallback:.2f}m2.")
            temp_map_for_fallback = {}
            for zone_obj_fb in zones_in_idf:
                temp_map_for_fallback[zone_obj_fb.Name] = {
                    'area': average_zone_area_for_fallback, 
                    'is_core': "_core" in safe_lower(zone_obj_fb.Name)
                }
            effective_zone_info_map = temp_map_for_fallback
            final_total_area_for_proportions = total_bldg_floor_area_m2_input 
        else:
            print(f"[VENT CRITICAL] Bldg {bldg_id}: Cannot distribute flows. Sum of zone areas is zero and input building area is zero or no zones. Aborting."); return

    # --- 11) Log Building-Level Parameters ---
    if assigned_vent_log is not None:
        if bldg_id not in assigned_vent_log: assigned_vent_log[bldg_id] = {}
        log_building_params = assigned_vent.copy()
        log_building_params["infiltration_rate_at_1Pa_L_s_per_m2_EFFECTIVE"] = infiltration_rate_at_1Pa_L_s_per_m2_floor_area
        log_building_params["ventilation_total_required_m3_s_building"] = vent_flow_m3_s_total_building
        log_building_params["total_bldg_floor_area_m2_input_attr"] = total_bldg_floor_area_m2_input
        log_building_params["sum_of_individual_zone_areas_derived"] = sum_of_individual_zone_areas 
        log_building_params["final_total_area_used_for_proportions"] = final_total_area_for_proportions
        log_building_params["flow_distribution_method"] = "EqualSplitFallbackLogicActive" if use_equal_split_fallback else "ProportionalToIndividualZoneArea"
        log_building_params["system_d_infiltration_reduction_factor_applied"] = system_d_infiltration_reduction_factor if system_type == "D" and system_d_infiltration_reduction_factor != 1.0 else None
        assigned_vent_log[bldg_id]["building_params"] = log_building_params
        assigned_vent_log[bldg_id]["zones"] = {} 

    print(
        f"[VENT FLOWS] Bldg={bldg_id}: BaseInfilRate(@1Pa,Effective)={infiltration_rate_at_1Pa_L_s_per_m2_floor_area:.4f} L/s/m2, "
        f"TotalMechVentReq={vent_flow_m3_s_total_building:.4f} m3/s, "
        f"DistMethod={'EqualSplitFallbackLogicActive' if use_equal_split_fallback else 'ProportionalToIndividualZoneArea'}"
    )
    
    # --- 12) Loop Through Zones: Calculate Zone Flows & Create IDF Objects ---
    for zone_obj_loopvar in zones_in_idf:
        zone_name_curr = zone_obj_loopvar.Name
        zone_info_curr = effective_zone_info_map.get(zone_name_curr)
        if not zone_info_curr: 
            print(f"[VENT CRITICAL ERROR] Zone '{zone_name_curr}' not found in effective map. Skipping."); continue 
            
        zone_floor_area_curr_m2 = zone_info_curr.get('area', 0.0) 
        is_core_zone_curr = zone_info_curr.get('is_core', False)

        infiltration_for_this_zone_m3_s = 0.0
        ventilation_for_this_zone_m3_s = 0.0

        if is_core_zone_curr:
            infiltration_for_this_zone_m3_s = 0.0 # Core zones typically have no direct envelope infiltration
        else: 
            if zone_floor_area_curr_m2 > 1e-6: # Only calculate if area is positive
                infiltration_L_s = infiltration_rate_at_1Pa_L_s_per_m2_floor_area * zone_floor_area_curr_m2
                infiltration_for_this_zone_m3_s = infiltration_L_s / 1000.0
        
        # Distribute total building mechanical ventilation proportionally to zone areas
        if final_total_area_for_proportions > 1e-6 and zone_floor_area_curr_m2 >= 0: # Allow zero area zones to get zero flow if proportional
            proportion = zone_floor_area_curr_m2 / final_total_area_for_proportions if final_total_area_for_proportions > 0 else 0
            ventilation_for_this_zone_m3_s = vent_flow_m3_s_total_building * proportion
        elif num_zones > 0 : # Fallback if total area for proportions is zero (e.g. all zones had zero area initially)
             ventilation_for_this_zone_m3_s = vent_flow_m3_s_total_building / num_zones
        
        fan_param_overrides = {}
        if fan_pressure_Pa is not None: fan_param_overrides["fan_pressure_override_Pa"] = fan_pressure_Pa
        if fan_total_efficiency is not None: fan_param_overrides["fan_efficiency_override"] = fan_total_efficiency
            
        iobj, vobj = create_ventilation_system(
            idf=idf,
            building_function=bldg_func,
            system_type=system_type,
            zone_name=zone_name_curr,
            infiltration_m3_s=infiltration_for_this_zone_m3_s, # This is TOTAL m3/s for the zone
            vent_flow_m3_s=ventilation_for_this_zone_m3_s,     # This is TOTAL m3/s for the zone
            zone_floor_area_m2=zone_floor_area_curr_m2,       # << PASSING ZONE AREA
            infiltration_sched_name=infiltration_sched_name,
            ventilation_sched_name=ventilation_sched_name,
            infiltration_model=infiltration_model,
            typical_delta_t=typical_delta_t,
            typical_wind=typical_wind,
            pick_strategy="random" if strategy == "B" else "midpoint",
            dsoa_object_name=dsoa_object_name_global if system_type == "D" else None,
            hrv_sensible_effectiveness=hrv_sens_eff if system_type == "D" else 0.0,
            hrv_latent_effectiveness=hrv_lat_eff if system_type == "D" else 0.0,
            **fan_param_overrides,
        )

        if assigned_vent_log is not None and bldg_id in assigned_vent_log: 
            if "zones" not in assigned_vent_log[bldg_id]:
                assigned_vent_log[bldg_id]["zones"] = {}
            assigned_vent_log[bldg_id]["zones"][zone_name_curr] = {
                "infiltration_object_name": iobj.Name if iobj else "N/A", 
                "infiltration_object_type": iobj.key if iobj else "N/A",
                "infiltration_flow_m3_s_DESIGN_TOTAL_ZONE": infiltration_for_this_zone_m3_s, # Log the total zone flow
                "infiltration_flow_m3_s_m2_DESIGN_ZONE": (infiltration_for_this_zone_m3_s / zone_floor_area_curr_m2) if zone_floor_area_curr_m2 > 1e-6 else 0.0,
                "infiltration_schedule_name": infiltration_sched_name,
                "ventilation_object_name": vobj.Name if vobj else "N/A",
                "ventilation_object_type": vobj.key if vobj else "N/A",
                "ventilation_flow_m3_s_DESIGN_TOTAL_ZONE": ventilation_for_this_zone_m3_s if vobj else 0.0, # Log the total zone flow
                "ventilation_flow_m3_s_m2_DESIGN_ZONE": (ventilation_for_this_zone_m3_s / zone_floor_area_curr_m2) if vobj and zone_floor_area_curr_m2 > 1e-6 else 0.0,
                "ventilation_schedule_name": ventilation_sched_name,
                "zone_floor_area_m2_used_for_dist": zone_floor_area_curr_m2, 
                "is_core_zone": is_core_zone_curr
            }
        elif assigned_vent_log is not None: 
            print(f"[VENT WARNING] Building ID {bldg_id} not in log for zone {zone_name_curr}")

    print(f"[VENTILATION] Completed ventilation setup for Building {bldg_id}.")

------------------------------------------------------------

# ventilation/schedule_lookup.py

"""
This file defines SCHEDULE_LOOKUP, a dictionary organizing realistic, ranged
schedule patterns for building archetypes, suitable for energy modeling.

Rationale for Improvement:
1.  More Detailed Time Slices: Schedules are broken down into more granular periods,
    including morning/evening peaks, daytime setbacks, lunch breaks, and janitorial
    hours to better capture building dynamics.
2.  Logic-Driven Ranges: The (min, max) value ranges are not arbitrary.
    - A low minimum (e.g., 0.0-0.1) during unoccupied hours reflects Demand-Controlled
      Ventilation (DCV) providing minimal background airflow.
    - A tight, high range (e.g., 0.95-1.0) during peak occupancy represents the
      system running at full design capacity.
    - Broader ranges during shoulder periods represent operational uncertainty.
3.  Clearer Ventilation vs. Infiltration Logic:
    - Ventilation (Mechanical): This schedule is a proxy for occupancy and internal
      loads. It is significantly reduced or turned off when the building is empty.
    - Infiltration (Natural): This schedule represents the 'availability' of leakage
      paths. For non-residential buildings, it is modeled as being higher when the
      mechanical ventilation is off (no pressurization) and lower during operational
      hours. For residential buildings, it remains high, proxying for occupant presence
      and window-opening behavior.

Structure:
SCHEDULE_LOOKUP[building_function][archetype_key][purpose][day_type]
"""

SCHEDULE_LOOKUP = {
    # =====================================================================
    # Residential Building Schedules
    # =====================================================================
    "residential": {
        "default": {  # Fallback: A typical family home pattern
            "ventilation": {
                # Weekday: People leave for work/school.
                "weekday": [(0, 6, (0.30, 0.50)),    # Night setback
                            (6, 9, (0.80, 1.00)),    # Morning peak (showers, breakfast)
                            (9, 16, (0.40, 0.60)),   # Daytime low (unoccupied/less active)
                            (16, 22, (0.90, 1.00)),  # Evening peak (cooking, activity)
                            (22, 24, (0.30, 0.50))], # Night setback
                # Weekend: People are home more often and activity is spread out.
                "weekend": [(0, 8, (0.40, 0.60)),    # Later night setback
                            (8, 23, (0.85, 1.00)),   # Broad, high daytime activity
                            (23, 24, (0.40, 0.60))], # Night setback
            },
            "infiltration": {
                # Potential for infiltration and window opening is always high when occupied.
                "allday": [(0, 24, (0.90, 1.00))],
            }
        },
        "Apartment": { # Often smaller, with quicker temperature/air quality changes.
            "ventilation": {
                "weekday": [(0, 6, (0.25, 0.40)), (6, 9, (0.85, 1.00)), (9, 17, (0.30, 0.50)), (17, 23, (0.95, 1.00)), (23, 24, (0.25, 0.40))],
                "weekend": [(0, 8, (0.40, 0.60)), (8, 23, (0.90, 1.00)), (23, 24, (0.40, 0.60))],
            },
            "infiltration": {
                "allday": [(0, 24, (0.90, 1.00))],
            }
        },
    },

    # =====================================================================
    # Non-Residential Building Schedules
    # =====================================================================
    "non_residential": {
        "default": {  # Fallback: Generic 9-5 Office.
            "ventilation": {
                "weekday": [(0, 7, (0.00, 0.10)), (7, 18, (0.90, 1.00)), (18, 24, (0.00, 0.10))],
                "weekend": [(0, 24, (0.00, 0.05))],
            },
            "infiltration": {
                "weekday": [(0, 7, (0.80, 1.00)), (7, 18, (0.30, 0.50)), (18, 24, (0.80, 1.00))],
                "weekend": [(0, 24, (0.90, 1.00))]
            }
        },
        "Office Function": {
            "ventilation": {
                "weekday": [(0, 7, (0.05, 0.15)),    # Night/unoccupied DCV rate
                            (7, 9, (0.95, 1.00)),    # Morning arrival peak
                            (9, 12, (0.90, 1.00)),   # Core morning work
                            (12, 14, (0.70, 0.85)),  # Lunch period dip
                            (14, 17, (0.90, 1.00)),  # Core afternoon work
                            (17, 18, (0.60, 0.80)),  # People leaving
                            (18, 20, (0.20, 0.30)),  # Cleaning crew period
                            (20, 24, (0.05, 0.15))], # Unoccupied
                "weekend": [(0, 24, (0.00, 0.10))],  # Weekend (minimal/off)
            },
            "infiltration": {
                "weekday": [(0, 7, (0.80, 1.00)), (7, 18, (0.25, 0.45)), (18, 24, (0.80, 1.00))], # Suppressed by HVAC pressure during day
                "weekend": [(0, 24, (0.90, 1.00))],
            }
        },
        "Retail Function": { # Assumes a store in a shopping street or mall
            "ventilation": {
                "weekday": [(0, 8, (0.05, 0.10)),    # Pre-opening
                            (8, 10, (0.70, 0.90)),   # Opening/stocking
                            (10, 19, (0.95, 1.00)),  # Peak customer hours
                            (19, 21, (0.40, 0.60)),  # Closing/cleaning
                            (21, 24, (0.05, 0.10))], # Closed
                "weekend": [(0, 9, (0.05, 0.15)),    # Saturday/Sunday opening prep
                            (9, 18, (0.95, 1.00)),   # Peak weekend customers
                            (18, 20, (0.40, 0.60)),  # Closing
                            (20, 24, (0.05, 0.15))], # Closed
            },
            "infiltration": { # Dominated by door openings
                "weekday": [(0, 9, (0.40, 0.60)), (9, 20, (0.80, 1.00)), (20, 24, (0.40, 0.60))],
                "weekend": [(0, 9, (0.40, 0.60)), (9, 19, (0.90, 1.00)), (19, 24, (0.40, 0.60))],
            }
        },
        "Education Function": { # School
            "ventilation": {
                "weekday": [(0, 7, (0.00, 0.10)),    # Unoccupied
                            (7, 12, (0.95, 1.00)),   # Morning classes
                            (12, 13, (0.50, 0.70)),  # Lunch break (less classroom occupancy)
                            (13, 16, (0.95, 1.00)),  # Afternoon classes
                            (16, 18, (0.30, 0.50)),  # After-school care / activities
                            (18, 24, (0.00, 0.10))], # Closed
                "weekend": [(0, 24, (0.00, 0.05))],  # No regular activity
            },
            "infiltration": {
                "weekday": [(0, 7, (0.70, 0.90)), (7, 17, (0.40, 0.60)), (17, 24, (0.70, 0.90))],
                "weekend": [(0, 24, (0.80, 1.00))],
            }
        },
        "Healthcare Function": { # Hospital (24/7 operation)
            "ventilation": {
                # High minimum rates required at all times.
                "allday": [(0, 7, (0.65, 0.80)),    # Night (lower activity, but still high demand)
                           (7, 21, (0.90, 1.00)),   # Daytime (procedures, visitors)
                           (21, 24, (0.65, 0.80))], # Evening/early night
            },
            "infiltration": {
                # Often pressurized; infiltration is minimized and controlled.
                "allday": [(0, 24, (0.10, 0.25))]
            }
        },
        "Accommodation Function": { # Hotel
             "ventilation": {
                "allday": [(0, 6, (0.50, 0.70)),    # Night (occupied rooms)
                           (6, 10, (0.85, 1.00)),   # Morning checkout/breakfast peak
                           (10, 16, (0.40, 0.60)),  # Mid-day low (guests out, cleaning)
                           (16, 24, (0.90, 1.00))], # Evening check-in / guests returning
            },
            "infiltration": {
                "allday": [(0, 24, (0.60, 0.80))] # Higher quality construction than average residential
            }
        },
    }
}

