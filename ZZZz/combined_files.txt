File: D:\Documents\E_Plus_2030_py\idf_objects\wshading\assign_shading_values.py
============================================================
"""
assign_shading_values.py

This module picks the final shading parameters from shading_lookup.py 
and optionally user overrides or Excel-based rules. The actual creation 
of EnergyPlus objects (e.g. WindowMaterial:Blind, Shading:Building:Detailed, etc.) 
will happen in another file (e.g. create_shading_objects.py).
"""

import random
from .shading_lookup import shading_lookup

def pick_val_from_range(rng_tuple, strategy="A"):
    """
    Helper function to pick a numeric value from (min_val, max_val).
    - If strategy="A", picks the midpoint.
    - If strategy="B", picks a random value in [min_val, max_val].
    - Otherwise, picks min_val.
    """
    if not rng_tuple or len(rng_tuple) < 2:
        return None
    min_val, max_val = rng_tuple
    if min_val is None or max_val is None:
        return min_val if min_val is not None else max_val  # fallback
    if min_val == max_val:
        return min_val  # no variability
    if strategy == "A":
        return 0.5 * (min_val + max_val)
    elif strategy == "B":
        return random.uniform(min_val, max_val)
    else:
        return min_val

def pick_shading_params(
    window_id,
    shading_type_key="my_external_louvers",
    strategy="A",
    user_config=None,
    assigned_shading_log=None
):
    """
    1) Looks up default shading parameters from shading_lookup[shading_type_key].
    2) If user_config is provided, override or adjust some values if needed.
    3) Based on 'strategy', pick final numeric values (midpoint or random) 
       from any ranges in these parameters.
    4) Optionally log the final picks in assigned_shading_log.

    Parameters
    ----------
    window_id : str
        An identifier for the window (optional, for logging).
    shading_type_key : str
        The key in shading_lookup to use, e.g. "my_external_louvers".
    strategy : str
        "A" => pick midpoint from ranges; "B" => pick random.
        Otherwise => pick min_val for everything.
    user_config : dict or None
        E.g. { "my_external_louvers": { "slat_angle_deg_range": (30, 60) } }
        to override certain ranges for all windows or certain IDs.
    assigned_shading_log : dict or None
        If provided, store final picks under assigned_shading_log[window_id].

    Returns
    -------
    dict
        A dictionary of final shading parameters, e.g.:
        {
          "blind_name": "MyExternalLouvers",
          "slat_orientation": "Horizontal",
          "slat_width": 0.025,
          ...
        }
    """
    # 1) Fetch base parameters from shading_lookup
    base_params = shading_lookup.get(shading_type_key, {})
    final_params = dict(base_params)  # shallow copy

    # 2) If user_config => update the base_params or override certain fields
    if user_config and shading_type_key in user_config:
        overrides_for_this_type = user_config[shading_type_key]
        for key, val in overrides_for_this_type.items():
            if key in final_params and isinstance(val, tuple) and len(val) == 2:
                # e.g. override "slat_angle_deg_range" => (30, 60)
                final_params[key] = val
            else:
                # you could also allow single fixed values or booleans
                final_params[key] = val

    # 3) Convert all "*_range" fields to single numeric picks
    #    e.g. final_params["slat_width_range"] => final_params["slat_width"]
    #    Then remove the old range key from final_params.
    fields_to_remove = []
    for field_key, field_val in final_params.items():
        if field_key.endswith("_range") and isinstance(field_val, tuple):
            param_name = field_key[:-6]  # remove "_range"
            chosen_val = pick_val_from_range(field_val, strategy=strategy)
            final_params[param_name] = chosen_val
            fields_to_remove.append(field_key)

    for ftr in fields_to_remove:
        del final_params[ftr]

    # 4) If assigned_shading_log is provided, store the final chosen values
    if assigned_shading_log is not None and window_id is not None:
        if window_id not in assigned_shading_log:
            assigned_shading_log[window_id] = {}
        assigned_shading_log[window_id]["shading_params"] = final_params

    return final_params

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\wshading\create_shading_objects.py
============================================================
"""
create_shading_objects.py

This module creates EnergyPlus shading objects in the IDF
(e.g., WindowMaterial:Blind, WindowProperty:ShadingControl,
 Shading:Building:Detailed, schedules, etc.).

It calls pick_shading_params(...) from assign_shading_values.py
to get final numeric parameter values. You can pass user/Excel overrides
to customize these parameters.

Usage:
  from idf_objects.wshading.create_shading_objects import add_shading_objects

  add_shading_objects(
      idf=idf,
      building_row=some_dict,
      shading_type_key="my_external_louvers",
      strategy="B",
      random_seed=42,
      user_config_shading=shading_dict,
      assigned_shading_log=shading_log_dict
  )
"""

import random
from .assign_shading_values import pick_shading_params
# from geomeppy import IDF  # or from eppy.bunch_subclass import EpBunch, if you prefer eppy

def add_shading_objects(
    idf,
    building_row,
    shading_type_key="my_external_louvers",
    strategy="A",
    random_seed=42,
    user_config_shading=None,
    assigned_shading_log=None,
    create_blinds=True,
    create_geometry_shading=False
):
    """
    Creates the necessary shading objects in the IDF: e.g. WindowMaterial:Blind,
    WindowProperty:ShadingControl, or geometry-based Shading:Building:Detailed.

    1) Loops over fenestration surfaces (or just once, depending on logic).
    2) Calls pick_shading_params(...) to get final numeric values (slat angles, etc.).
    3) Creates an EnergyPlus shading device (WindowMaterial:Blind + ShadingControl).
    4) Optionally, create an E+ schedule if dynamic shading is needed.
    5) Optionally, create Shading:Building:Detailed geometry if requested.

    Parameters
    ----------
    idf : IDF
        The IDF object where new objects will be added.
    building_row : dict or pandas.Series
        Row of building data, if needed to pick orientation/area, etc.
    shading_type_key : str
        Key in shading_lookup, e.g. "my_external_louvers".
    strategy : str
        "A" => pick midpoint from param ranges; "B" => pick random, etc.
    random_seed : int
        For reproducibility if strategy="B".
    user_config_shading : dict or None
        Shading overrides to pass to pick_shading_params(...).
        E.g. {
          "my_external_louvers": {
              "slat_angle_deg_range": (30, 60),
              ...
          }
        }
    assigned_shading_log : dict or None
        If provided, final shading params are stored under assigned_shading_log[window_id].
    create_blinds : bool
        If True, create blind-based shading objects (WindowMaterial:Blind + ShadingControl).
    create_geometry_shading : bool
        If True, create Shading:Building:Detailed geometry-based shading (e.g. overhangs).
        You can do both if your design includes both.
    """
    if random_seed is not None:
        random.seed(random_seed)

    # Example: If we want to add blinds to each "FENESTRATIONSURFACE:DETAILED" in the IDF
    if create_blinds:
        fen_surfaces = idf.idfobjects["FENESTRATIONSURFACE:DETAILED"]

        for fen in fen_surfaces:
            window_id = fen.Name

            # 1) Pick shading params (combines shading_lookup + user overrides)
            shading_params = pick_shading_params(
                window_id=window_id,
                shading_type_key=shading_type_key,
                strategy=strategy,
                user_config=user_config_shading,
                assigned_shading_log=assigned_shading_log,
            )

            # 2) Create a WindowMaterial:Blind object
            blind_mat = idf.newidfobject("WINDOWMATERIAL:BLIND")
            blind_mat.Name = shading_params["blind_name"] + f"_{window_id}"
            blind_mat.SlatOrientation = shading_params["slat_orientation"]
            blind_mat.SlatWidth = shading_params["slat_width"]
            blind_mat.SlatSeparation = shading_params["slat_separation"]
            blind_mat.SlatThickness = shading_params["slat_thickness"]
            blind_mat.SlatAngle = shading_params["slat_angle_deg"]
            blind_mat.SlatConductivity = shading_params["slat_conductivity"]
            # If your shading_lookup includes solar reflectances, IR emissivity, etc.:
            if "slat_beam_solar_transmittance" in shading_params:
                blind_mat.Slat_Beam_Solar_Transmittance = shading_params["slat_beam_solar_transmittance"]
            if "slat_beam_solar_reflectance" in shading_params:
                blind_mat.Slat_Beam_Solar_Reflectance = shading_params["slat_beam_solar_reflectance"]
            if "slat_diffuse_solar_transmittance" in shading_params:
                blind_mat.Slat_Diffuse_Solar_Transmittance = shading_params["slat_diffuse_solar_transmittance"]
            if "slat_diffuse_solar_reflectance" in shading_params:
                blind_mat.Slat_Diffuse_Solar_Reflectance = shading_params["slat_diffuse_solar_reflectance"]
            if "slat_beam_visible_transmittance" in shading_params:
                blind_mat.Slat_Beam_Visible_Transmittance = shading_params["slat_beam_visible_transmittance"]
            if "slat_beam_visible_reflectance" in shading_params:
                blind_mat.Slat_Beam_Visible_Reflectance = shading_params["slat_beam_visible_reflectance"]
            if "slat_diffuse_visible_transmittance" in shading_params:
                blind_mat.Slat_Diffuse_Visible_Transmittance = shading_params["slat_diffuse_visible_transmittance"]
            if "slat_diffuse_visible_reflectance" in shading_params:
                blind_mat.Slat_Diffuse_Visible_Reflectance = shading_params["slat_diffuse_visible_reflectance"]
            if "slat_ir_transmittance" in shading_params:
                blind_mat.Slat_IR_Transmittance = shading_params["slat_ir_transmittance"]
            if "slat_ir_emissivity" in shading_params:
                blind_mat.Slat_IR_Emissivity = shading_params["slat_ir_emissivity"]

            # 3) If dynamic shading => create or reference a schedule
            #    For example, if we want a schedule that changes slat angle or availability:
            #    We'll illustrate a simple static case here.
            shading_ctrl = idf.newidfobject("WINDOWPROPERTY:SHADINGCONTROL")
            shading_ctrl.Name = f"ShadingCtrl_{window_id}"
            shading_ctrl.Shading_Type = "Blind"
            shading_ctrl.Shading_Device_Material_Name = blind_mat.Name
            shading_ctrl.Type_of_Slats_Control = "FixedSlatAngle"
            shading_ctrl.Slat_Angle_Control_for_Fixed_Slat_Angle = shading_params["slat_angle_deg"]
            shading_ctrl.Shading_Control_Is_Scheduled = "No"
            shading_ctrl.Glare_Control_Is_Active = "No"

            # Link the shading control to this fenestration surface
            fen.Shading_Control_Name = shading_ctrl.Name

    # If you want geometry-based shading objects (overhangs, fins):
    # create them using "Shading:Building:Detailed":
    if create_geometry_shading:
        _create_overhang_example(idf, building_row, shading_type_key, strategy, user_config_shading)


def _create_overhang_example(idf, building_row, shading_type_key, strategy, user_config_shading):
    """
    Example function to demonstrate geometry-based shading (Shading:Building:Detailed).
    In real usage, you’d compute or retrieve the overhang geometry from building_row
    or shading_params. This is just a placeholder.
    """
    # Suppose we pick some shading params that define the overhang depth
    shading_params = pick_shading_params(
        window_id="Global_Overhang", 
        shading_type_key=shading_type_key,
        strategy=strategy,
        user_config=user_config_shading
    )

    # Let's say we read an "overhang_depth" from shading_params
    overhang_depth = shading_params.get("overhang_depth", 1.0)  # default 1m

    # Create a Shading:Building:Detailed object
    shading_obj = idf.newidfobject("SHADING:BUILDING:DETAILED")
    shading_obj.Name = "Overhang_North"
    shading_obj.Shading_Surface_Type = "Overhang"  # or "Fin" or just blank

    # Hard-coded example geometry (4 vertices):
    # This is purely illustrative. You’d typically compute X/Y based on
    # building_row geometry, window width, or orientation, etc.
    shading_obj.Number_of_Vertices = 4

    # Vertex 1
    shading_obj.Vertex_1_Xcoordinate = 0.0
    shading_obj.Vertex_1_Ycoordinate = 5.0
    shading_obj.Vertex_1_Zcoordinate = 3.0
    # Vertex 2
    shading_obj.Vertex_2_Xcoordinate = overhang_depth
    shading_obj.Vertex_2_Ycoordinate = 5.0
    shading_obj.Vertex_2_Zcoordinate = 3.0
    # Vertex 3
    shading_obj.Vertex_3_Xcoordinate = overhang_depth
    shading_obj.Vertex_3_Ycoordinate = 5.0
    shading_obj.Vertex_3_Zcoordinate = 2.8
    # Vertex 4
    shading_obj.Vertex_4_Xcoordinate = 0.0
    shading_obj.Vertex_4_Ycoordinate = 5.0
    shading_obj.Vertex_4_Zcoordinate = 2.8

    # If shading_params included “tilt_angle” or “width”, you could
    # incorporate them in the above coordinates.


def add_shading_schedule(idf, schedule_name="MyShadingSchedule"):
    """
    Example of how you might create a schedule for dynamic shading control.
    You can call this within add_shading_objects if you want a non-fixed schedule.
    """
    sched = idf.newidfobject("SCHEDULE:COMPACT")
    sched.Name = schedule_name
    sched.Schedule_Type_Limits_Name = "Fraction"
    # Simple example: always 1.0
    sched.Field_1 = "Through: 12/31"
    sched.Field_2 = "For: AllDays"
    sched.Field_3 = "Until: 24:00, 1.0"

    return sched

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\wshading\shading_lookup.py
============================================================
"""
shading_lookup.py

Contains default (hardcoded) shading parameters for different blind types, 
overhangs, louvers, etc. This is analogous to geometry_lookup.py or 
materials_lookup.py, storing dictionary-based defaults.

You can store various fields such as slat width, slat angle ranges, 
reflectances, etc. for each shading 'key' (e.g., "my_external_louvers").
"""

shading_lookup = {
    # Example: external louvers
    "my_external_louvers": {
        # This name will appear in EnergyPlus as the Blind material name
        "blind_name": "MyExternalLouvers",
        "slat_orientation": "Horizontal",
        "slat_width_range": (0.025, 0.025),
        "slat_separation_range": (0.02, 0.02),
        "slat_thickness_range": (0.001, 0.001),
        "slat_angle_deg_range": (45.0, 45.0),   # If you want a fixed 45°, keep min=max
        "slat_conductivity_range": (160.0, 160.0),
        
        # Solar trans/reflect properties (beam & diffuse):
        "slat_beam_solar_transmittance_range": (0.0, 0.0),
        "slat_beam_solar_reflectance_range": (0.2, 0.2),  # front/back same in this example
        "slat_diffuse_solar_transmittance_range": (0.0, 0.0),
        "slat_diffuse_solar_reflectance_range": (0.2, 0.2),
        
        # Visible trans/reflect properties (beam & diffuse):
        "slat_beam_visible_transmittance_range": (0.0, 0.0),
        "slat_beam_visible_reflectance_range": (0.5, 0.5),
        "slat_diffuse_visible_transmittance_range": (0.0, 0.0),
        "slat_diffuse_visible_reflectance_range": (0.5, 0.5),
        
        # IR / emissivity
        "slat_ir_transmittance_range": (0.0, 0.0),
        "slat_ir_emissivity_range": (0.9, 0.9),  # front/back same in this example
        
        # Blind geometry offsets
        "blind_to_glass_distance_range": (0.05, 0.05),
        "blind_opening_multiplier_top": (1.0, 1.0),
        "blind_opening_multiplier_bottom": (1.0, 1.0),
        "blind_opening_multiplier_left": (1.0, 1.0),
        "blind_opening_multiplier_right": (1.0, 1.0),
        
        # Slat angle limits
        "slat_angle_min_range": (0.0, 0.0),
        "slat_angle_max_range": (90.0, 90.0),
    },

    # Add more shading “types” here if needed, e.g.:
    # "my_vertical_fins": {...},
    # "my_overhang": {...},
}

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\wshading\shading_overrides_from_excel.py
============================================================
"""
shading_overrides_from_excel.py

If you want to read shading overrides from an Excel file (e.g., different 
blind angles per season, or custom user settings for certain building IDs), 
you can do that here.

Analogous to geometry_overrides_from_excel.py or dict_override_excel.py:
 - parse the Excel
 - store each row in a rules dictionary
 - 'pick_shading_params_from_rules' uses those rules to find 
   the best match for a building/window context
"""

import pandas as pd

def read_shading_overrides_excel(excel_path):
    """
    Reads an Excel file containing shading override rules.
    Example columns might be:
        building_id
        shading_type_key
        slat_angle_deg_min
        slat_angle_deg_max
        ...
    Returns a list of dict rules, each describing a row from the sheet.
    """
    df = pd.read_excel(excel_path)

    # We define a minimal required set of columns
    required_cols = ["building_id", "shading_type_key"]
    missing = [c for c in required_cols if c not in df.columns]
    if missing:
        raise ValueError(f"Missing columns in shading_overrides Excel: {missing}")

    override_rules = []
    for _, row in df.iterrows():
        # Build a single dictionary from the row
        rule = {}
        rule["building_id"] = str(row["building_id"]).strip()  # or int if you prefer
        rule["shading_type_key"] = str(row["shading_type_key"]).strip()
        
        # If present, read additional fields like slat_angle_deg_min/max
        if "slat_angle_deg_min" in df.columns and "slat_angle_deg_max" in df.columns:
            min_ang = row["slat_angle_deg_min"]
            max_ang = row["slat_angle_deg_max"]
            if pd.notna(min_ang) and pd.notna(max_ang):
                rule["slat_angle_deg_range"] = (float(min_ang), float(max_ang))
        
        # Similarly for other shading parameters
        # if "slat_width_min" in df.columns, etc.

        override_rules.append(rule)

    return override_rules


def pick_shading_params_from_rules(
    building_id,
    shading_type_key,
    all_rules,
    fallback=None
):
    """
    Look through the list of override_rules (from read_shading_overrides_excel) 
    to find a matching rule for this building_id and shading_type_key.
    Returns a dict of override fields or 'fallback' if none found.

    Example override dict might look like:
        {
          "slat_angle_deg_range": (30, 60),
          ...
        }
    """
    best_rule = None
    for rule in all_rules:
        # building_id must match
        if str(rule.get("building_id", "")).lower() != str(building_id).lower():
            continue
        # shading_type_key must match
        if str(rule.get("shading_type_key", "")).lower() != shading_type_key.lower():
            continue
        # If multiple matches, pick last match or define your logic
        best_rule = rule

    if best_rule is None:
        return fallback

    # remove top-level fields "building_id" and "shading_type_key"
    # the rest are actual overrides
    overrides = dict(best_rule)
    overrides.pop("building_id", None)
    overrides.pop("shading_type_key", None)

    return overrides

------------------------------------------------------------

