File: D:\Documents\E_Plus_2030_py\idf_objects\wshading\assign_shading_values.py
============================================================
"""
assign_shading_values.py

This module picks the final shading parameters from shading_lookup.py 
and optionally user overrides or Excel-based rules. The actual creation 
of EnergyPlus objects (e.g. WindowMaterial:Blind, Shading:Building:Detailed, etc.) 
will happen in another file (e.g. create_shading_objects.py).
"""

import random
from .shading_lookup import shading_lookup

def pick_val_from_range(rng_tuple, strategy="A"):
    """
    Helper function to pick a numeric value from (min_val, max_val).
    - If strategy="A", picks the midpoint.
    - If strategy="B", picks a random value in [min_val, max_val].
    - Otherwise, picks min_val.
    """
    if not rng_tuple or len(rng_tuple) < 2:
        return None
    min_val, max_val = rng_tuple
    if min_val is None or max_val is None:
        return min_val if min_val is not None else max_val  # fallback
    if min_val == max_val:
        return min_val  # no variability
    if strategy == "A":
        return 0.5 * (min_val + max_val)
    elif strategy == "B":
        return random.uniform(min_val, max_val)
    else:
        return min_val

def pick_shading_params(
    window_id,
    shading_type_key="my_external_louvers",
    strategy="A",
    user_config=None,
    assigned_shading_log=None
):
    """
    1) Looks up default shading parameters from shading_lookup[shading_type_key].
    2) If user_config is provided, override or adjust some values if needed.
    3) Based on 'strategy', pick final numeric values (midpoint or random) 
       from any ranges in these parameters.
    4) Optionally log the final picks in assigned_shading_log.

    Parameters
    ----------
    window_id : str
        An identifier for the window (optional, for logging).
    shading_type_key : str
        The key in shading_lookup to use, e.g. "my_external_louvers".
    strategy : str
        "A" => pick midpoint from ranges; "B" => pick random.
        Otherwise => pick min_val for everything.
    user_config : dict or None
        E.g. { "my_external_louvers": { "slat_angle_deg_range": (30, 60) } }
        to override certain ranges for all windows or certain IDs.
    assigned_shading_log : dict or None
        If provided, store final picks under assigned_shading_log[window_id].

    Returns
    -------
    dict
        A dictionary of final shading parameters, e.g.:
        {
          "blind_name": "MyExternalLouvers",
          "slat_orientation": "Horizontal",
          "slat_width": 0.025,
          ...
        }
    """
    # 1) Fetch base parameters from shading_lookup
    base_params = shading_lookup.get(shading_type_key, {})
    final_params = dict(base_params)  # shallow copy

    # 2) If user_config => update the base_params or override certain fields
    if user_config and shading_type_key in user_config:
        overrides_for_this_type = user_config[shading_type_key]
        for key, val in overrides_for_this_type.items():
            if key in final_params and isinstance(val, tuple) and len(val) == 2:
                # e.g. override "slat_angle_deg_range" => (30, 60)
                final_params[key] = val
            else:
                # you could also allow single fixed values or booleans
                final_params[key] = val

    # 3) Convert all "*_range" fields to single numeric picks
    #    e.g. final_params["slat_width_range"] => final_params["slat_width"]
    #    Then remove the old range key from final_params.
    fields_to_remove = []
    for field_key, field_val in final_params.items():
        if field_key.endswith("_range") and isinstance(field_val, tuple):
            param_name = field_key[:-6]  # remove "_range"
            chosen_val = pick_val_from_range(field_val, strategy=strategy)
            final_params[param_name] = chosen_val
            fields_to_remove.append(field_key)

    for ftr in fields_to_remove:
        del final_params[ftr]

    # 4) If assigned_shading_log is provided, store the final chosen values
    if assigned_shading_log is not None and window_id is not None:
        if window_id not in assigned_shading_log:
            assigned_shading_log[window_id] = {}
        assigned_shading_log[window_id]["shading_params"] = final_params

    return final_params

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\wshading\create_shading_objects.py
============================================================
"""
create_shading_objects.py

This module creates EnergyPlus shading objects in the IDF
(e.g., WindowMaterial:Blind, WindowProperty:ShadingControl,
 Shading:Building:Detailed, schedules, etc.).

It calls pick_shading_params(...) from assign_shading_values.py
to get final numeric parameter values. You can pass user/Excel overrides
to customize these parameters.

Usage:
  from idf_objects.wshading.create_shading_objects import add_shading_objects

  add_shading_objects(
      idf=idf,
      building_row=some_dict,
      shading_type_key="my_external_louvers",
      strategy="B",
      random_seed=42,
      user_config_shading=shading_dict,
      assigned_shading_log=shading_log_dict
  )
"""

import random
from .assign_shading_values import pick_shading_params
# from geomeppy import IDF  # or from eppy.bunch_subclass import EpBunch, if you prefer eppy

def add_shading_objects(
    idf,
    building_row,
    shading_type_key="my_external_louvers",
    strategy="A",
    random_seed=42,
    user_config_shading=None,
    assigned_shading_log=None,
    create_blinds=True,
    create_geometry_shading=False
):
    """
    Creates the necessary shading objects in the IDF: e.g. WindowMaterial:Blind,
    WindowProperty:ShadingControl, or geometry-based Shading:Building:Detailed.

    1) Loops over fenestration surfaces (or just once, depending on logic).
    2) Calls pick_shading_params(...) to get final numeric values (slat angles, etc.).
    3) Creates an EnergyPlus shading device (WindowMaterial:Blind + ShadingControl).
    4) Optionally, create an E+ schedule if dynamic shading is needed.
    5) Optionally, create Shading:Building:Detailed geometry if requested.

    Parameters
    ----------
    idf : IDF
        The IDF object where new objects will be added.
    building_row : dict or pandas.Series
        Row of building data, if needed to pick orientation/area, etc.
    shading_type_key : str
        Key in shading_lookup, e.g. "my_external_louvers".
    strategy : str
        "A" => pick midpoint from param ranges; "B" => pick random, etc.
    random_seed : int
        For reproducibility if strategy="B".
    user_config_shading : dict or None
        Shading overrides to pass to pick_shading_params(...).
        E.g. {
          "my_external_louvers": {
              "slat_angle_deg_range": (30, 60),
              ...
          }
        }
    assigned_shading_log : dict or None
        If provided, final shading params are stored under assigned_shading_log[window_id].
    create_blinds : bool
        If True, create blind-based shading objects (WindowMaterial:Blind + ShadingControl).
    create_geometry_shading : bool
        If True, create Shading:Building:Detailed geometry-based shading (e.g. overhangs).
        You can do both if your design includes both.
    """
    if random_seed is not None:
        random.seed(random_seed)

    # Example: If we want to add blinds to each "FENESTRATIONSURFACE:DETAILED" in the IDF
    if create_blinds:
        fen_surfaces = idf.idfobjects["FENESTRATIONSURFACE:DETAILED"]

        for fen in fen_surfaces:
            window_id = fen.Name

            # 1) Pick shading params (combines shading_lookup + user overrides)
            shading_params = pick_shading_params(
                window_id=window_id,
                shading_type_key=shading_type_key,
                strategy=strategy,
                user_config=user_config_shading,
                assigned_shading_log=assigned_shading_log,
            )

            # 2) Create a WindowMaterial:Blind object
            blind_mat = idf.newidfobject("WINDOWMATERIAL:BLIND")
            blind_mat.Name = shading_params["blind_name"] + f"_{window_id}"
            blind_mat.SlatOrientation = shading_params["slat_orientation"]
            blind_mat.SlatWidth = shading_params["slat_width"]
            blind_mat.SlatSeparation = shading_params["slat_separation"]
            blind_mat.SlatThickness = shading_params["slat_thickness"]
            blind_mat.SlatAngle = shading_params["slat_angle_deg"]
            blind_mat.SlatConductivity = shading_params["slat_conductivity"]
            # If your shading_lookup includes solar reflectances, IR emissivity, etc.:
            if "slat_beam_solar_transmittance" in shading_params:
                blind_mat.Slat_Beam_Solar_Transmittance = shading_params["slat_beam_solar_transmittance"]
            if "slat_beam_solar_reflectance" in shading_params:
                blind_mat.Slat_Beam_Solar_Reflectance = shading_params["slat_beam_solar_reflectance"]
            if "slat_diffuse_solar_transmittance" in shading_params:
                blind_mat.Slat_Diffuse_Solar_Transmittance = shading_params["slat_diffuse_solar_transmittance"]
            if "slat_diffuse_solar_reflectance" in shading_params:
                blind_mat.Slat_Diffuse_Solar_Reflectance = shading_params["slat_diffuse_solar_reflectance"]
            if "slat_beam_visible_transmittance" in shading_params:
                blind_mat.Slat_Beam_Visible_Transmittance = shading_params["slat_beam_visible_transmittance"]
            if "slat_beam_visible_reflectance" in shading_params:
                blind_mat.Slat_Beam_Visible_Reflectance = shading_params["slat_beam_visible_reflectance"]
            if "slat_diffuse_visible_transmittance" in shading_params:
                blind_mat.Slat_Diffuse_Visible_Transmittance = shading_params["slat_diffuse_visible_transmittance"]
            if "slat_diffuse_visible_reflectance" in shading_params:
                blind_mat.Slat_Diffuse_Visible_Reflectance = shading_params["slat_diffuse_visible_reflectance"]
            if "slat_ir_transmittance" in shading_params:
                blind_mat.Slat_IR_Transmittance = shading_params["slat_ir_transmittance"]
            if "slat_ir_emissivity" in shading_params:
                blind_mat.Slat_IR_Emissivity = shading_params["slat_ir_emissivity"]

            # 3) If dynamic shading => create or reference a schedule
            #    For example, if we want a schedule that changes slat angle or availability:
            #    We'll illustrate a simple static case here.
            shading_ctrl = idf.newidfobject("WINDOWPROPERTY:SHADINGCONTROL")
            shading_ctrl.Name = f"ShadingCtrl_{window_id}"
            shading_ctrl.Shading_Type = "Blind"
            shading_ctrl.Shading_Device_Material_Name = blind_mat.Name
            shading_ctrl.Type_of_Slats_Control = "FixedSlatAngle"
            shading_ctrl.Slat_Angle_Control_for_Fixed_Slat_Angle = shading_params["slat_angle_deg"]
            shading_ctrl.Shading_Control_Is_Scheduled = "No"
            shading_ctrl.Glare_Control_Is_Active = "No"

            # Link the shading control to this fenestration surface
            fen.Shading_Control_Name = shading_ctrl.Name

    # If you want geometry-based shading objects (overhangs, fins):
    # create them using "Shading:Building:Detailed":
    if create_geometry_shading:
        _create_overhang_example(idf, building_row, shading_type_key, strategy, user_config_shading)


def _create_overhang_example(idf, building_row, shading_type_key, strategy, user_config_shading):
    """
    Example function to demonstrate geometry-based shading (Shading:Building:Detailed).
    In real usage, you’d compute or retrieve the overhang geometry from building_row
    or shading_params. This is just a placeholder.
    """
    # Suppose we pick some shading params that define the overhang depth
    shading_params = pick_shading_params(
        window_id="Global_Overhang", 
        shading_type_key=shading_type_key,
        strategy=strategy,
        user_config=user_config_shading
    )

    # Let's say we read an "overhang_depth" from shading_params
    overhang_depth = shading_params.get("overhang_depth", 1.0)  # default 1m

    # Create a Shading:Building:Detailed object
    shading_obj = idf.newidfobject("SHADING:BUILDING:DETAILED")
    shading_obj.Name = "Overhang_North"
    shading_obj.Shading_Surface_Type = "Overhang"  # or "Fin" or just blank

    # Hard-coded example geometry (4 vertices):
    # This is purely illustrative. You’d typically compute X/Y based on
    # building_row geometry, window width, or orientation, etc.
    shading_obj.Number_of_Vertices = 4

    # Vertex 1
    shading_obj.Vertex_1_Xcoordinate = 0.0
    shading_obj.Vertex_1_Ycoordinate = 5.0
    shading_obj.Vertex_1_Zcoordinate = 3.0
    # Vertex 2
    shading_obj.Vertex_2_Xcoordinate = overhang_depth
    shading_obj.Vertex_2_Ycoordinate = 5.0
    shading_obj.Vertex_2_Zcoordinate = 3.0
    # Vertex 3
    shading_obj.Vertex_3_Xcoordinate = overhang_depth
    shading_obj.Vertex_3_Ycoordinate = 5.0
    shading_obj.Vertex_3_Zcoordinate = 2.8
    # Vertex 4
    shading_obj.Vertex_4_Xcoordinate = 0.0
    shading_obj.Vertex_4_Ycoordinate = 5.0
    shading_obj.Vertex_4_Zcoordinate = 2.8

    # If shading_params included “tilt_angle” or “width”, you could
    # incorporate them in the above coordinates.


def add_shading_schedule(idf, schedule_name="MyShadingSchedule"):
    """
    Example of how you might create a schedule for dynamic shading control.
    You can call this within add_shading_objects if you want a non-fixed schedule.
    """
    sched = idf.newidfobject("SCHEDULE:COMPACT")
    sched.Name = schedule_name
    sched.Schedule_Type_Limits_Name = "Fraction"
    # Simple example: always 1.0
    sched.Field_1 = "Through: 12/31"
    sched.Field_2 = "For: AllDays"
    sched.Field_3 = "Until: 24:00, 1.0"

    return sched

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\wshading\shading_lookup.py
============================================================
"""
shading_lookup.py

Contains default (hardcoded) shading parameters for different blind types, 
overhangs, louvers, etc. This is analogous to geometry_lookup.py or 
materials_lookup.py, storing dictionary-based defaults.

You can store various fields such as slat width, slat angle ranges, 
reflectances, etc. for each shading 'key' (e.g., "my_external_louvers").
"""

shading_lookup = {
    # Example: external louvers
    "my_external_louvers": {
        # This name will appear in EnergyPlus as the Blind material name
        "blind_name": "MyExternalLouvers",
        "slat_orientation": "Horizontal",
        "slat_width_range": (0.025, 0.025),
        "slat_separation_range": (0.02, 0.02),
        "slat_thickness_range": (0.001, 0.001),
        "slat_angle_deg_range": (45.0, 45.0),   # If you want a fixed 45°, keep min=max
        "slat_conductivity_range": (160.0, 160.0),
        
        # Solar trans/reflect properties (beam & diffuse):
        "slat_beam_solar_transmittance_range": (0.0, 0.0),
        "slat_beam_solar_reflectance_range": (0.2, 0.2),  # front/back same in this example
        "slat_diffuse_solar_transmittance_range": (0.0, 0.0),
        "slat_diffuse_solar_reflectance_range": (0.2, 0.2),
        
        # Visible trans/reflect properties (beam & diffuse):
        "slat_beam_visible_transmittance_range": (0.0, 0.0),
        "slat_beam_visible_reflectance_range": (0.5, 0.5),
        "slat_diffuse_visible_transmittance_range": (0.0, 0.0),
        "slat_diffuse_visible_reflectance_range": (0.5, 0.5),
        
        # IR / emissivity
        "slat_ir_transmittance_range": (0.0, 0.0),
        "slat_ir_emissivity_range": (0.9, 0.9),  # front/back same in this example
        
        # Blind geometry offsets
        "blind_to_glass_distance_range": (0.05, 0.05),
        "blind_opening_multiplier_top": (1.0, 1.0),
        "blind_opening_multiplier_bottom": (1.0, 1.0),
        "blind_opening_multiplier_left": (1.0, 1.0),
        "blind_opening_multiplier_right": (1.0, 1.0),
        
        # Slat angle limits
        "slat_angle_min_range": (0.0, 0.0),
        "slat_angle_max_range": (90.0, 90.0),
    },

    # Add more shading “types” here if needed, e.g.:
    # "my_vertical_fins": {...},
    # "my_overhang": {...},
}

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\wshading\shading_overrides_from_excel.py
============================================================
"""
shading_overrides_from_excel.py

If you want to read shading overrides from an Excel file (e.g., different 
blind angles per season, or custom user settings for certain building IDs), 
you can do that here.

Analogous to geometry_overrides_from_excel.py or dict_override_excel.py:
 - parse the Excel
 - store each row in a rules dictionary
 - 'pick_shading_params_from_rules' uses those rules to find 
   the best match for a building/window context
"""

import pandas as pd

def read_shading_overrides_excel(excel_path):
    """
    Reads an Excel file containing shading override rules.
    Example columns might be:
        building_id
        shading_type_key
        slat_angle_deg_min
        slat_angle_deg_max
        ...
    Returns a list of dict rules, each describing a row from the sheet.
    """
    df = pd.read_excel(excel_path)

    # We define a minimal required set of columns
    required_cols = ["building_id", "shading_type_key"]
    missing = [c for c in required_cols if c not in df.columns]
    if missing:
        raise ValueError(f"Missing columns in shading_overrides Excel: {missing}")

    override_rules = []
    for _, row in df.iterrows():
        # Build a single dictionary from the row
        rule = {}
        rule["building_id"] = str(row["building_id"]).strip()  # or int if you prefer
        rule["shading_type_key"] = str(row["shading_type_key"]).strip()
        
        # If present, read additional fields like slat_angle_deg_min/max
        if "slat_angle_deg_min" in df.columns and "slat_angle_deg_max" in df.columns:
            min_ang = row["slat_angle_deg_min"]
            max_ang = row["slat_angle_deg_max"]
            if pd.notna(min_ang) and pd.notna(max_ang):
                rule["slat_angle_deg_range"] = (float(min_ang), float(max_ang))
        
        # Similarly for other shading parameters
        # if "slat_width_min" in df.columns, etc.

        override_rules.append(rule)

    return override_rules


def pick_shading_params_from_rules(
    building_id,
    shading_type_key,
    all_rules,
    fallback=None
):
    """
    Look through the list of override_rules (from read_shading_overrides_excel) 
    to find a matching rule for this building_id and shading_type_key.
    Returns a dict of override fields or 'fallback' if none found.

    Example override dict might look like:
        {
          "slat_angle_deg_range": (30, 60),
          ...
        }
    """
    best_rule = None
    for rule in all_rules:
        # building_id must match
        if str(rule.get("building_id", "")).lower() != str(building_id).lower():
            continue
        # shading_type_key must match
        if str(rule.get("shading_type_key", "")).lower() != shading_type_key.lower():
            continue
        # If multiple matches, pick last match or define your logic
        best_rule = rule

    if best_rule is None:
        return fallback

    # remove top-level fields "building_id" and "shading_type_key"
    # the rest are actual overrides
    overrides = dict(best_rule)
    overrides.pop("building_id", None)
    overrides.pop("shading_type_key", None)

    return overrides

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_creation.py
============================================================
"""
idf_creation.py

Handles the creation of EnergyPlus IDF files for a list of buildings,
plus optional simulation runs and post-processing.

Key functionalities:
  1) create_idf_for_building(...) builds a single IDF using geomeppy,
     applying geometry, fenestration, HVAC, etc.
  2) create_idfs_for_all_buildings(...) loops over multiple buildings,
     then optionally runs simulations and merges results in one or more ways.

Updated to allow writing logs/results inside a specific job folder via logs_base_dir.
"""

import os
import logging
import pandas as pd

# geomeppy for IDF manipulation
from geomeppy import IDF

# --- Import your custom submodules ---
from idf_objects.geomz.building import create_building_with_roof_type
from idf_objects.fenez.fenestration import add_fenestration
from idf_objects.fenez.materials import (
    update_construction_materials,
    assign_constructions_to_surfaces
)
from idf_objects.Elec.lighting import add_lights_and_parasitics
from idf_objects.eequip.equipment import add_electric_equipment
from idf_objects.DHW.water_heater import add_dhw_to_idf
from idf_objects.HVAC.custom_hvac import add_HVAC_Ideal_to_all_zones
from idf_objects.ventilation.add_ventilation import add_ventilation_to_idf
from idf_objects.wshading.create_shading_objects import add_shading_objects
from idf_objects.setzone.add_outdoor_air_and_zone_sizing_to_all_zones import add_outdoor_air_and_zone_sizing_to_all_zones
from idf_objects.tempground.add_ground_temperatures import add_ground_temperatures
from idf_objects.other.zonelist import create_zonelist

# Output & simulation modules
from idf_objects.outputdef.assign_output_settings import assign_output_settings
from idf_objects.outputdef.add_output_definitions import add_output_definitions
from postproc.merge_results import merge_all_results
from epw.run_epw_sims import simulate_all

###############################################################################
# Global Default IDF Config
# (Override these via environment variables or main_config if needed.)
###############################################################################
idf_config = {
    "iddfile": "EnergyPlus/Energy+.idd",         # Default path to the IDD file
    "idf_file_path": "EnergyPlus/Minimal.idf",   # Default path to a minimal base IDF
    "output_dir": "output/output_IDFs"           # Default folder to save generated IDFs
}


def create_idf_for_building(
    building_row,
    building_index,
    scenario="scenario1",
    calibration_stage="pre_calibration",
    strategy="B",
    random_seed=42,
    # Geometry
    user_config_geom=None,
    assigned_geom_log=None,
    # Lighting
    user_config_lighting=None,
    assigned_lighting_log=None,
    # Electric equipment
    user_config_equipment=None,
    assigned_equip_log=None,
    # DHW
    user_config_dhw=None,
    assigned_dhw_log=None,
    # Fenestration
    res_data=None,
    nonres_data=None,
    assigned_fenez_log=None,
    # Window Shading
    user_config_shading=None,
    assigned_shading_log=None,
    # HVAC
    user_config_hvac=None,
    assigned_hvac_log=None,
    # Vent
    user_config_vent=None,
    assigned_vent_log=None,
    # Zone sizing
    assigned_setzone_log=None,
    # Ground temps
    assigned_groundtemp_log=None,
    # Output definitions
    output_definitions=None
):
    """
    Build an IDF for a single building, applying geometry, fenestration, window
    shading, lighting, HVAC, ventilation, zone sizing, ground temps, and user
    overrides.

    Returns
    -------
    out_path : str
        File path to the saved IDF.
    """
    # 1) Setup IDF from the minimal template
    IDF.setiddname(idf_config["iddfile"])
    idf = IDF(idf_config["idf_file_path"])

    # 2) Basic building object settings
    building_obj = idf.newidfobject("BUILDING")
    building_obj.Name = f"Sample_Building_{building_index}"

    orientation = building_row.get("building_orientation", 0.0)



    # for orientation correction this changed 
    #if not pd.isna(orientation):
    #    building_obj.North_Axis = orientation






    if pd.isna(orientation):
        orientation = 0.0

    # Apply orientation when creating geometry.  The BUILDING object's
    # North_Axis is kept at 0 so that the rotated geometry correctly
    # represents the building's orientation in the world coordinate system.
    building_obj.North_Axis = 0.0









    # 3) Create geometry
    if assigned_geom_log is not None and building_row.get("ogc_fid") not in assigned_geom_log:
        assigned_geom_log[building_row.get("ogc_fid")] = {}

    edge_types = []
    for side_col in ["north_side", "east_side", "south_side", "west_side"]:
        edge_types.append(building_row.get(side_col, "Facade"))

    create_building_with_roof_type(
        idf=idf,
        area=building_row.get("area", 100.0),
        perimeter=building_row.get("perimeter", 40.0),
        orientation=orientation,
        building_row=building_row,
        edge_types=edge_types,
        calibration_stage=calibration_stage,
        strategy=strategy,
        random_seed=random_seed,
        user_config=user_config_geom,
        assigned_geom_log=assigned_geom_log
    )

    # 4) Update materials & constructions
    construction_map = update_construction_materials(
        idf=idf,
        building_row=building_row,
        building_index=building_index,
        scenario=scenario,
        calibration_stage=calibration_stage,
        strategy=strategy,
        random_seed=random_seed,
        user_config_fenez=None,  # not used directly
        assigned_fenez_log=assigned_fenez_log
    )
    assign_constructions_to_surfaces(idf, construction_map)

    # Create zone list for convenience
    create_zonelist(idf, zonelist_name="ALL_ZONES")

    # 5) Fenestration
    add_fenestration(
        idf=idf,
        building_row=building_row,
        scenario=scenario,
        calibration_stage=calibration_stage,
        strategy=strategy,
        random_seed=random_seed,
        res_data=res_data,
        nonres_data=nonres_data,
        assigned_fenez_log=assigned_fenez_log
    )

    # 6) Window shading (e.g., blinds)
    add_shading_objects(
        idf=idf,
        building_row=building_row,
        strategy=strategy,
        random_seed=random_seed,
        user_config_shading=user_config_shading,
        assigned_shading_log=assigned_shading_log,
    )

    # 7) Lighting
    add_lights_and_parasitics(
        idf=idf,
        building_row=building_row,
        calibration_stage=calibration_stage,
        strategy=strategy,
        random_seed=random_seed,
        user_config=user_config_lighting,
        assigned_values_log=assigned_lighting_log
    )

    # 8) Electric equipment
    add_electric_equipment(
        idf=idf,
        building_row=building_row,
        calibration_stage=calibration_stage,
        strategy=strategy,
        random_seed=random_seed,
        user_config=user_config_equipment,
        assigned_values_log=assigned_equip_log,
        zonelist_name="ALL_ZONES",
    )
    # 9) DHW
    add_dhw_to_idf(
        idf=idf,
        building_row=building_row,
        calibration_stage=calibration_stage,
        strategy=strategy,
        random_seed=random_seed,
        name_suffix=f"MyDHW_{building_index}",
        user_config_dhw=user_config_dhw,
        assigned_dhw_log=assigned_dhw_log,
        use_nta=True
    )

    # 10) HVAC
    add_HVAC_Ideal_to_all_zones(
        idf=idf,
        building_row=building_row,
        calibration_stage=calibration_stage,
        strategy=strategy,
        random_seed=random_seed,
        user_config_hvac=user_config_hvac,
        assigned_hvac_log=assigned_hvac_log
    )

    # 11) Ventilation
    add_ventilation_to_idf(
        idf=idf,
        building_row=building_row,
        calibration_stage=calibration_stage,
        strategy=strategy,
        random_seed=random_seed,
        user_config_vent=user_config_vent,
        assigned_vent_log=assigned_vent_log,
        infiltration_model="weather",
    )

    # 12) Zone sizing
    add_outdoor_air_and_zone_sizing_to_all_zones(
        idf=idf,
        building_row=building_row,
        calibration_stage=calibration_stage,
        strategy=strategy,
        random_seed=random_seed,
        assigned_setzone_log=assigned_setzone_log
    )

    # 13) Ground temperatures
    add_ground_temperatures(
        idf=idf,
        calibration_stage=calibration_stage,
        strategy=strategy,
        random_seed=random_seed,
        assigned_groundtemp_log=assigned_groundtemp_log
    )

    # 14) Output definitions
    if output_definitions is None:
        output_definitions = {
            "desired_variables": ["Facility Total Electric Demand Power", "Zone Air Temperature"],
            "desired_meters": ["Electricity:Facility"],
            "override_variable_frequency": "Hourly",
            "override_meter_frequency": "Hourly",
            "include_tables": True,
            "include_summary": True
        }
    out_settings = assign_output_settings(
        desired_variables=output_definitions.get("desired_variables", []),
        desired_meters=output_definitions.get("desired_meters", []),
        override_variable_frequency=output_definitions.get("override_variable_frequency", "Hourly"),
        override_meter_frequency=output_definitions.get("override_meter_frequency", "Hourly"),
        include_tables=output_definitions.get("include_tables", True),
        include_summary=output_definitions.get("include_summary", True)
    )
    add_output_definitions(idf, out_settings)

    # 15) Save final IDF
    os.makedirs(idf_config["output_dir"], exist_ok=True)
    idf_filename = f"building_{building_index}.idf"
    out_path = os.path.join(idf_config["output_dir"], idf_filename)
    idf.save(out_path)
    print(f"[create_idf_for_building] IDF saved at: {out_path}")

    return out_path


def create_idfs_for_all_buildings(
    df_buildings,
    scenario="scenario1",
    calibration_stage="pre_calibration",
    strategy="B",
    random_seed=42,
    # partial user configs
    user_config_geom=None,
    user_config_lighting=None,
    user_config_equipment=None,
    user_config_dhw=None,
    res_data=None,
    nonres_data=None,
    user_config_shading=None,
    assigned_shading_log=None,
    user_config_hvac=None,
    user_config_vent=None,
    user_config_epw=None,  # pass epw config or list if relevant
    # output definitions
    output_definitions=None,
    # simulation & postprocess
    run_simulations=True,
    simulate_config=None,
    post_process=True,
    post_process_config=None,
    # NEW: Where to store logs and results
    logs_base_dir=None
):
    """
    Loops over df_buildings, calls create_idf_for_building for each building,
    optionally runs E+ simulations in parallel, and merges results if
    post_process=True. Window shading overrides can be passed via
    ``user_config_shading`` and logged to ``assigned_shading_log``.

    If logs_base_dir is provided, all assigned_*.csv and merged results go under that folder
    (e.g. logs_base_dir/assigned, logs_base_dir/Sim_Results, etc.).
    """
    logger = logging.getLogger(__name__)

    # A) Prepare dictionaries to store final picks for each module
    assigned_geom_log       = {}
    assigned_lighting_log   = {}
    assigned_equip_log      = {}
    assigned_dhw_log        = {}
    assigned_fenez_log      = {}
    assigned_hvac_log       = {}
    assigned_vent_log       = {}
    assigned_epw_log        = {}
    assigned_groundtemp_log = {}
    assigned_setzone_log    = {}
    assigned_shading_log    = {}

    # B) Create an IDF for each building
    for idx, row in df_buildings.iterrows():
        bldg_id = row.get("ogc_fid", idx)
        logger.info(f"--- Creating IDF for building index {idx}, ogc_fid={bldg_id} ---")

        idf_path = create_idf_for_building(
            building_row=row,
            building_index=idx,
            scenario=scenario,
            calibration_stage=calibration_stage,
            strategy=strategy,
            random_seed=random_seed,
            # geometry
            user_config_geom=user_config_geom,
            assigned_geom_log=assigned_geom_log,
            # lighting
            user_config_lighting=user_config_lighting,
            assigned_lighting_log=assigned_lighting_log,
            # electric equipment
            user_config_equipment=user_config_equipment,
            assigned_equip_log=assigned_equip_log,
            # DHW
            user_config_dhw=user_config_dhw,
            assigned_dhw_log=assigned_dhw_log,
            # Fenestration
            res_data=res_data,
            nonres_data=nonres_data,
            assigned_fenez_log=assigned_fenez_log,
            # Window shading
            user_config_shading=user_config_shading,
            assigned_shading_log=assigned_shading_log,
            # HVAC
            user_config_hvac=user_config_hvac,
            assigned_hvac_log=assigned_hvac_log,
            # Vent
            user_config_vent=user_config_vent,
            assigned_vent_log=assigned_vent_log,
            # zone sizing
            assigned_setzone_log=assigned_setzone_log,
            # ground temps
            assigned_groundtemp_log=assigned_groundtemp_log,
            # output definitions
            output_definitions=output_definitions
        )
        # Store the final IDF filename in df_buildings
        df_buildings.loc[idx, "idf_name"] = os.path.basename(idf_path)

    # C) If we’re told to run simulations
    if run_simulations:
        logger.info("[create_idfs_for_all_buildings] => Running simulations ...")
        if simulate_config is None:
            simulate_config = {}

        # Decide on a base_output_dir for sim results
        if logs_base_dir:
            sim_output_dir = os.path.join(logs_base_dir, "Sim_Results")
        else:
            sim_output_dir = simulate_config.get("base_output_dir", "output/Sim_Results")

        idf_directory = idf_config["output_dir"]
        iddfile       = idf_config["iddfile"]

        simulate_all(
            df_buildings=df_buildings,
            idf_directory=idf_directory,
            iddfile=iddfile,
            base_output_dir=sim_output_dir,
            user_config_epw=user_config_epw,
            assigned_epw_log=assigned_epw_log,
            num_workers=simulate_config.get("num_workers", 4)
            # ep_force_overwrite=simulate_config.get("ep_force_overwrite", False)
        )

    # D) Post-processing
    if post_process:
        logger.info("[create_idfs_for_all_buildings] => Post-processing results & writing logs ...")

        if post_process_config is None:
            post_process_config = {
                "base_output_dir": "output/Sim_Results",
                "outputs": [
                    {
                        "convert_to_daily": False,
                        "convert_to_monthly": False,
                        "aggregator": "none",
                        "output_csv": "output/results/merged_as_is.csv"
                    }
                ]
            }

        # If logs_base_dir is set, we override base_output_dir
        if logs_base_dir:
            post_process_config["base_output_dir"] = os.path.join(logs_base_dir, "Sim_Results")

        base_output_dir = post_process_config.get("base_output_dir", "output/Sim_Results")
        multiple_outputs = post_process_config.get("outputs", [])

        # Possibly handle multiple post-process outputs
        for proc_item in multiple_outputs:
            convert_daily = proc_item.get("convert_to_daily", False)
            convert_monthly = proc_item.get("convert_to_monthly", False)
            aggregator = proc_item.get("aggregator", "mean")  # daily aggregator
            out_csv = proc_item.get("output_csv", "output/results/merged_default.csv")

            # If logs_base_dir is set and the out_csv is still something like "output/results/..."
            # We can relocate it under logs_base_dir, e.g. logs_base_dir/results
            # Let's do a check:
            if logs_base_dir and "output/" in out_csv:
                # redirect to logs_base_dir
                # e.g. logs_base_dir/results/merged_default.csv
                # you can pick your subfolder naming
                rel_filename = out_csv.split("output/")[-1]  # e.g. results/merged_default.csv
                out_csv = os.path.join(logs_base_dir, rel_filename)

            # Make sure directory exists
            os.makedirs(os.path.dirname(out_csv), exist_ok=True)

            # Now merge the results
            merge_all_results(
                base_output_dir=base_output_dir,
                output_csv=out_csv,
                convert_to_daily=convert_daily,
                daily_aggregator=aggregator,
                convert_to_monthly=convert_monthly
            )

        # Write CSV logs for assigned parameters
        _write_geometry_csv(assigned_geom_log, logs_base_dir)
        _write_lighting_csv(assigned_lighting_log, logs_base_dir)
        _write_equipment_csv(assigned_equip_log, logs_base_dir)
        _write_fenestration_csv(assigned_fenez_log, logs_base_dir)
        _write_dhw_csv(assigned_dhw_log, logs_base_dir)
        _write_hvac_csv(assigned_hvac_log, logs_base_dir)
        _write_vent_csv(assigned_vent_log, logs_base_dir)
        _write_shading_csv(assigned_shading_log, logs_base_dir)
        # (If needed, also EPW or groundtemp logs, do similarly)

        logger.info("[create_idfs_for_all_buildings] => Done post-processing.")

    return df_buildings  # includes "idf_name" column


###############################################################################
# Internal Helper Functions to Write Assigned Logs
# -- Now accept logs_base_dir so we can place them in job_output_dir
###############################################################################
def _make_assigned_path(filename, logs_base_dir):
    """Helper to build the path for assigned_*.csv, given logs_base_dir."""
    if logs_base_dir:
        assigned_dir = os.path.join(logs_base_dir, "assigned")
    else:
        assigned_dir = "output/assigned"

    os.makedirs(assigned_dir, exist_ok=True)
    return os.path.join(assigned_dir, filename)


def _write_geometry_csv(assigned_geom_log, logs_base_dir):
    rows = []
    for bldg_id, param_dict in assigned_geom_log.items():
        for param_name, param_val in param_dict.items():
            rows.append({
                "ogc_fid": bldg_id,
                "param_name": param_name,
                "assigned_value": param_val
            })
    if not rows:
        return
    df = pd.DataFrame(rows)
    out_path = _make_assigned_path("assigned_geometry.csv", logs_base_dir)
    df.to_csv(out_path, index=False)


def _write_lighting_csv(assigned_lighting_log, logs_base_dir):
    rows = []
    for bldg_id, param_dict in assigned_lighting_log.items():
        for param_name, subdict in param_dict.items():
            assigned_val = subdict.get("assigned_value")
            min_v = subdict.get("min_val")
            max_v = subdict.get("max_val")
            obj_name = subdict.get("object_name", "")
            rows.append({
                "ogc_fid": bldg_id,
                "object_name": obj_name,
                "param_name": param_name,
                "assigned_value": assigned_val,
                "min_val": min_v,
                "max_val": max_v
            })
    if not rows:
        return
    df = pd.DataFrame(rows)
    out_path = _make_assigned_path("assigned_lighting.csv", logs_base_dir)
    df.to_csv(out_path, index=False)


def _write_fenestration_csv(assigned_fenez_log, logs_base_dir):
    rows = []
    for bldg_id, param_dict in assigned_fenez_log.items():
        for key, val in param_dict.items():
            rows.append({
                "ogc_fid": bldg_id,
                "param_name": key,
                "assigned_value": val
            })
    if not rows:
        return
    df = pd.DataFrame(rows)
    out_path = _make_assigned_path("assigned_fenez_params.csv", logs_base_dir)
    df.to_csv(out_path, index=False)


def _write_dhw_csv(assigned_dhw_log, logs_base_dir):
    rows = []
    for bldg_id, param_dict in assigned_dhw_log.items():
        for param_name, param_val in param_dict.items():
            rows.append({
                "ogc_fid": bldg_id,
                "param_name": param_name,
                "assigned_value": param_val
            })
    if not rows:
        return
    df = pd.DataFrame(rows)
    out_path = _make_assigned_path("assigned_dhw_params.csv", logs_base_dir)
    df.to_csv(out_path, index=False)


def _write_hvac_csv(assigned_hvac_log, logs_base_dir):
    rows = []
    for bldg_id, param_dict in assigned_hvac_log.items():
        for param_name, param_val in param_dict.items():
            rows.append({
                "ogc_fid": bldg_id,
                "param_name": param_name,
                "assigned_value": param_val
            })
    if not rows:
        return
    df = pd.DataFrame(rows)
    out_path = _make_assigned_path("assigned_hvac_params.csv", logs_base_dir)
    df.to_csv(out_path, index=False)


def _write_vent_csv(assigned_vent_log, logs_base_dir):
    rows = []
    for bldg_id, param_dict in assigned_vent_log.items():
        for param_name, param_val in param_dict.items():
            rows.append({
                "ogc_fid": bldg_id,
                "param_name": param_name,
                "assigned_value": param_val
            })
    if not rows:
        return
    df = pd.DataFrame(rows)
    out_path = _make_assigned_path("assigned_ventilation.csv", logs_base_dir)
    df.to_csv(out_path, index=False)


def _write_equipment_csv(assigned_equip_log, logs_base_dir):
    """Write ``assigned_equipment.csv`` in the same style as lighting.

    ``assigned_equip_log`` is produced by ``assign_equipment_parameters`` and
    stores a nested ``"assigned"`` dictionary for each building.  Each
    parameter entry contains ``object_name``, ``assigned_value``, ``min_val`` and
    ``max_val``.  We mirror ``_write_lighting_csv`` so that downstream scenario
    functions can expect the same columns.
    """

    rows = []
    for bldg_id, param_dict in assigned_equip_log.items():
        # Older logs might only contain the inner dict.  Default to that format
        assigned = param_dict.get("assigned", param_dict)
        for param_name, subdict in assigned.items():
            rows.append({
                "ogc_fid": bldg_id,
                "object_name": subdict.get("object_name", ""),
                "param_name": param_name,
                "assigned_value": subdict.get("assigned_value"),
                "min_val": subdict.get("min_val"),
                "max_val": subdict.get("max_val"),
            })
    if not rows:
        return
    df = pd.DataFrame(rows)
    out_path = _make_assigned_path("assigned_equipment.csv", logs_base_dir)
    df.to_csv(out_path, index=False)


def _write_shading_csv(assigned_shading_log, logs_base_dir):
    """Write ``assigned_shading_params.csv`` from ``assigned_shading_log``."""
    rows = []
    for window_id, param_dict in assigned_shading_log.items():
        shading_params = param_dict.get("shading_params", param_dict)
        for param_name, param_val in shading_params.items():
            rows.append({
                "window_id": window_id,
                "param_name": param_name,
                "assigned_value": param_val,
            })
    if not rows:
        return
    df = pd.DataFrame(rows)
    out_path = _make_assigned_path("assigned_shading_params.csv", logs_base_dir)
    df.to_csv(out_path, index=False)

------------------------------------------------------------

