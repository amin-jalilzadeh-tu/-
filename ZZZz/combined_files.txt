File: D:\Documents\E_Plus_2030_py\idf_objects\fenez\assign_fenestration_values.py
============================================================
"""
assign_fenestration_values.py

Provides a function to determine the final WWR (window-to-wall ratio)
for a given building, referencing a final fenestration dictionary
that already includes Excel + JSON overrides.

Usage Example:
    final_wwr, wwr_range_used = assign_fenestration_parameters(
        building_row=row,
        scenario="scenario1",
        calibration_stage="pre_calibration",
        strategy="B",
        random_seed=42,
        res_data=updated_res_data,
        nonres_data=updated_nonres_data,
        use_computed_wwr=False,
        include_doors_in_wwr=False
    )
"""

import random
from .materials_config import compute_wwr

def assign_fenestration_parameters(
    building_row,
    scenario="scenario1",
    calibration_stage="pre_calibration",
    strategy="B",
    random_seed=None,
    res_data=None,
    nonres_data=None,
    use_computed_wwr=False,
    include_doors_in_wwr=False
):
    """
    Determine the final WWR for this building. If use_computed_wwr=False,
    we look up a wwr_range from the final dictionaries and pick a value
    (randomly or midpoint, depending on 'strategy').

    If use_computed_wwr=True, we compute the ratio from sub-element areas
    (windows, doors if include_doors_in_wwr=True) vs. external_wall area.

    Parameters
    ----------
    building_row : dict or pandas.Series
        Must have building_function, age_range, possibly building_type, etc.
    scenario : str
        e.g. "scenario1"
    calibration_stage : str
        e.g. "pre_calibration"
    strategy : str
        "A" => pick midpoint from the wwr_range
        "B" => pick random uniform in the wwr_range
        ...
    random_seed : int
        For reproducible random picks if strategy="B".
    res_data, nonres_data : dict
        Final fenestration dictionaries that incorporate Excel & user JSON overrides.
        Each key in these dicts is (bldg_type, age_range, scenario, calibration_stage).
    use_computed_wwr : bool
        If True, compute WWR by summing sub-element areas (windows, doors if
        include_doors_in_wwr=True) vs. external_wall area from the data dicts.
    include_doors_in_wwr : bool
        If True, add door area to the fenestration area when computing WWR.

    Returns
    -------
    (final_wwr, wwr_range_used) : (float, tuple or None)
        The numeric WWR (0.0â€“1.0) and the range that was used (or None if computed).
    """
    if random_seed is not None:
        random.seed(random_seed)

    # A) Determine if building is residential or non_residential
    bldg_func = str(building_row.get("building_function", "residential")).lower()
    if bldg_func == "residential":
        fenez_dict = res_data
        bldg_type  = str(building_row.get("residential_type", "")).strip()
    else:
        fenez_dict = nonres_data
        bldg_type  = str(building_row.get("non_residential_type", "")).strip()

    age_range = str(building_row.get("age_range", "2015 and later"))
    scen = str(scenario)
    stage = str(calibration_stage)

    dict_key = (bldg_type, age_range, scen, stage)

    # B) If the user wants to compute WWR from sub-element areas
    if use_computed_wwr:
        # We can attempt to see if sub-element data exists in the dictionary,
        # or we can compute from the building_row if it has area columns.
        if not fenez_dict or dict_key not in fenez_dict:
            # fallback => compute from building_row if possible
            computed_val = compute_wwr_from_row(building_row, include_doors_in_wwr)
            return computed_val, None

        # If the dict_key is found, it might have an "elements" subdict
        entry = fenez_dict[dict_key]
        elements_subdict = entry.get("elements", {})
        final_wwr = compute_wwr(elements_subdict, include_doors=include_doors_in_wwr)
        return final_wwr, None

    # C) If not computing from sub-elements, then we pick from wwr_range
    if not fenez_dict or dict_key not in fenez_dict:
        # fallback => wwr=0.3, range=(0.3,0.3)
        return 0.30, (0.30, 0.30)

    entry = fenez_dict[dict_key]
    wwr_range = entry.get("wwr_range", (0.2, 0.3))

    min_v, max_v = wwr_range
    if min_v == max_v:
        final_wwr = min_v
    else:
        if strategy == "B":
            final_wwr = random.uniform(min_v, max_v)
        else:
            # strategy="A" => midpoint by default
            final_wwr = (min_v + max_v) / 2.0

    return final_wwr, wwr_range


def compute_wwr_from_row(building_row, include_doors_in_wwr=False):
    """
    Alternate fallback if you want to directly read building_row
    to compute the ratio of window_area / external_wall_area,
    including door_area if flagged.

    Returns a float WWR in [0,1].
    """
    # Example usage if your building_row has columns:
    # 'window_area_m2', 'exterior_wall_area_m2', 'door_area_m2'
    ext_wall_area = building_row.get("exterior_wall_area_m2", 100.0)
    if ext_wall_area <= 0:
        return 0.0

    window_area = building_row.get("window_area_m2", 0.0)
    if include_doors_in_wwr:
        door_area = building_row.get("door_area_m2", 0.0)
        window_area += door_area

    return window_area / ext_wall_area

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\fenez\fenestration.py
============================================================
"""
fenestration.py

Handles the creation or updating of fenestration (windows, etc.) in a geomeppy IDF.
It references final fenestration dictionaries (res_data, nonres_data) that
already incorporate Excel + user JSON overrides.

Key function: add_fenestration(...)
"""

import pandas as pd
from geomeppy import IDF as GeppyIDF
from .assign_fenestration_values import assign_fenestration_parameters


def add_fenestration(
    idf,
    building_row,
    scenario="scenario1",
    calibration_stage="pre_calibration",
    strategy="B",
    random_seed=None,
    res_data=None,
    nonres_data=None,
    assigned_fenez_log=None,
    use_computed_wwr=False,
    include_doors_in_wwr=False
):
    """
    Adds fenestration to the given IDF for the specified building_row.

    Steps:
      1) Determine building function => use 'res_data' or 'nonres_data'.
      2) Call 'assign_fenestration_parameters(...)' to get final WWR or computed WWR.
      3) Remove existing fenestration surfaces (FENESTRATIONSURFACE:DETAILED).
      4) Use geomeppy 'idf.set_wwr(...)' to add windows with the final WWR.
         By default, references a construction "Window1C" (ensure it exists in materials).
      5) Log picks & new fenestration object names in 'assigned_fenez_log' if provided.

    Parameters
    ----------
    idf : geomeppy.IDF
        The IDF to modify.
    building_row : dict or Series
        Contains building attributes like ogc_fid, building_function, age_range, orientation, etc.
    scenario, calibration_stage, strategy : str
        For passing to the assignment logic or logging.
    random_seed : int
        For reproducible random picks in the WWR range.
    res_data : dict
        Final fenestration dictionary for residential (Excel + user JSON merged).
    nonres_data : dict
        Final fenestration dictionary for non-res (Excel + user JSON merged).
    assigned_fenez_log : dict
        A place to store assigned picks for CSV logging later.
    use_computed_wwr : bool
        If True, compute WWR from sub-element areas (windows, doors, etc.)
        rather than from the dictionary's wwr_range.
    include_doors_in_wwr : bool
        If True, door area is counted as fenestration in the WWR ratio.
    """

    # 1) Determine final WWR (and WWR range used)
    wwr, wwr_range_used = assign_fenestration_parameters(
        building_row=building_row,
        scenario=scenario,
        calibration_stage=calibration_stage,
        strategy=strategy,
        random_seed=random_seed,
        res_data=res_data,
        nonres_data=nonres_data,
        use_computed_wwr=use_computed_wwr,
        include_doors_in_wwr=include_doors_in_wwr
    )

    # 2) Log final picks
    bldg_id = building_row.get("ogc_fid", None)
    if assigned_fenez_log and bldg_id is not None:
        if bldg_id not in assigned_fenez_log:
            assigned_fenez_log[bldg_id] = {}
        assigned_fenez_log[bldg_id]["fenez_final_wwr"] = wwr
        if wwr_range_used is not None:
            assigned_fenez_log[bldg_id]["fenez_wwr_range_used"] = wwr_range_used

    # 3) Remove existing fenestration surfaces
    fen_objects = idf.idfobjects["FENESTRATIONSURFACE:DETAILED"]
    del fen_objects[:]  # clear them all

    # 4) Use geomeppy to create new window surfaces for each exterior wall
    #    The default or fallback construction name is "Window1C".
    #    Make sure your updated materials/constructions code has created "Window1C" or a suitable name.
    GeppyIDF.set_wwr(idf, wwr=wwr, construction="Window1C")

    # 5) Optional: Log fenestration object names
    new_fens = idf.idfobjects["FENESTRATIONSURFACE:DETAILED"]
    if assigned_fenez_log and bldg_id is not None and new_fens:
        # store the new fenestration object names
        assigned_fenez_log[bldg_id]["fenez_fenestration_objects"] = [
            fen.Name for fen in new_fens
        ]

    print(f"[add_fenestration] Building: {bldg_id} => WWR={wwr:.3f}, used Window1C")

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\fenez\materials_config.py
============================================================
"""
fenez/materials_config.py

Contains logic for picking final material properties from ranges,
including references to material_lookup for different obj_types (MATERIAL,
MATERIAL:NOMASS, WINDOWMATERIAL:GLAZING, WINDOWMATERIAL:SIMPLEGLAZINGSYSTEM, etc.).

Key functions:
    - pick_val(...)
    - assign_material_from_lookup(...)
    - get_extended_materials_data(...)
    - compute_wwr(...)
"""

import random

# Update these imports to match your actual file locations:
from Lookups.data_materials_residential import residential_materials_data
from Lookups.data_materials_non_residential import non_residential_materials_data
from .materials_lookup import material_lookup


###############################################################################
#    pick_val(...) & assign_material_from_lookup(...) helper functions
###############################################################################

def pick_val(rng, strategy="A"):
    """
    Helper to pick a single float from a numeric range (min_val, max_val).
    If rng=(x,x), returns x.
    If strategy="A", picks the midpoint. If "B", picks random uniform.
    Otherwise, fallback to min_val.

    Parameters
    ----------
    rng : tuple of (float, float)
        (min_val, max_val).
    strategy : str
        "A" => midpoint, "B" => random uniform, etc.

    Returns
    -------
    A float in [min_val, max_val], or None if invalid.
    """
    if not rng or len(rng) < 2:
        return None
    min_val, max_val = rng
    if min_val is None and max_val is None:
        return None
    if min_val is not None and max_val is not None:
        if min_val == max_val:
            return min_val
        if strategy == "A":
            return (min_val + max_val) / 2.0
        elif strategy == "B":
            return random.uniform(min_val, max_val)
        else:
            # fallback => pick min
            return min_val
    # If one side is None, fallback to the other
    return min_val if min_val is not None else max_val


def assign_material_from_lookup(mat_def: dict, strategy="A"):
    """
    Takes a dict from material_lookup (which has fields like "Thickness_range",
    "Conductivity_range", etc.) and returns a *copy* with final numeric picks assigned.

    The function modifies keys like "Thickness", "Conductivity", "Thermal_Resistance",
    etc., based on the strategy for picking from each _range.

    Returns the updated dict.
    """
    final_mat = dict(mat_def)  # shallow copy to preserve original
    obj_type = final_mat["obj_type"].upper()

    # Some materials have thickness & conductivity ranges
    thick_rng = final_mat.get("Thickness_range", None)
    cond_rng  = final_mat.get("Conductivity_range", None)

    if obj_type == "MATERIAL":
        # Mass-based opaque
        final_mat["Thickness"] = pick_val(thick_rng, strategy)
        final_mat["Conductivity"] = pick_val(cond_rng, strategy)
        final_mat["Density"] = pick_val(final_mat.get("Density_range", (2300, 2300)), strategy)
        final_mat["Specific_Heat"] = pick_val(final_mat.get("Specific_Heat_range", (900, 900)), strategy)
        final_mat["Thermal_Absorptance"] = pick_val(final_mat.get("Thermal_Absorptance_range", (0.9, 0.9)), strategy)
        final_mat["Solar_Absorptance"]   = pick_val(final_mat.get("Solar_Absorptance_range", (0.7, 0.7)), strategy)
        final_mat["Visible_Absorptance"] = pick_val(final_mat.get("Visible_Absorptance_range", (0.7, 0.7)), strategy)

    elif obj_type == "MATERIAL:NOMASS":
        # No-mass => thermal_resistance
        r_rng = final_mat.get("Thermal_Resistance_range", None)
        final_mat["Thermal_Resistance"] = pick_val(r_rng, strategy)
        final_mat["Thermal_Absorptance"] = pick_val(final_mat.get("Thermal_Absorptance_range", (0.9, 0.9)), strategy)
        final_mat["Solar_Absorptance"]   = pick_val(final_mat.get("Solar_Absorptance_range", (0.7, 0.7)), strategy)
        final_mat["Visible_Absorptance"] = pick_val(final_mat.get("Visible_Absorptance_range", (0.7, 0.7)), strategy)

    elif obj_type == "WINDOWMATERIAL:GLAZING":
        # Typical single/multi-pane window material
        final_mat["Thickness"] = pick_val(thick_rng, strategy)
        final_mat["Solar_Transmittance"] = pick_val(
            final_mat.get("Solar_Transmittance_range", (0.76, 0.76)),
            strategy
        )
        final_mat["Front_Solar_Reflectance"] = pick_val(
            final_mat.get("Front_Solar_Reflectance_range", (0.07, 0.07)),
            strategy
        )
        final_mat["Back_Solar_Reflectance"]  = pick_val(
            final_mat.get("Back_Solar_Reflectance_range", (0.07, 0.07)),
            strategy
        )
        final_mat["Visible_Transmittance"]   = pick_val(
            final_mat.get("Visible_Transmittance_range", (0.86, 0.86)),
            strategy
        )
        final_mat["Front_Visible_Reflectance"] = pick_val(
            final_mat.get("Front_Visible_Reflectance_range", (0.06, 0.06)),
            strategy
        )
        final_mat["Back_Visible_Reflectance"]  = pick_val(
            final_mat.get("Back_Visible_Reflectance_range", (0.06, 0.06)),
            strategy
        )
        final_mat["Front_IR_Emissivity"]       = pick_val(
            final_mat.get("Front_IR_Emissivity_range", (0.84, 0.84)),
            strategy
        )
        final_mat["Back_IR_Emissivity"]        = pick_val(
            final_mat.get("Back_IR_Emissivity_range", (0.84, 0.84)),
            strategy
        )
        final_mat["Conductivity"]              = pick_val(cond_rng, strategy)
        final_mat["Dirt_Correction_Factor"]    = pick_val(
            final_mat.get("Dirt_Correction_Factor_range", (1.0, 1.0)),
            strategy
        )
        # IR_Transmittance often 0 => if stored, keep as is

    elif obj_type == "WINDOWMATERIAL:SIMPLEGLAZINGSYSTEM":
        # For simple glazing, you typically just set U-factor, SHGC, Visible Transmittance in E+.
        # We'll just pick from the provided ranges if present:
        final_mat["SHGC"] = pick_val(final_mat.get("SHGC_range", (0.40, 0.40)), strategy)
        # If "Optical_Data_Type" is stored as a numeric range for some reason, pick it:
        opt_dat = final_mat.get("Optical_Data_Type", None)
        # This might be a numeric or fixed string; handle gracefully:
        if isinstance(opt_dat, tuple) and len(opt_dat) == 2:
            final_mat["Optical_Data_Type"] = pick_val(opt_dat, strategy)
        else:
            # If it's a single string or float, just keep as is
            pass

        # You may also store a default U_value here if you keep a "U_value_range" in the dict

    else:
        # fallback - do nothing special
        pass

    return final_mat


###############################################################################
#    The main function to retrieve data & combine user overrides
###############################################################################

def compute_wwr(elements_dict, include_doors=False):
    """
    Compute WWR => (window area) / (exterior wall area).
    If include_doors=True, add door area to the fenestration area.
    """
    external_wall_area = 0.0
    if "exterior_wall" in elements_dict:
        external_wall_area += elements_dict["exterior_wall"].get("area_m2", 0.0)

    window_area = elements_dict.get("windows", {}).get("area_m2", 0.0)
    if include_doors and "doors" in elements_dict:
        window_area += elements_dict["doors"].get("area_m2", 0.0)

    if external_wall_area > 0:
        return window_area / external_wall_area
    else:
        return 0.0


def get_extended_materials_data(
    building_function: str,
    building_type: str,
    age_range: str,
    scenario: str,
    calibration_stage: str,
    strategy: str = "A",
    random_seed=None,
    user_config_fenez=None
):
    """
    1) Looks up either residential_materials_data or non_residential_materials_data
       by (building_type, age_range, scenario, calibration_stage).
    2) Retrieves "wwr_range" and picks a final 'wwr' if relevant.
    3) Grabs top-level 'material_opaque_lookup', 'material_window_lookup' if present.
    4) For each sub-element (e.g., ground_floor, windows, doors),
       picks R_value, U_value from (R_value_range, U_value_range).
    5) If user_config_fenez is provided, we override some fields (range or fixed).
    6) Return a dictionary with "wwr", "material_opaque", "material_window",
       plus "elements" sub-dicts for each sub-element with final picks.

    The final dict can then be used in materials.py to actually create IDF Materials/Constructions.
    """
    if random_seed is not None:
        random.seed(random_seed)

    # Pick which dataset to use
    if building_function.lower() == "residential":
        ds = residential_materials_data
    else:
        ds = non_residential_materials_data

    dict_key = (building_type, age_range, scenario, calibration_stage)
    if dict_key not in ds:
        # fallback if no data
        output_fallback = {
            "roughness": "MediumRough",
            "wwr": 0.3,
            "wwr_range_used": (0.3, 0.3),
            "material_opaque": None,
            "material_window": None,
            "elements": {}
        }
        # Possibly let user_config_fenez override wwr or wwr_range
        if user_config_fenez:
            if "wwr_range" in user_config_fenez:
                output_fallback["wwr_range_used"] = user_config_fenez["wwr_range"]
            if "wwr" in user_config_fenez:
                output_fallback["wwr"] = user_config_fenez["wwr"]
        return output_fallback

    data_entry = ds[dict_key]

    # 1) pick or override wwr_range
    default_wwr_range = data_entry.get("wwr_range", (0.3, 0.3))
    if user_config_fenez and "wwr_range" in user_config_fenez:
        default_wwr_range = user_config_fenez["wwr_range"]
    wwr_val = pick_val(default_wwr_range, strategy)

    # If user overrides wwr directly, apply it
    if user_config_fenez and "wwr" in user_config_fenez:
        wwr_val = user_config_fenez["wwr"]

    # 2) top-level roughness
    rough_str = data_entry.get("roughness", "MediumRough")

    # top-level materials
    mat_opq_key = data_entry.get("material_opaque_lookup", None)
    mat_win_key = data_entry.get("material_window_lookup", None)

    if user_config_fenez:
        if "material_opaque_lookup" in user_config_fenez:
            mat_opq_key = user_config_fenez["material_opaque_lookup"]
        if "material_window_lookup" in user_config_fenez:
            mat_win_key = user_config_fenez["material_window_lookup"]

    final_opq = None
    if mat_opq_key and mat_opq_key in material_lookup:
        final_opq = assign_material_from_lookup(material_lookup[mat_opq_key], strategy)

    final_win = None
    if mat_win_key and mat_win_key in material_lookup:
        final_win = assign_material_from_lookup(material_lookup[mat_win_key], strategy)

    # 3) sub-elements
    possible_elems = [
        "ground_floor", "exterior_wall", "flat_roof", "sloping_flat_roof",
        "inter_floor", "interior_wall", "windows", "doors"
    ]
    elements = {}
    for elem_name in possible_elems:
        if elem_name in data_entry:
            subd = dict(data_entry[elem_name])  # shallow copy

            # apply user overrides for sub-element if present
            if user_config_fenez and "elements" in user_config_fenez:
                user_elem_config = user_config_fenez["elements"].get(elem_name, {})
                if "R_value_range" in user_elem_config:
                    subd["R_value_range"] = user_elem_config["R_value_range"]
                if "U_value_range" in user_elem_config:
                    subd["U_value_range"] = user_elem_config["U_value_range"]
                if "area_m2" in user_elem_config:
                    subd["area_m2"] = user_elem_config["area_m2"]
                if "material_opaque_lookup" in user_elem_config:
                    subd["material_opaque_lookup"] = user_elem_config["material_opaque_lookup"]
                if "material_window_lookup" in user_elem_config:
                    subd["material_window_lookup"] = user_elem_config["material_window_lookup"]

            out_sub = dict(subd)

            # pick R_value / U_value
            r_val_rng = subd.get("R_value_range", None)
            u_val_rng = subd.get("U_value_range", None)
            r_val = pick_val(r_val_rng, strategy) if r_val_rng else None
            u_val = pick_val(u_val_rng, strategy) if u_val_rng else None

            # if user has a forced R_value / U_value
            if user_config_fenez and "elements" in user_config_fenez:
                user_elem_vals = user_config_fenez["elements"].get(elem_name, {})
                if "R_value" in user_elem_vals and user_elem_vals["R_value"] is not None:
                    r_val = user_elem_vals["R_value"]
                if "U_value" in user_elem_vals and user_elem_vals["U_value"] is not None:
                    u_val = user_elem_vals["U_value"]

            out_sub["R_value"] = r_val
            out_sub["U_value"] = u_val
            if r_val_rng:
                out_sub["R_value_range_used"] = r_val_rng
            if u_val_rng:
                out_sub["U_value_range_used"] = u_val_rng

            # sub-element material picks
            mat_opq_sub_key = subd.get("material_opaque_lookup", None)
            mat_win_sub_key = subd.get("material_window_lookup", None)

            if mat_opq_sub_key and mat_opq_sub_key in material_lookup:
                out_sub["material_opaque"] = assign_material_from_lookup(
                    material_lookup[mat_opq_sub_key],
                    strategy
                )
            else:
                out_sub["material_opaque"] = None

            if mat_win_sub_key and mat_win_sub_key in material_lookup:
                out_sub["material_window"] = assign_material_from_lookup(
                    material_lookup[mat_win_sub_key],
                    strategy
                )
            else:
                out_sub["material_window"] = None

            elements[elem_name] = out_sub

    # build final result
    result = {
        "roughness": rough_str,
        "wwr_range_used": default_wwr_range,
        "wwr": wwr_val,
        "material_opaque": final_opq,
        "material_window": final_win,
        "elements": elements
    }

    # 4) final step => if R_value or U_value is set, override the derived thickness/conductivity
    for elem_name, elem_data in result["elements"].items():
        r_val = elem_data.get("R_value", None)
        u_val = elem_data.get("U_value", None)
        if r_val is None and u_val is not None and u_val != 0:
            r_val = 1.0 / u_val

        mat_opq = elem_data.get("material_opaque", None)
        if mat_opq and r_val is not None:
            # re-derive Conductivity or Thermal_Resistance
            if mat_opq["obj_type"].upper() == "MATERIAL":
                thick = mat_opq["Thickness"]
                if r_val != 0:
                    mat_opq["Conductivity"] = thick / r_val
            elif mat_opq["obj_type"].upper() == "MATERIAL:NOMASS":
                mat_opq["Thermal_Resistance"] = r_val

        mat_win = elem_data.get("material_window", None)
        if mat_win and u_val is not None and u_val != 0:
            # For WINDOWMATERIAL:GLAZING, approximate conduction => U_value * thickness
            # For WINDOWMATERIAL:SIMPLEGLAZINGSYSTEM, you might set a 'U_value' field directly
            if mat_win["obj_type"].upper() == "WINDOWMATERIAL:GLAZING":
                thick = mat_win.get("Thickness", 0.003)
                mat_win["Conductivity"] = u_val * thick
            elif mat_win["obj_type"].upper() == "WINDOWMATERIAL:SIMPLEGLAZINGSYSTEM":
                # store a direct property
                mat_win["U_value"] = u_val

    return result

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\fenez\fenez_config_manager.py
============================================================
"""
fenez_config_manager.py

Manages the final fenestration configuration by merging:
 1) base dictionaries (res + nonres),
 2) Excel overrides (optional),
 3) user JSON overrides (optional).

Returns final dictionaries used in fenestration/material assignment.
"""

import copy
import pandas as pd

# Example of an Excel override import (if you use it):
# from idf_objects.fenez.dict_override_excel import override_dictionaries_from_excel


def build_fenez_config(
    base_res_data: dict,
    base_nonres_data: dict,
    excel_path: str = None,
    do_excel_override: bool = False,
    user_fenez_overrides=None
):
    """
    Builds the final fenestration configuration (residential & non-res)
    by merging:

      1) base_res_data, base_nonres_data (the "default" dictionaries).
      2) Excel overrides (if do_excel_override=True and excel_path provided).
      3) User overrides from fenestration.json (a list of override rules).

    Returns (final_res_data, final_nonres_data).

    Parameters
    ----------
    base_res_data : dict
        Your default dictionary for residential fenestration/materials.
    base_nonres_data : dict
        Your default dictionary for non-res fenestration/materials.
    excel_path : str
        Path to the Excel file with fenestration overrides (if any).
    do_excel_override : bool
        If True, apply the Excel overrides first (if excel_path is valid).
    user_fenez_overrides : list or None
        A list of overrides from fenestration.json, e.g.:
        [
          {
            "building_id": 4136730,
            "building_function": "residential",
            "age_range": "1992 - 2005",
            "scenario": "scenario1",
            "param_name": "wwr",
            "min_val": 0.25,
            "max_val": 0.30
          },
          ...
        ]
    """
    # 1) Copy the base dictionaries so we don't mutate originals
    final_res_data = copy.deepcopy(base_res_data)
    final_nonres_data = copy.deepcopy(base_nonres_data)

    # 2) If requested, apply Excel overrides (optional)
    if do_excel_override and excel_path and len(excel_path.strip()) > 0:
        # Uncomment/adjust if you implement 'override_dictionaries_from_excel'
        # final_res_data, final_nonres_data = override_dictionaries_from_excel(
        #     excel_path=excel_path,
        #     default_res_data=final_res_data,
        #     default_nonres_data=final_nonres_data,
        #     default_roughness="MediumRough",
        #     fallback_wwr_range=(0.2, 0.3)
        # )
        pass  # Remove this if you have the actual Excel override function

    # 3) Then apply user JSON overrides (if any)
    if user_fenez_overrides:
        final_res_data, final_nonres_data = apply_user_fenez_overrides(
            final_res_data,
            final_nonres_data,
            user_fenez_overrides
        )

    return final_res_data, final_nonres_data


def apply_user_fenez_overrides(final_res_data, final_nonres_data, user_fenez_list):
    """
    Applies user-defined overrides from fenestration.json to the in-memory dictionaries.

    Each item in `user_fenez_list` might look like:
      {
        "building_id": 4136730,
        "building_function": "residential",
        "age_range": "1992 - 2005",
        "scenario": "scenario1",
        "calibration_stage": "pre_calibration",  # optional
        "param_name": "wwr",
        "fixed_value": 0.28
      }
    or:
      {
        "building_function": "non_residential",
        "age_range": "2015 and later",
        "scenario": "scenario1",
        "param_name": "roof_r_value",
        "min_val": 3.0,
        "max_val": 3.5
      }

    We interpret 'param_name' to decide what to override: wwr, roof_r_value, etc.
    Then we set either a fixed_value or a (min_val, max_val) range in final_res_data/nonres_data.
    """
    for rule in user_fenez_list:
        bfunc   = str(rule.get("building_function", "")).lower()
        btype   = str(rule.get("building_type", ""))  # could also come from "residential_type"
        age_rng = str(rule.get("age_range", "2015 and later"))
        scen    = str(rule.get("scenario", "scenario1"))
        stage   = str(rule.get("calibration_stage", "pre_calibration"))
        p_name  = rule.get("param_name", "").lower()

        # Decide which dict to modify
        if bfunc == "residential":
            data_dict = final_res_data
        else:
            data_dict = final_nonres_data

        dict_key = (btype, age_rng, scen, stage)
        if dict_key not in data_dict:
            # If the combination doesn't exist, create an entry with some default
            data_dict[dict_key] = {
                "roughness": "MediumRough",
                "wwr_range": (0.2, 0.3),
                "elements": {}  # so we can store sub-element data if needed
            }

        # Extract override values
        fixed_val = rule.get("fixed_value")
        min_val   = rule.get("min_val")
        max_val   = rule.get("max_val")

        # Now interpret param_name
        if p_name == "wwr":
            # If there's a fixed_value, store range=(fixed_val, fixed_val).
            if fixed_val is not None:
                data_dict[dict_key]["wwr_range"] = (fixed_val, fixed_val)
            elif min_val is not None and max_val is not None:
                data_dict[dict_key]["wwr_range"] = (min_val, max_val)

        elif p_name == "roof_r_value":
            # For example, override the "flat_roof" -> "R_value_range"
            if "flat_roof" not in data_dict[dict_key]:
                data_dict[dict_key]["flat_roof"] = {}
            if fixed_val is not None:
                data_dict[dict_key]["flat_roof"]["R_value_range"] = (fixed_val, fixed_val)
            elif min_val is not None and max_val is not None:
                data_dict[dict_key]["flat_roof"]["R_value_range"] = (min_val, max_val)

        elif p_name == "wall_u_value":
            # Example override for "exterior_wall" -> "U_value_range"
            if "exterior_wall" not in data_dict[dict_key]:
                data_dict[dict_key]["exterior_wall"] = {}
            if fixed_val is not None:
                data_dict[dict_key]["exterior_wall"]["U_value_range"] = (fixed_val, fixed_val)
            elif min_val is not None and max_val is not None:
                data_dict[dict_key]["exterior_wall"]["U_value_range"] = (min_val, max_val)

        elif p_name == "door_u_value":
            if "doors" not in data_dict[dict_key]:
                data_dict[dict_key]["doors"] = {}
            if fixed_val is not None:
                data_dict[dict_key]["doors"]["U_value_range"] = (fixed_val, fixed_val)
            elif min_val is not None and max_val is not None:
                data_dict[dict_key]["doors"]["U_value_range"] = (min_val, max_val)

        # Add more param_names as needed for your use cases

        # If your override logic depends on building_id specifically, you might
        # store separate keys or treat it differently. Typically, overrides
        # go by (bldg_type, age_range, scenario, stage) unless you want per-bldg logic.

    return final_res_data, final_nonres_data

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\fenez\materials_lookup.py
============================================================
"""
Auto-generated materials_lookup.py
"""
"""
materials_lookup.py

Defines a dictionary 'material_lookup' where each key is a label like
"Concrete_200mm" or "Glazing_Clear_3mm". Each value is a dict containing:
  - obj_type (e.g. "MATERIAL", "MATERIAL:NOMASS", "WINDOWMATERIAL:GLAZING", etc.)
  - Name (the actual name in the IDF)
  - Roughness
  - Range-based fields like "Thickness_range", "Conductivity_range", etc.
  - Possibly optical properties for glazing, etc.
"""
material_lookup = {
    'Default_Material': {
        'obj_type': 'MATERIAL',
        'Name': 'Default_Material',
        'Description': 'Placeholder for generic opaque material',
        'Roughness': 'MediumRough',
        'Thickness_range': (0.099, 0.101),
        'Conductivity_range': (0.99, 1.01),
        'Density_range': (1782, 1818),
        'Specific_Heat_range': (832, 848),
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
    }, 
    'Concrete_200mm': {
        'obj_type': 'MATERIAL',
        'Name': 'Concrete_200mm',
        'Description': 'Standard 200 mm concrete wall',
        'Roughness': 'MediumRough',
        'Thickness_range': (0.195, 0.205),
        'Conductivity_range': (1.5, 1.7),
        'Density_range': (2250, 2350),
        'Specific_Heat_range': (850, 950),
        'Thermal_Absorptance_range': (0.9, 0.9),
        'Solar_Absorptance_range': (0.7, 0.7),
        'Visible_Absorptance_range': (0.7, 0.7),
    },
    'Brick_100mm': {
        'obj_type': 'MATERIAL',
        'Name': 'Brick_100mm',
        'Description': '100 mm common brick',
        'Roughness': 'MediumRough',
        'Thickness_range': (0.095, 0.105),
        'Conductivity_range': (0.6, 0.8),
        'Density_range': (1700, 1900),
        'Specific_Heat_range': (800, 900),
        'Thermal_Absorptance_range': (0.9, 0.9),
        'Solar_Absorptance_range': (0.7, 0.7),
        'Visible_Absorptance_range': (0.7, 0.7),
    },
    'Fiberglass_Insulation_100mm': {
        'obj_type': 'MATERIAL',
        'Name': 'Fiberglass_Insulation_100mm',
        'Description': '100 mm fiberglass batt insulation',
        'Roughness': 'MediumRough',
        'Thickness_range': (0.095, 0.105),
        'Conductivity_range': (0.04, 0.05),
        'Density_range': (12, 20),
        'Specific_Heat_range': (800, 900),
        'Thermal_Absorptance_range': (0.9, 0.9),
        'Solar_Absorptance_range': (0.5, 0.5),
        'Visible_Absorptance_range': (0.5, 0.5),
    },
    'Gypsum_Board_12mm': {
        'obj_type': 'MATERIAL',
        'Name': 'Gypsum_Board_12mm',
        'Description': '12 mm gypsum board',
        'Roughness': 'MediumSmooth',
        'Thickness_range': (0.0115, 0.0125),
        'Conductivity_range': (0.16, 0.18),
        'Density_range': (800, 950),
        'Specific_Heat_range': (1000, 1100),
        'Thermal_Absorptance_range': (0.9, 0.9),
        'Solar_Absorptance_range': (0.7, 0.7),
        'Visible_Absorptance_range': (0.7, 0.7),
    },






    'InteriorWall_Generic_R0.5': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'InteriorWall_Generic_R0.5',
        'Description': 'Generic Interior Wall R0.5',
        'Roughness': 'MediumSmooth',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.495, 0.505),
        'Visible_Absorptance_range': (0.495, 0.505),
        'Thermal_Resistance_range': (0.495, 0.505),
    },
    'InternalFloor_Generic_R1.0': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'InternalFloor_Generic_R1.0',
        'Description': 'Generic Internal Floor R1.0',
        'Roughness': 'MediumSmooth',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (0.99, 1.01),
    },
    'GroundFloor_R0.15': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'GroundFloor_R0.15',
        'Description': 'Ground Floor R0.15',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (0.148, 0.152),
    },
    'GroundFloor_R0.17': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'GroundFloor_R0.17',
        'Description': 'Ground Floor R0.17',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (0.168, 0.172),
    },
    'GroundFloor_R0.52': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'GroundFloor_R0.52',
        'Description': 'Ground Floor R0.52',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (0.515, 0.525),
    },
    'GroundFloor_R1.30': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'GroundFloor_R1.30',
        'Description': 'Ground Floor R1.30',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (1.287, 1.313),
    },
    'GroundFloor_R2.5': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'GroundFloor_R2.5',
        'Description': 'Ground Floor R2.5',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (2.475, 2.525),
    },
    'GroundFloor_R3.5': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'GroundFloor_R3.5',
        'Description': 'Ground Floor R3.5',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (3.465, 3.535),
    },
    'ExtWall_R0.19': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'ExtWall_R0.19',
        'Description': 'Exterior Wall R0.19',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (0.188, 0.192),
    },
    'ExtWall_R0.35': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'ExtWall_R0.35',
        'Description': 'Exterior Wall R0.35',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (0.347, 0.354),
    },
    'ExtWall_R0.43': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'ExtWall_R0.43',
        'Description': 'Exterior Wall R0.43',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (0.426, 0.434),
    },
    'ExtWall_R1.30': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'ExtWall_R1.30',
        'Description': 'Exterior Wall R1.30',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (1.287, 1.313),
    },
    'ExtWall_R1.7': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'ExtWall_R1.7',
        'Description': 'Exterior Wall R1.7',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (1.683, 1.717),
    },
    'ExtWall_R2.5': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'ExtWall_R2.5',
        'Description': 'Exterior Wall R2.5',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (2.475, 2.525),
    },
    'ExtWall_R4.5': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'ExtWall_R4.5',
        'Description': 'Exterior Wall R4.5',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (4.455, 4.545),
    },
    'Roof_R0.22': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'Roof_R0.22',
        'Description': 'Roof R0.22',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (0.218, 0.222),
    },
    'Roof_R0.25': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'Roof_R0.25',
        'Description': 'Roof R0.25',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (0.247, 0.253),
    },
    'Roof_R0.35': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'Roof_R0.35',
        'Description': 'Roof R0.35',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (0.347, 0.354),
    },
    'Roof_R0.43': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'Roof_R0.43',
        'Description': 'Roof R0.43',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (0.426, 0.434),
    },
    'Roof_R0.72': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'Roof_R0.72',
        'Description': 'Roof R0.72',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (0.713, 0.727),
    },
    'Roof_R0.86': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'Roof_R0.86',
        'Description': 'Roof R0.86',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (0.851, 0.869),
    },
    'Roof_R1.03': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'Roof_R1.03',
        'Description': 'Roof R1.03',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (1.02, 1.04),
    },
    'Roof_R1.30': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'Roof_R1.30',
        'Description': 'Roof R1.30',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (1.287, 1.313),
    },
    'Roof_R1.71': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'Roof_R1.71',
        'Description': 'Roof R1.71',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (1.693, 1.727),
    },
    'Roof_R2.5': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'Roof_R2.5',
        'Description': 'Roof R2.5',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (2.475, 2.525),
    },
    'Roof_R3.5': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'Roof_R3.5',
        'Description': 'Roof R3.5',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (3.465, 3.535),
    },
    'Roof_R6.0': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'Roof_R6.0',
        'Description': 'Roof R6.0',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (5.94, 6.06),
    },
    'Door_U3.4': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'Door_U3.4',
        'Description': 'Opaque Door, U=3.4 (R=0.29)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (0.287, 0.293),
    },
    'Door_U2.0': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'Door_U2.0',
        'Description': 'Opaque Door, U=2.0 (R=0.50)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (0.495, 0.505),
    },
    'Door_U1.4': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'Door_U1.4',
        'Description': 'Opaque Door, U=1.4 (R=0.71)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (0.703, 0.717),
    },
    'Window_U5.1': {
    'obj_type': 'WINDOWMATERIAL:SIMPLEGLAZINGSYSTEM',
    'Name': 'Window_U5.1',
    'Description': 'Window System U=5.1 (Single Clear?)',
    # U=5.1 W/m2K => store that as U_value_range
    'U_value_range': (5.049, 5.151),
    # SHGC ~0.80 => store as SHGC_range in [0,1]
    'SHGC_range': (0.792, 0.808),
},

'Window_U4.0': {
    'obj_type': 'WINDOWMATERIAL:SIMPLEGLAZINGSYSTEM',
    'Name': 'Window_U4.0',
    'Description': 'Window System U=4.0 (Single Clear?)',
    'U_value_range': (3.960, 4.040),
    'SHGC_range': (0.742, 0.758),
},

'Window_U2.9': {
    'obj_type': 'WINDOWMATERIAL:SIMPLEGLAZINGSYSTEM',
    'Name': 'Window_U2.9',
    'Description': 'Window System U=2.9 (Double Clear?)',
    'U_value_range': (2.871, 2.929),
    'SHGC_range': (0.693, 0.707),
},

'Window_U2.0': {
    'obj_type': 'WINDOWMATERIAL:SIMPLEGLAZINGSYSTEM',
    'Name': 'Window_U2.0',
    'Description': 'Window System U=2.0 (Double Low-e?)',
    'U_value_range': (1.980, 2.020),
    'SHGC_range': (0.594, 0.606),
},

'Window_U1.8': {
    'obj_type': 'WINDOWMATERIAL:SIMPLEGLAZINGSYSTEM',
    'Name': 'Window_U1.8',
    'Description': 'Window System U=1.8 (Double Low-e?)',
    'U_value_range': (1.782, 1.818),
    'SHGC_range': (0.544, 0.556),
},

'Window_U1.4': {
    'obj_type': 'WINDOWMATERIAL:SIMPLEGLAZINGSYSTEM',
    'Name': 'Window_U1.4',
    'Description': 'Window System U=1.4 (Triple Low-e?)',
    'U_value_range': (1.386, 1.414),
    'SHGC_range': (0.446, 0.455),
},

    'NR_InteriorWall_R0.5': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_InteriorWall_R0.5',
        'Description': 'NonRes Generic Interior Wall R0.5',
        'Roughness': 'MediumSmooth',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.495, 0.505),
        'Visible_Absorptance_range': (0.495, 0.505),
        'Thermal_Resistance_range': (0.495, 0.505),
    },
    'NR_InternalFloor_R1.0': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_InternalFloor_R1.0',
        'Description': 'NonRes Generic Internal Floor R1.0',
        'Roughness': 'MediumSmooth',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (0.99, 1.01),
    },
    'NR_GroundFloor_U2.8': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_GroundFloor_U2.8',
        'Description': 'NonRes Ground Floor U=2.8 (R=0.36)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (0.356, 0.364),
    },
    'NR_GroundFloor_U2.4': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_GroundFloor_U2.4',
        'Description': 'NonRes Ground Floor U=2.4 (R=0.42)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (0.416, 0.424),
    },
    'NR_GroundFloor_U1.8': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_GroundFloor_U1.8',
        'Description': 'NonRes Ground Floor U=1.8 (R=0.56)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (0.554, 0.566),
    },
    'NR_GroundFloor_U1.3': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_GroundFloor_U1.3',
        'Description': 'NonRes Ground Floor U=1.3 (R=0.77)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (0.762, 0.778),
    },
    'NR_GroundFloor_U0.9': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_GroundFloor_U0.9',
        'Description': 'NonRes Ground Floor U=0.9 (R=1.11)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (1.099, 1.121),
    },
    'NR_GroundFloor_U0.8': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_GroundFloor_U0.8',
        'Description': 'NonRes Ground Floor U=0.8 (R=1.25)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (1.237, 1.263),
    },
    'NR_GroundFloor_U0.5': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_GroundFloor_U0.5',
        'Description': 'NonRes Ground Floor U=0.5 (R=2.00)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (1.98, 2.02),
    },
    'NR_GroundFloor_U0.35': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_GroundFloor_U0.35',
        'Description': 'NonRes Ground Floor U=0.35 (R=2.86)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (2.831, 2.889),
    },
    'NR_GroundFloor_U0.3': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_GroundFloor_U0.3',
        'Description': 'NonRes Ground Floor U=0.3 (R=3.33)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (3.297, 3.363),
    },
    'NR_GroundFloor_U0.2': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_GroundFloor_U0.2',
        'Description': 'NonRes Ground Floor U=0.2 (R=5.00)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (4.95, 5.05),
    },
    'NR_ExtWall_U3.0': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_ExtWall_U3.0',
        'Description': 'NonRes Exterior Wall U=3.0 (R=0.33)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (0.327, 0.333),
    },
    'NR_ExtWall_U2.5': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_ExtWall_U2.5',
        'Description': 'NonRes Exterior Wall U=2.5 (R=0.40)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (0.396, 0.404),
    },
    'NR_ExtWall_U2.0': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_ExtWall_U2.0',
        'Description': 'NonRes Exterior Wall U=2.0 (R=0.50)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (0.495, 0.505),
    },
    'NR_ExtWall_U1.5': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_ExtWall_U1.5',
        'Description': 'NonRes Exterior Wall U=1.5 (R=0.67)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (0.663, 0.677),
    },
    'NR_ExtWall_U1.0': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_ExtWall_U1.0',
        'Description': 'NonRes Exterior Wall U=1.0 (R=1.00)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (0.99, 1.01),
    },
    'NR_ExtWall_U0.7': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_ExtWall_U0.7',
        'Description': 'NonRes Exterior Wall U=0.7 (R=1.43)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (1.416, 1.444),
    },
    'NR_ExtWall_U0.6': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_ExtWall_U0.6',
        'Description': 'NonRes Exterior Wall U=0.6 (R=1.67)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (1.653, 1.687),
    },
    'NR_ExtWall_U0.4': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_ExtWall_U0.4',
        'Description': 'NonRes Exterior Wall U=0.4 (R=2.50)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (2.475, 2.525),
    },
    'NR_ExtWall_U0.3': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_ExtWall_U0.3',
        'Description': 'NonRes Exterior Wall U=0.3 (R=3.33)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (3.297, 3.363),
    },
    'NR_ExtWall_U0.2': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_ExtWall_U0.2',
        'Description': 'NonRes Exterior Wall U=0.2 (R=5.00)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (4.95, 5.05),
    },
    'NR_Roof_U3.5': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_Roof_U3.5',
        'Description': 'NonRes Roof U=3.5 (R=0.29)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (0.287, 0.293),
    },
    'NR_Roof_U3.0': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_Roof_U3.0',
        'Description': 'NonRes Roof U=3.0 (R=0.33)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (0.327, 0.333),
    },
    'NR_Roof_U2.5': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_Roof_U2.5',
        'Description': 'NonRes Roof U=2.5 (R=0.40)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (0.396, 0.404),
    },
    'NR_Roof_U1.8': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_Roof_U1.8',
        'Description': 'NonRes Roof U=1.8 (R=0.56)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (0.554, 0.566),
    },
    'NR_Roof_U1.2': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_Roof_U1.2',
        'Description': 'NonRes Roof U=1.2 (R=0.83)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (0.822, 0.838),
    },
    'NR_Roof_U0.8': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_Roof_U0.8',
        'Description': 'NonRes Roof U=0.8 (R=1.25)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (1.237, 1.263),
    },
    'NR_Roof_U0.7': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_Roof_U0.7',
        'Description': 'NonRes Roof U=0.7 (R=1.43)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (1.416, 1.444),
    },
    'NR_Roof_U0.5': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_Roof_U0.5',
        'Description': 'NonRes Roof U=0.5 (R=2.00)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (1.98, 2.02),
    },
    'NR_Roof_U0.35': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_Roof_U0.35',
        'Description': 'NonRes Roof U=0.35 (R=2.86)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (2.831, 2.889),
    },
    'NR_Roof_U0.3': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_Roof_U0.3',
        'Description': 'NonRes Roof U=0.3 (R=3.33)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (3.297, 3.363),
    },
    'NR_Roof_U0.18': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_Roof_U0.18',
        'Description': 'NonRes Roof U=0.18 (R=5.56)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (5.504, 5.616),
    },
    'NR_Door_U4.0': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_Door_U4.0',
        'Description': 'NonRes Door U=4.0 (R=0.25)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (0.247, 0.253),
    },
    'NR_Door_U3.4': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_Door_U3.4',
        'Description': 'NonRes Door U=3.4 (R=0.29)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (0.287, 0.293),
    },
    'NR_Door_U2.8': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_Door_U2.8',
        'Description': 'NonRes Door U=2.8 (R=0.36)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (0.356, 0.364),
    },
    'NR_Door_U2.2': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_Door_U2.2',
        'Description': 'NonRes Door U=2.2 (R=0.45)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (0.446, 0.455),
    },
    'NR_Door_U1.8': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_Door_U1.8',
        'Description': 'NonRes Door U=1.8 (R=0.56)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (0.554, 0.566),
    },
    'NR_Door_U1.5': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_Door_U1.5',
        'Description': 'NonRes Door U=1.5 (R=0.67)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (0.663, 0.677),
    },
    'NR_Door_U1.2': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_Door_U1.2',
        'Description': 'NonRes Door U=1.2 (R=0.83)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (0.822, 0.838),
    },
    'NR_Door_U1.0': {
        'obj_type': 'MATERIAL:NOMASS',
        'Name': 'NR_Door_U1.0',
        'Description': 'NonRes Door U=1.0 (R=1.00)',
        'Roughness': 'MediumRough',
        'Thermal_Absorptance_range': (0.891, 0.909),
        'Solar_Absorptance_range': (0.693, 0.707),
        'Visible_Absorptance_range': (0.693, 0.707),
        'Thermal_Resistance_range': (0.99, 1.01),
    },
'NR_Window_U5.8_SHGC0.80': {
    'obj_type': 'WINDOWMATERIAL:SIMPLEGLAZINGSYSTEM',
    'Name': 'NR_Window_U5.8_SHGC0.80',
    'Description': 'NonRes Window U=5.8, SHGC=0.80',
    'U_value_range': (5.742, 5.858),
    'SHGC_range': (0.792, 0.808),
},

'NR_Window_U5.1_SHGC0.80': {
    'obj_type': 'WINDOWMATERIAL:SIMPLEGLAZINGSYSTEM',
    'Name': 'NR_Window_U5.1_SHGC0.80',
    'Description': 'NonRes Window U=5.1, SHGC=0.80',
    'U_value_range': (5.049, 5.151),
    'SHGC_range': (0.792, 0.808),
},

'NR_Window_U4.0_SHGC0.70': {
    'obj_type': 'WINDOWMATERIAL:SIMPLEGLAZINGSYSTEM',
    'Name': 'NR_Window_U4.0_SHGC0.70',
    'Description': 'NonRes Window U=4.0, SHGC=0.70',
    'U_value_range': (3.960, 4.040),
    'SHGC_range': (0.693, 0.707),
},

'NR_Window_U2.9_SHGC0.60': {
    'obj_type': 'WINDOWMATERIAL:SIMPLEGLAZINGSYSTEM',
    'Name': 'NR_Window_U2.9_SHGC0.60',
    'Description': 'NonRes Window U=2.9, SHGC=0.60',
    'U_value_range': (2.871, 2.929),
    'SHGC_range': (0.594, 0.606),
},

'NR_Window_U2.2_SHGC0.55': {
    'obj_type': 'WINDOWMATERIAL:SIMPLEGLAZINGSYSTEM',
    'Name': 'NR_Window_U2.2_SHGC0.55',
    'Description': 'NonRes Window U=2.2, SHGC=0.55',
    'U_value_range': (2.178, 2.222),
    'SHGC_range': (0.544, 0.556),
},

'NR_Window_U1.8_SHGC0.50': {
    'obj_type': 'WINDOWMATERIAL:SIMPLEGLAZINGSYSTEM',
    'Name': 'NR_Window_U1.8_SHGC0.50',
    'Description': 'NonRes Window U=1.8, SHGC=0.50',
    'U_value_range': (1.782, 1.818),
    'SHGC_range': (0.495, 0.505),
},

'NR_Window_U1.4_SHGC0.45': {
    'obj_type': 'WINDOWMATERIAL:SIMPLEGLAZINGSYSTEM',
    'Name': 'NR_Window_U1.4_SHGC0.45',
    'Description': 'NonRes Window U=1.4, SHGC=0.45',
    'U_value_range': (1.386, 1.414),
    'SHGC_range': (0.446, 0.455),
},

'NR_Window_U1.1_SHGC0.40': {
    'obj_type': 'WINDOWMATERIAL:SIMPLEGLAZINGSYSTEM',
    'Name': 'NR_Window_U1.1_SHGC0.40',
    'Description': 'NonRes Window U=1.1, SHGC=0.40',
    'U_value_range': (1.089, 1.111),
    'SHGC_range': (0.396, 0.404),
},

    'Glazing_Clear_3mm': {
        'obj_type': 'WINDOWMATERIAL:GLAZING',
        'Name': 'Glazing_Clear_3mm',
        'Thickness_range': (0.003, 0.003),
        'Conductivity_range': (0.95, 1.05),
        'Optical_Data_Type': 'SpectralAverage',
        'Solar_Transmittance_range': (0.76, 0.78),
        'Front_Solar_Reflectance_range': (0.07, 0.08),
        'Back_Solar_Reflectance_range': (0.07, 0.08),
        'Visible_Transmittance_range': (0.86, 0.88),
        'Front_Visible_Reflectance_range': (0.06, 0.07),
        'Back_Visible_Reflectance_range': (0.06, 0.07),
        'IR_Transmittance': 0,
        'Front_IR_Emissivity_range': (0.84, 0.84),
        'Back_IR_Emissivity_range': (0.84, 0.84),
        'Dirt_Correction_Factor_range': (1.0, 1.0),
        'Solar_Diffusing': 'No',
    }
}

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\fenez\materials.py
============================================================
"""
materials.py

This module handles:
 1) Creating new MATERIAL & CONSTRUCTION objects in the IDF
    (including window materials).
 2) Storing logs of the final picks (and ranges) in assigned_fenez_log
    for possible CSV or JSON output.
 3) Optionally reassigning surfaces to the newly created constructions.

Key functions:
  - update_construction_materials(...)
  - assign_constructions_to_surfaces(...)
"""

from geomeppy import IDF
from .materials_config import get_extended_materials_data

def _store_material_picks(assigned_fenez_log, building_id, label, mat_data):
    """
    A helper to store final material picks (and any range fields) in
    assigned_fenez_log[building_id].

    'label' might be "top_opq", "top_win", or "exterior_wall_opq", etc.

    We flatten the dict so each key becomes:
       f"fenez_{label}.{key}" => value

    Example:
      label == "top_opq"
      mat_data == {
         "obj_type": "MATERIAL",
         "Thickness": 0.2,
         "Thickness_range": (0.15, 0.25),
         ...
      }
      We store:
        assigned_fenez_log[building_id]["fenez_top_opq.obj_type"] = "MATERIAL"
        assigned_fenez_log[building_id]["fenez_top_opq.Thickness_range"] = (0.15, 0.25)
      etc.
    """
    if not mat_data or not assigned_fenez_log:
        return

    if building_id not in assigned_fenez_log:
        assigned_fenez_log[building_id] = {}

    for k, v in mat_data.items():
        assigned_fenez_log[building_id][f"fenez_{label}.{k}"] = v


def update_construction_materials(
    idf,
    building_row,
    building_index=None,
    scenario="scenario1",
    calibration_stage="pre_calibration",
    strategy="A",
    random_seed=None,
    user_config_fenez=None,
    assigned_fenez_log=None
):
    """
    1) Calls get_extended_materials_data(...) => returns a dict with final picks
       (including sub-element R/U and range fields, plus top-level materials).
    2) Removes all existing Materials & Constructions from the IDF (clean slate).
    3) Creates new Opaque & Window materials => including top-level fallback
       so geometry references remain valid.
    4) Creates distinct sub-element-based materials & constructions (e.g. "exterior_wall_Construction").
    5) Logs assigned final picks (and ranges) into assigned_fenez_log if provided.

    Returns
    -------
    construction_map : dict
        Maps sub-element name => construction name
        (e.g. {"exterior_wall": "exterior_wall_Construction", ...}).

    Notes
    -----
    - The newly created Constructions (CEILING1C, Ext_Walls1C, Window1C, etc.)
      can be referenced when you set surfaces or WWR. These fallback
      constructions now first look for element-specific materials before
      defaulting to the top-level material.
    - If you have many building surfaces, you'll typically call
      'assign_constructions_to_surfaces(...)' afterwards to match them properly.
    """

    # 1) Determine building_id for logging
    building_id = building_row.get("ogc_fid", None)
    if building_id is None:
        building_id = building_index

    # 2) Retrieve extended materials data (with overrides)
    data = get_extended_materials_data(
        building_function=building_row.get("building_function", "residential"),
        building_type=(
            building_row.get("residential_type", "")
            if building_row.get("building_function", "").lower() == "residential"
            else building_row.get("non_residential_type", "")
        ),
        age_range=building_row.get("age_range", "2015 and later"),
        scenario=scenario,
        calibration_stage=calibration_stage,
        strategy=strategy,
        random_seed=random_seed,
        user_config_fenez=user_config_fenez
    )

    mat_opq = data.get("material_opaque", None)
    mat_win = data.get("material_window", None)
    elements_data = data.get("elements", {})

    # 2b) If logging final picks + ranges, store them now
    if assigned_fenez_log is not None and building_id is not None:
        if building_id not in assigned_fenez_log:
            assigned_fenez_log[building_id] = {}
        # Log top-level data: "roughness", "wwr_range_used", "wwr", etc.
        for top_key in ["roughness", "wwr_range_used", "wwr"]:
            if top_key in data:
                assigned_fenez_log[building_id][f"fenez_{top_key}"] = data[top_key]

        # Also store the top-level opaque/window material details
        _store_material_picks(assigned_fenez_log, building_id, "top_opq", mat_opq)
        _store_material_picks(assigned_fenez_log, building_id, "top_win", mat_win)

        # For each sub-element, store final picks + ranges
        for elem_name, elem_data in elements_data.items():
            if "R_value" in elem_data:
                assigned_fenez_log[building_id][f"fenez_{elem_name}_R_value"] = elem_data["R_value"]
            if "R_value_range_used" in elem_data:
                assigned_fenez_log[building_id][f"fenez_{elem_name}_R_value_range_used"] = elem_data["R_value_range_used"]

            if "U_value" in elem_data:
                assigned_fenez_log[building_id][f"fenez_{elem_name}_U_value"] = elem_data["U_value"]
            if "U_value_range_used" in elem_data:
                assigned_fenez_log[building_id][f"fenez_{elem_name}_U_value_range_used"] = elem_data["U_value_range_used"]

            if "area_m2" in elem_data:
                assigned_fenez_log[building_id][f"fenez_{elem_name}_area_m2"] = elem_data["area_m2"]

            # Now store the sub-element's opaque & window material dict
            opq_sub = elem_data.get("material_opaque", None)
            win_sub = elem_data.get("material_window", None)
            _store_material_picks(assigned_fenez_log, building_id, f"{elem_name}_opq", opq_sub)
            _store_material_picks(assigned_fenez_log, building_id, f"{elem_name}_win", win_sub)

    # 3) Remove existing Materials & Constructions from the IDF
    for obj_type in [
        "MATERIAL",
        "MATERIAL:NOMASS",
        "WINDOWMATERIAL:GLAZING",
        "WINDOWMATERIAL:SIMPLEGLAZINGSYSTEM",
        "CONSTRUCTION"
    ]:
        for obj in idf.idfobjects[obj_type][:]:
            idf.removeidfobject(obj)

    def create_opaque_material(idf_obj, mat_data, mat_name):
        """
        Create a MATERIAL or MATERIAL:NOMASS in the IDF with the given name
        and properties from mat_data. Returns the new object's name or None.
        """
        if not mat_data or "obj_type" not in mat_data:
            return None

        mat_type = mat_data["obj_type"].upper()
        if mat_type == "MATERIAL":
            mat_obj = idf_obj.newidfobject("MATERIAL")
            mat_obj.Name = mat_name
            mat_obj.Roughness = mat_data.get("Roughness", "MediumRough")
            mat_obj.Thickness = mat_data.get("Thickness", 0.1)
            mat_obj.Conductivity = mat_data.get("Conductivity", 1.0)
            mat_obj.Density = mat_data.get("Density", 2000.0)
            mat_obj.Specific_Heat = mat_data.get("Specific_Heat", 900.0)
            mat_obj.Thermal_Absorptance = mat_data.get("Thermal_Absorptance", 0.9)
            mat_obj.Solar_Absorptance   = mat_data.get("Solar_Absorptance", 0.7)
            mat_obj.Visible_Absorptance = mat_data.get("Visible_Absorptance", 0.7)
            return mat_obj.Name

        elif mat_type == "MATERIAL:NOMASS":
            mat_obj = idf_obj.newidfobject("MATERIAL:NOMASS")
            mat_obj.Name = mat_name
            mat_obj.Roughness = mat_data.get("Roughness", "MediumRough")
            mat_obj.Thermal_Resistance = mat_data.get("Thermal_Resistance", 0.5)
            mat_obj.Thermal_Absorptance = mat_data.get("Thermal_Absorptance", 0.9)
            mat_obj.Solar_Absorptance   = mat_data.get("Solar_Absorptance", 0.7)
            mat_obj.Visible_Absorptance = mat_data.get("Visible_Absorptance", 0.7)
            return mat_obj.Name

        return None

    def create_window_material(idf_obj, mat_data, mat_name):
        """
        Create a window material (GLAZING or SIMPLEGLAZINGSYSTEM) with mat_data.
        Returns the new object's name or None.
        """
        if not mat_data or "obj_type" not in mat_data:
            return None

        wtype = mat_data["obj_type"].upper()
        if wtype == "WINDOWMATERIAL:GLAZING":
            wmat = idf_obj.newidfobject("WINDOWMATERIAL:GLAZING")
            wmat.Name = mat_name
            wmat.Optical_Data_Type = mat_data.get("Optical_Data_Type", "SpectralAverage")
            wmat.Thickness = mat_data.get("Thickness", 0.003)
            wmat.Solar_Transmittance_at_Normal_Incidence = mat_data.get("Solar_Transmittance", 0.77)
            wmat.Front_Side_Solar_Reflectance_at_Normal_Incidence = mat_data.get("Front_Solar_Reflectance", 0.07)
            wmat.Back_Side_Solar_Reflectance_at_Normal_Incidence  = mat_data.get("Back_Solar_Reflectance", 0.07)
            wmat.Visible_Transmittance_at_Normal_Incidence        = mat_data.get("Visible_Transmittance", 0.86)
            wmat.Front_Side_Visible_Reflectance_at_Normal_Incidence = mat_data.get("Front_Visible_Reflectance", 0.07)
            wmat.Back_Side_Visible_Reflectance_at_Normal_Incidence  = mat_data.get("Back_Visible_Reflectance", 0.07)
            wmat.Infrared_Transmittance_at_Normal_Incidence         = mat_data.get("IR_Transmittance", 0.0)
            wmat.Front_Side_Infrared_Hemispherical_Emissivity       = mat_data.get("Front_IR_Emissivity", 0.84)
            wmat.Back_Side_Infrared_Hemispherical_Emissivity        = mat_data.get("Back_IR_Emissivity", 0.84)
            wmat.Conductivity = mat_data.get("Conductivity", 1.0)
            wmat.Dirt_Correction_Factor_for_Solar_and_Visible_Transmittance = mat_data.get("Dirt_Correction_Factor", 1.0)
            wmat.Solar_Diffusing = mat_data.get("Solar_Diffusing", "No")
            return wmat.Name

        elif wtype == "WINDOWMATERIAL:SIMPLEGLAZINGSYSTEM":
            wmat = idf_obj.newidfobject("WINDOWMATERIAL:SIMPLEGLAZINGSYSTEM")
            wmat.Name = mat_name
            # If your code includes a derived U_value or SHGC, set them here:
            u_val  = mat_data.get("U_value", 2.9)
            shgc   = mat_data.get("SHGC", 0.6)
            vt     = mat_data.get("Visible_Transmittance", 0.7)  # if you store one
            wmat.UFactor = u_val
            wmat.Solar_Heat_Gain_Coefficient = shgc
            wmat.Visible_Transmittance = vt
            # The built-in "Optical_Data_Type" field doesn't exist for SimpleGlazing in E+
            # so we ignore mat_data["Optical_Data_Type"] here (or store it in a custom field if needed).
            return wmat.Name

        return None

    # 4) Create top-level fallback Materials & Constructions
    opq_name = None
    if mat_opq:
        opq_name = create_opaque_material(idf, mat_opq, mat_opq["Name"])
        if assigned_fenez_log and building_id is not None and opq_name:
            assigned_fenez_log[building_id]["fenez_top_opaque_material_name"] = opq_name

    win_name = None
    if mat_win:
        win_name = create_window_material(idf, mat_win, mat_win["Name"])
        if assigned_fenez_log and building_id is not None and win_name:
            assigned_fenez_log[building_id]["fenez_top_window_material_name"] = win_name

    
    # Create fallback Constructions (CEILING1C, Ext_Walls1C, etc.).
    # These now mirror the per-element lookups. Each construction uses the
    # element-specific material when available, otherwise it falls back to the
    # top-level opaque material. Avoid creating duplicate materials by caching
    # any new opaque layers we add here.

    created_layers = {}

    def _layer_for_fallback(elem_key):
        mat = elements_data.get(elem_key, {}).get("material_opaque")
        if not mat:
            return opq_name

        name = mat.get("Name", f"{elem_key}_Mat")
        if name not in created_layers:
            created_layers[name] = create_opaque_material(idf, mat, name)
        return created_layers[name]

    ceil_layer = _layer_for_fallback("flat_roof")
    ext_layer = _layer_for_fallback("exterior_wall")
    intw_layer = _layer_for_fallback("interior_wall")
    roof_layer = _layer_for_fallback("flat_roof")
    grnd_layer = _layer_for_fallback("ground_floor")
    ifloor_layer = _layer_for_fallback("inter_floor")

    if any([ceil_layer, ext_layer, intw_layer, roof_layer, grnd_layer, ifloor_layer]):
        if ceil_layer:
            c_ceil = idf.newidfobject("CONSTRUCTION")
            c_ceil.Name = "CEILING1C"
            c_ceil.Outside_Layer = ceil_layer

        if ext_layer:
            c_ext = idf.newidfobject("CONSTRUCTION")
            c_ext.Name = "Ext_Walls1C"
            c_ext.Outside_Layer = ext_layer

        if intw_layer:
            c_intw = idf.newidfobject("CONSTRUCTION")
            c_intw.Name = "Int_Walls1C"
            c_intw.Outside_Layer = intw_layer

        if roof_layer:
            c_roof = idf.newidfobject("CONSTRUCTION")
            c_roof.Name = "Roof1C"
            c_roof.Outside_Layer = roof_layer

        if grnd_layer:
            c_grnd = idf.newidfobject("CONSTRUCTION")
            c_grnd.Name = "GroundFloor1C"
            c_grnd.Outside_Layer = grnd_layer

        if ifloor_layer:
            c_ifloor = idf.newidfobject("CONSTRUCTION")
            c_ifloor.Name = "IntFloor1C"
            c_ifloor.Outside_Layer = ifloor_layer


    if win_name:
        c_win = idf.newidfobject("CONSTRUCTION")
        c_win.Name = "Window1C"
        c_win.Outside_Layer = win_name

        if assigned_fenez_log and building_id is not None:
            assigned_fenez_log[building_id]["fenez_window1C_construction"] = c_win.Name

    # 5) Create sub-element-based Materials & Constructions
    construction_map = {}
    for elem_name, elem_data in elements_data.items():
        mat_opq_sub = elem_data.get("material_opaque", None)
        mat_win_sub = elem_data.get("material_window", None)

        opq_sub_name = None
        win_sub_name = None

        # create opaque
        if mat_opq_sub:
            sub_opq_name = f"{elem_name}_OpaqueMat"
            opq_sub_name = create_opaque_material(idf, mat_opq_sub, sub_opq_name)
            if assigned_fenez_log and building_id is not None and opq_sub_name:
                assigned_fenez_log[building_id][f"fenez_{elem_name}_opq_material_name"] = opq_sub_name

        # create window
        if mat_win_sub:
            sub_win_name = f"{elem_name}_WindowMat"
            win_sub_name = create_window_material(idf, mat_win_sub, sub_win_name)
            if assigned_fenez_log and building_id is not None and win_sub_name:
                assigned_fenez_log[building_id][f"fenez_{elem_name}_win_material_name"] = win_sub_name

        # create new Opaque Construction
        if opq_sub_name:
            c_sub = idf.newidfobject("CONSTRUCTION")
            c_sub.Name = f"{elem_name}_Construction"
            c_sub.Outside_Layer = opq_sub_name
            construction_map[elem_name] = c_sub.Name

            if assigned_fenez_log and building_id is not None:
                assigned_fenez_log[building_id][f"fenez_{elem_name}_construction_name"] = c_sub.Name

        # Optionally: create a separate window construction
        if win_sub_name:
            c_sub_win = idf.newidfobject("CONSTRUCTION")
            c_sub_win.Name = f"{elem_name}_WindowConst"
            c_sub_win.Outside_Layer = win_sub_name
            construction_map[f"{elem_name}_window"] = c_sub_win.Name

            if assigned_fenez_log and building_id is not None:
                assigned_fenez_log[building_id][f"fenez_{elem_name}_window_construction_name"] = c_sub_win.Name

    print("[update_construction_materials] => Created fallback top-level constructions (CEILING1C, etc.).")
    print("[update_construction_materials] => Created sub-element-based constructions:")
    for k, v in construction_map.items():
        print(f"   {k} => {v}")

    return construction_map


def assign_constructions_to_surfaces(idf, construction_map):
    """
    Assign each BUILDINGSURFACE:DETAILED to a suitable construction name
    based on sub-element keys, surface type, boundary condition, etc.

    construction_map: e.g.
      {
        "exterior_wall": "exterior_wall_Construction",
        "exterior_wall_window": "exterior_wall_WindowConst",
        "ground_floor": "ground_floor_Construction",
        ...
      }

    Typically, you'll call this after update_construction_materials(...).

    Example usage:
        c_map = update_construction_materials(...)
        assign_constructions_to_surfaces(idf, c_map)
    """
    for surface in idf.idfobjects["BUILDINGSURFACE:DETAILED"]:
        s_type = surface.Surface_Type.upper()
        bc = surface.Outside_Boundary_Condition.upper()

        if s_type == "WALL":
            if bc == "OUTDOORS":
                if "exterior_wall" in construction_map:
                    surface.Construction_Name = construction_map["exterior_wall"]
                else:
                    surface.Construction_Name = "Ext_Walls1C"
            elif bc in ["SURFACE", "ADIABATIC"]:
                if "interior_wall" in construction_map:
                    surface.Construction_Name = construction_map["interior_wall"]
                else:
                    surface.Construction_Name = "Int_Walls1C"
            else:
                # fallback
                surface.Construction_Name = "Ext_Walls1C"

        elif s_type in ["ROOF", "CEILING"]:
            if bc == "OUTDOORS":
                # could match "flat_roof" if it exists
                if "flat_roof" in construction_map:
                    surface.Construction_Name = construction_map["flat_roof"]
                else:
                    surface.Construction_Name = "Roof1C"
            elif bc in ["ADIABATIC", "SURFACE"]:
                if "inter_floor" in construction_map:
                    surface.Construction_Name = construction_map["inter_floor"]
                else:
                    surface.Construction_Name = "IntFloor1C"
            else:
                # fallback
                surface.Construction_Name = "Roof1C"

        elif s_type == "FLOOR":
            if bc == "GROUND":
                if "ground_floor" in construction_map:
                    surface.Construction_Name = construction_map["ground_floor"]
                else:
                    surface.Construction_Name = "GroundFloor1C"
            elif bc in ["SURFACE", "ADIABATIC"]:
                if "inter_floor" in construction_map:
                    surface.Construction_Name = construction_map["inter_floor"]
                else:
                    surface.Construction_Name = "IntFloor1C"
            else:
                # fallback
                surface.Construction_Name = "GroundFloor1C"

        else:
            # fallback
            surface.Construction_Name = "Ext_Walls1C"

    # Now fenestrations
    for fen in idf.idfobjects["FENESTRATIONSURFACE:DETAILED"]:
        # If there's a sub-element key "windows" or "exterior_wall_window"
        # in the construction_map, assign it. Otherwise fallback to "Window1C".
        if "windows" in construction_map:
            fen.Construction_Name = construction_map["windows"]
        else:
            fen.Construction_Name = "Window1C"

    print("[assign_constructions_to_surfaces] => Surfaces assigned via sub-element logic.")

------------------------------------------------------------

