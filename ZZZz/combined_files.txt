File: D:\Documents\E_Plus_2030_py\idf_objects\wshading\assign_shading_values.py
============================================================
"""
assign_shading_values.py

This module picks the final shading parameters from shading_lookup.py
and optionally user overrides or Excel-based rules. The actual creation
of EnergyPlus objects (e.g. WindowMaterial:Blind, Shading:Building:Detailed, etc.)
will happen in another file (e.g. create_shading_objects.py).
"""

import random
import logging
from .shading_lookup import shading_lookup # Assuming shading_lookup.py is in the same directory

logger = logging.getLogger(__name__)

def pick_val_from_range(rng_tuple, strategy="A"):
    """
    Helper function to pick a numeric value from a (min_val, max_val) tuple.

    - If strategy="A", picks the midpoint.
    - If strategy="B", picks a random value in [min_val, max_val].
    - Otherwise (e.g., strategy="C" or any other string), picks min_val.

    Parameters
    ----------
    rng_tuple : tuple or None
        A tuple of two numeric values (min_val, max_val) or None.
        If None or not a 2-element tuple, returns None.
        If min_val or max_val is None, attempts to return the non-None value,
        or None if both are None.
    strategy : str, optional
        The strategy to use for picking the value ("A", "B", or other).
        Defaults to "A".

    Returns
    -------
    float or int or None
        The picked numeric value, or None if input is invalid or values are missing.
    """
    if not rng_tuple or not isinstance(rng_tuple, tuple) or len(rng_tuple) != 2:
        if rng_tuple is not None: # Log if it's not None but still invalid
             logger.warning(f"Invalid rng_tuple: {rng_tuple}. Expected a 2-element tuple or None.")
        return None

    min_val, max_val = rng_tuple

    if min_val is None and max_val is None:
        return None
    if min_val is None:
        return max_val # Return max_val if min_val is None
    if max_val is None:
        return min_val # Return min_val if max_val is None

    # Ensure min_val and max_val are numbers if they are not None
    if not all(isinstance(v, (int, float)) for v in [min_val, max_val] if v is not None):
        logger.warning(f"Non-numeric values in rng_tuple: {rng_tuple}. Cannot pick value.")
        return None # Or handle as per specific logic, e.g., return first valid number

    if min_val == max_val:
        return min_val  # No variability

    if min_val > max_val:
        logger.warning(
            f"min_val ({min_val}) is greater than max_val ({max_val}) in range tuple. "
            f"Swapping them for strategy 'A'. For strategy 'B', this might lead to issues if not handled by random.uniform."
        )
        # For midpoint, swapping is fine. For random, random.uniform might error or behave unexpectedly.
        # Python's random.uniform(a,b) requires a <= b.
        if strategy == "B":
            # To be safe, either swap, or return min_val, or log and let it potentially error
            # Choosing to swap for random.uniform to ensure it works:
            min_val, max_val = max_val, min_val


    if strategy == "A":
        return 0.5 * (min_val + max_val)
    elif strategy == "B":
        return random.uniform(min_val, max_val)
    else: # Default or other strategies pick min_val
        return min_val

def pick_shading_params(
    window_id, # Retained for logging, though not strictly used for parameter picking logic here
    shading_type_key="my_external_louvers",
    strategy="A",
    user_config=None,
    assigned_shading_log=None
):
    """
    1) Looks up default shading parameters from shading_lookup[shading_type_key].
    2) If user_config is provided, overrides or adjusts some values. The user_config
       is expected to be a dictionary where keys are parameter names (e.g.,
       "slat_angle_deg_range") and values are the new values or new ranges.
       This `user_config` should be specific to the `shading_type_key` being processed.
    3) Based on 'strategy', picks final numeric values (midpoint, random, or min)
       from any ranges in these parameters.
    4) Optionally logs the final picks in assigned_shading_log.

    Parameters
    ----------
    window_id : str
        An identifier for the window (primarily for logging purposes).
    shading_type_key : str
        The key in shading_lookup to use, e.g., "my_external_louvers".
    strategy : str
        "A" => pick midpoint from ranges; "B" => pick random.
        Otherwise => pick min_val from ranges.
    user_config : dict or None
        A dictionary of overrides specific to this `shading_type_key`.
        E.g., { "slat_angle_deg_range": (30, 60), "slat_width": 0.05 }.
        This dict directly contains parameter names and their override values.
    assigned_shading_log : dict or None
        If provided, store final picks under assigned_shading_log[window_id].

    Returns
    -------
    dict
        A dictionary of final shading parameters with single numeric values, e.g.:
        {
          "blind_name": "MyExternalLouvers",
          "slat_orientation": "Horizontal",
          "slat_width": 0.025,
          "slat_angle_deg": 45.0,
          ...
        }
        Returns an empty dictionary if base_params for shading_type_key are not found.
    """
    base_params = shading_lookup.get(shading_type_key)
    if not base_params:
        logger.error(f"Shading type key '{shading_type_key}' not found in shading_lookup.")
        if assigned_shading_log is not None and window_id is not None:
            if window_id not in assigned_shading_log:
                assigned_shading_log[window_id] = {}
            assigned_shading_log[window_id]["shading_params_error"] = f"Key '{shading_type_key}' not in lookup."
        return {}

    # Start with a deepcopy if base_params might contain nested mutable structures,
    # though for typical shading_lookup, shallow copy is often sufficient.
    # Using shallow copy as per original, assuming values are simple types or tuples.
    final_params = dict(base_params)

    # 2) Apply user overrides
    # user_config here is already the specific set of overrides for this shading_type_key.
    if user_config and isinstance(user_config, dict):
        for key, override_val in user_config.items():
            # If the override_val is a tuple and the original key also ended with _range
            # (or if the new key ends with _range), it's likely an override for a range.
            # Otherwise, it's a direct value replacement or a new parameter.
            final_params[key] = override_val
            # Log if an existing parameter is being overridden
            # if key in base_params:
            # logger.debug(f"For {shading_type_key}, '{key}' overridden from '{base_params[key]}' to '{override_val}'")
            # else:
            # logger.debug(f"For {shading_type_key}, new param '{key}' added with value '{override_val}'")


    # 3) Convert all "*_range" fields to single numeric picks
    #    Also convert any single values that were specified as ranges in lookup/override.
    processed_params = {}
    params_to_remove_range_suffix = []

    for field_key, field_val in list(final_params.items()):
        if field_key.endswith("_range"):
            param_name_base = field_key[:-6]  # remove "_range"
            if isinstance(field_val, tuple): # It's a range, pick a value
                chosen_val = pick_val_from_range(field_val, strategy=strategy)
                if chosen_val is not None:
                    processed_params[param_name_base] = chosen_val
                else:
                    logger.warning(f"Could not pick value for '{field_key}' with value {field_val} for {shading_type_key}. Parameter '{param_name_base}' will be missing.")
                params_to_remove_range_suffix.append(field_key)
            else: # It ends with _range but isn't a tuple, treat as direct value for param_name_base
                logger.warning(f"Field '{field_key}' for {shading_type_key} ends with '_range' but is not a tuple: {field_val}. Using value directly for '{param_name_base}'.")
                processed_params[param_name_base] = field_val
                params_to_remove_range_suffix.append(field_key)
        else:
            # If field_val is a tuple (e.g. from an override that set a non-range field to a tuple)
            # AND it's meant to be a range that needs picking (e.g. user_config provided ("width": (0.1,0.2))
            # then pick_val_from_range should be used.
            # Current logic assumes explicit *_range suffix for picking.
            # If a non-range parameter is overridden with a tuple, it stays a tuple unless handled elsewhere.
            # For simplicity, we only act on *_range keys here.
            # Non-range parameters are kept as is.
            processed_params[field_key] = field_val

    # Clean up the original *_range keys from final_params if they were processed
    for key_to_remove in params_to_remove_range_suffix:
        if key_to_remove in final_params : # It might have been overwritten by a direct key (param_name_base) already
            final_params.pop(key_to_remove, None)


    # Update final_params with the processed (picked) values
    final_params.update(processed_params)


    # 4) Log if needed
    if assigned_shading_log is not None and window_id is not None:
        if window_id not in assigned_shading_log:
            assigned_shading_log[window_id] = {}
        # Store a copy to avoid external modification if final_params is mutable and reused.
        assigned_shading_log[window_id]["shading_params"] = dict(final_params)

    return final_params
------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\wshading\shading_lookup.py
============================================================
"""
shading_lookup.py

Contains default (hardcoded) shading parameters for different blind types,
overhangs, louvers, etc. This is analogous to geometry_lookup.py or
materials_lookup.py, storing dictionary-based defaults.

Each key in the `shading_lookup` dictionary represents a specific type of shading.
The associated value is a dictionary of its parameters. Parameters intended
to be a range (min, max) from which a value will be picked should have a
key ending with "_range".

Example:
  "slat_width_range": (0.025, 0.050)  # Slat width can be between 0.025m and 0.050m

Values for these ranges will be selected by the `pick_val_from_range` function
in `assign_shading_values.py` based on the chosen strategy (e.g., midpoint, random).
"""

shading_lookup = {
    # Example: external horizontal louvers/blinds
    "my_external_louvers": {
        # This name will be used as a base for the EnergyPlus WindowMaterial:Blind object name
        "blind_name": "MyExternalLouvers",
        "slat_orientation": "Horizontal", # Or "Vertical"
        "slat_width_range": (0.025, 0.025), # Slat width in meters
        "slat_separation_range": (0.020, 0.020), # Slat separation (distance between front of one slat and next) in meters
        "slat_thickness_range": (0.001, 0.001), # Slat thickness in meters
        "slat_angle_deg_range": (45.0, 45.0), # Slat angle in degrees (0=horizontal, 90=vertical profile)
        "slat_conductivity_range": (160.0, 160.0), # Slat conductivity in W/m-K (e.g., for aluminum)

        # Solar trans/reflect properties (beam & diffuse):
        # These are for the slat material itself.
        "slat_beam_solar_transmittance_range": (0.0, 0.0), # Fraction of beam solar radiation transmitted directly through slat
        "slat_beam_solar_reflectance_range": (0.7, 0.7), # Fraction of beam solar radiation reflected by front/back of slat (assumed same for front/back here)
        "slat_diffuse_solar_transmittance_range": (0.0, 0.0),# Fraction of diffuse solar radiation transmitted directly through slat
        "slat_diffuse_solar_reflectance_range": (0.7, 0.7), # Fraction of diffuse solar radiation reflected by front/back of slat (assumed same for front/back here)

        # Visible trans/reflect properties (beam & diffuse):
        "slat_beam_visible_transmittance_range": (0.0, 0.0),
        "slat_beam_visible_reflectance_range": (0.7, 0.7), # Assumed same for front/back here
        "slat_diffuse_visible_transmittance_range": (0.0, 0.0),
        "slat_diffuse_visible_reflectance_range": (0.7, 0.7), # Assumed same for front/back here

        # IR / emissivity properties
        "slat_ir_transmittance_range": (0.0, 0.0), # Infrared transmittance of slat material
        "slat_ir_emissivity_range": (0.9, 0.9), # Infrared emissivity of slat material (assumed same for front/back here)

        # Blind geometry offsets and details (these may or may not be used by all shading objects)
        "blind_to_glass_distance_range": (0.05, 0.05), # Distance from glazing to blind in meters (positive for exterior, negative for interior)
        "blind_top_opening_multiplier_range": (1.0, 1.0), # Multiplier for air flow opening at top of blind
        "blind_bottom_opening_multiplier_range": (1.0, 1.0), # Multiplier for air flow opening at bottom of blind
        "blind_left_opening_multiplier_range": (1.0, 1.0), # Multiplier for air flow opening at left side of blind
        "blind_right_opening_multiplier_range": (1.0, 1.0), # Multiplier for air flow opening at right side of blind

        # Slat angle limits (if dynamic control is used, not directly used by fixed angle)
        "slat_angle_min_deg_range": (0.0, 0.0), # Minimum slat angle in degrees
        "slat_angle_max_deg_range": (90.0, 90.0), # Maximum slat angle in degrees

        # For Shading:Building:Detailed type objects (if this key were for an overhang/fin)
        # "overhang_depth_range": (0.5, 1.0), # Example for a geometric shading element
        # "fin_depth_range": (0.3, 0.6),      # Example for a geometric shading element
    },

    # Example: interior roller blind (dark)
    "my_interior_roller_blind_dark": {
        "blind_name": "InteriorRollerDark",
        "slat_orientation": "Horizontal", # Roller blinds are effectively horizontal slats of fabric
        "slat_width_range": (1.0, 1.0), # Effectively the full window width when down (actual E+ modelling might differ)
        "slat_separation_range": (1.0, 1.0), # Effectively the same as slat width
        "slat_thickness_range": (0.0005, 0.0005), # Fabric thickness
        "slat_angle_deg_range": (0.0, 0.0), # Always flat when down
        "slat_conductivity_range": (0.1, 0.1), # Fabric conductivity

        "slat_beam_solar_transmittance_range": (0.05, 0.05),
        "slat_beam_solar_reflectance_range": (0.1, 0.1),
        "slat_diffuse_solar_transmittance_range": (0.05, 0.05),
        "slat_diffuse_solar_reflectance_range": (0.1, 0.1),

        "slat_beam_visible_transmittance_range": (0.03, 0.03),
        "slat_beam_visible_reflectance_range": (0.05, 0.05),
        "slat_diffuse_visible_transmittance_range": (0.03, 0.03),
        "slat_diffuse_visible_reflectance_range": (0.05, 0.05),

        "slat_ir_transmittance_range": (0.0, 0.0),
        "slat_ir_emissivity_range": (0.85, 0.85),

        "blind_to_glass_distance_range": (-0.03, -0.03), # Negative for interior
    },

    # Add more predefined shading “types” here as needed, for example:
    # "my_vertical_fins": {
    #     "fin_name": "VerticalFinSystem",
    #     "fin_depth_range": (0.3, 0.5),
    #     "fin_spacing_range": (0.5, 0.7),
    #     # ... other relevant geometric or material properties
    # },
    # "my_fixed_overhang": {
    #     "overhang_name": "FixedBuildingOverhang",
    #     "overhang_depth_range": (0.5, 1.2),
    #     # ... other relevant geometric or material properties
    # },
}
------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\wshading\create_shading_objects.py
============================================================
"""
create_shading_objects.py

This module creates EnergyPlus shading objects in the IDF
(e.g., WindowMaterial:Blind, WindowShadingControl,
 Shading:Building:Detailed, schedules, etc.).

It calls pick_shading_params(...) from assign_shading_values.py
to get final numeric parameter values. You can pass user/Excel overrides
to customize these parameters.

Usage:
  from idf_objects.wshading.create_shading_objects import add_shading_objects

  add_shading_objects(
      idf=idf,
      building_row=some_dict, # Or other context identifier
      shading_type_key="my_external_louvers",
      strategy="A", # Or "B"
      random_seed=42,
      user_config_shading=shading_overrides_for_this_type, # Dict of overrides for this specific shading_type_key
      assigned_shading_log=shading_log_dict,
      create_blinds=True,
      create_geometry_shading=False
  )
"""

import random
import logging
from .assign_shading_values import pick_shading_params

# from geomeppy import IDF # Ensure your IDF object type matches
# from eppy.bunch_subclass import EpBunch # Ensure your IDF object type matches

logger = logging.getLogger(__name__)
# Configure logger if not already configured by the main application
if not logger.hasHandlers():
    logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')


def add_shading_objects(
    idf,
    building_row,  # Used for context, e.g., if shading depends on building properties
    shading_type_key="my_external_louvers",
    strategy="A",
    random_seed=42,
    user_config_shading=None,
    assigned_shading_log=None,
    create_blinds=True,
    create_geometry_shading=False,
):
    """
    Creates the necessary shading objects in the IDF: e.g. WindowMaterial:Blind,
    WindowShadingControl, or geometry-based Shading:Building:Detailed.

    1) Loops over fenestration surfaces (if creating blinds per window) or processes
       once for global shading elements.
    2) Calls pick_shading_params(...) to get final numeric values (slat angles, etc.).
    3) Creates EnergyPlus shading devices (e.g., WindowMaterial:Blind + ShadingControl).
    4) Optionally, creates an E+ schedule if dynamic shading is needed (example provided).
    5) Optionally, creates Shading:Building:Detailed geometry if requested.

    Parameters
    ----------
    idf : IDF object
        The IDF object (e.g., from geomeppy or eppy) where new objects will be added.
    building_row : dict or pandas.Series or object
        Contextual data for the building/element being processed. Can be used to
        derive window IDs or influence shading choices if needed.
    shading_type_key : str
        Key in shading_lookup (from shading_lookup.py) to define the base shading
        parameters, e.g., "my_external_louvers".
    strategy : str
        Strategy for picking values from ranges ("A" for midpoint, "B" for random,
        other for min_val). Passed to pick_shading_params.
    random_seed : int, optional
        Seed for random number generation if strategy="B". Defaults to 42.
    user_config_shading : dict or None
        A dictionary of overrides for the specified `shading_type_key`.
        E.g., {"slat_angle_deg_range": (30, 60), "slat_width": 0.05}.
        These are applied on top of `shading_lookup` defaults.
    assigned_shading_log : dict or None
        If provided, final shading params are stored here. Keys could be window_id
        or another relevant identifier.
    create_blinds : bool
        If True, attempts to create blind-based shading objects (WindowMaterial:Blind
        + WindowShadingControl) for fenestration surfaces.
    create_geometry_shading : bool
        If True, attempts to create Shading:Building:Detailed geometry-based shading
        (e.g., overhangs), using an example function.
    """
    if random_seed is not None:
        random.seed(random_seed)

    if not idf:
        logger.error("IDF object is None. Cannot add shading objects.")
        return

    logger.info(f"Starting add_shading_objects for shading_type_key: '{shading_type_key}'")

    # --- Create Blind Shading for Fenestration Surfaces ---
    if create_blinds:
        logger.info("Attempting to create blind shading for fenestration surfaces.")
        try:
            fen_surfaces = idf.idfobjects.get("FENESTRATIONSURFACE:DETAILED", [])
            if not fen_surfaces:
                logger.warning(
                    "No 'FENESTRATIONSURFACE:DETAILED' objects found in IDF. Skipping blind creation."
                )
            else:
                logger.info(f"Found {len(fen_surfaces)} FENESTRATIONSURFACE:DETAILED objects to process.")
        except Exception as e:
            logger.error(
                f"Could not retrieve FENESTRATIONSURFACE:DETAILED from IDF: {e}"
            )
            fen_surfaces = []

        for fen_idx, fen in enumerate(fen_surfaces):
            fen_name_attr = getattr(fen, "Name", None)
            window_id = fen_name_attr if fen_name_attr else f"FenestrationSurface_DefaultName_{fen_idx}"
            
            logger.info(f"Processing fenestration surface: '{window_id}' (Index: {fen_idx})")

            try:
                # 1) Pick shading params (combines shading_lookup + user overrides)
                logger.debug(f"[{window_id}] Picking shading parameters with key '{shading_type_key}' and strategy '{strategy}'.")
                shading_params = pick_shading_params(
                    window_id=window_id,  # Used for logging within pick_shading_params
                    shading_type_key=shading_type_key,
                    strategy=strategy,
                    user_config=user_config_shading,  # Pass the specific overrides for this type
                    assigned_shading_log=assigned_shading_log,
                )

                if not shading_params:
                    logger.warning(
                        f"[{window_id}] No shading parameters resolved for key '{shading_type_key}'. Skipping blind creation for this window."
                    )
                    if assigned_shading_log is not None and window_id is not None: # Log failure
                        if window_id not in assigned_shading_log:
                            assigned_shading_log[window_id] = {}
                        assigned_shading_log[window_id]["shading_creation_status"] = f"Failed: No params for key {shading_type_key}"
                    continue

                logger.debug(f"[{window_id}] Resolved shading parameters: {shading_params}")

                # 2) Create or retrieve a WindowMaterial:Blind object
                # The name should be unique per window if properties differ, or shared if identical.
                # Current approach makes it unique per window_id.
                base_blind_material_name_from_params = shading_params.get("blind_name", "DefaultBlindMaterial")
                blind_mat_name = f"{base_blind_material_name_from_params}_{window_id}"
                
                logger.debug(f"[{window_id}] Target WindowMaterial:Blind name: '{blind_mat_name}'")

                # Check if blind material already exists to prevent duplicates
                existing_blind_mats_objects = idf.idfobjects.get("WINDOWMATERIAL:BLIND", [])
                found_blind_mat = next((bm for bm in existing_blind_mats_objects if bm.Name == blind_mat_name), None)

                if found_blind_mat:
                    logger.info(
                        f"[{window_id}] WindowMaterial:Blind '{blind_mat_name}' already exists. Reusing."
                    )
                    # blind_mat = found_blind_mat # Not strictly needed if only name is used later
                else:
                    logger.info(f"[{window_id}] Creating new WindowMaterial:Blind '{blind_mat_name}'.")
                    blind_mat = idf.newidfobject("WINDOWMATERIAL:BLIND")
                    blind_mat.Name = blind_mat_name

                    # --- Assign common blind material properties with defaults ---
                    blind_mat.Slat_Orientation = shading_params.get(
                        "slat_orientation", "Horizontal"
                    )
                    blind_mat.Slat_Width = shading_params.get(
                        "slat_width", 0.025
                    )
                    blind_mat.Slat_Separation = shading_params.get(
                        "slat_separation", 0.020
                    )
                    blind_mat.Slat_Thickness = shading_params.get(
                        "slat_thickness", 0.001
                    )
                    blind_mat.Slat_Angle = shading_params.get(
                        "slat_angle_deg", 45.0
                    )
                    blind_mat.Slat_Conductivity = shading_params.get(
                        "slat_conductivity", 160.0
                    )

                    # --- Optical Properties ---
                    sbsr = shading_params.get("slat_beam_solar_reflectance", 0.7)
                    sdsr = shading_params.get("slat_diffuse_solar_reflectance", 0.7)
                    sbvr = shading_params.get("slat_beam_visible_reflectance", 0.7)
                    sdvr = shading_params.get("slat_diffuse_visible_reflectance", 0.7)
                    sir_em = shading_params.get("slat_ir_emissivity", 0.9)

                    blind_mat.Slat_Beam_Solar_Transmittance = shading_params.get("slat_beam_solar_transmittance", 0.0)
                    blind_mat.Front_Side_Slat_Beam_Solar_Reflectance = sbsr
                    blind_mat.Back_Side_Slat_Beam_Solar_Reflectance = shading_params.get("back_side_slat_beam_solar_reflectance", sbsr) # Allow asymmetric if specified

                    blind_mat.Slat_Diffuse_Solar_Transmittance = shading_params.get("slat_diffuse_solar_transmittance", 0.0)
                    blind_mat.Front_Side_Slat_Diffuse_Solar_Reflectance = sdsr
                    blind_mat.Back_Side_Slat_Diffuse_Solar_Reflectance = shading_params.get("back_side_slat_diffuse_solar_reflectance", sdsr)

                    blind_mat.Slat_Beam_Visible_Transmittance = shading_params.get("slat_beam_visible_transmittance", 0.0)
                    blind_mat.Front_Side_Slat_Beam_Visible_Reflectance = sbvr
                    blind_mat.Back_Side_Slat_Beam_Visible_Reflectance = shading_params.get("back_side_slat_beam_visible_reflectance", sbvr)

                    blind_mat.Slat_Diffuse_Visible_Transmittance = shading_params.get("slat_diffuse_visible_transmittance", 0.0)
                    blind_mat.Front_Side_Slat_Diffuse_Visible_Reflectance = sdvr
                    blind_mat.Back_Side_Slat_Diffuse_Visible_Reflectance = shading_params.get("back_side_slat_diffuse_visible_reflectance", sdvr)
                    
                    blind_mat.Slat_Infrared_Hemispherical_Transmittance = shading_params.get("slat_ir_transmittance", 0.0)
                    blind_mat.Front_Side_Slat_Infrared_Hemispherical_Emissivity = sir_em
                    blind_mat.Back_Side_Slat_Infrared_Hemispherical_Emissivity = shading_params.get("back_side_slat_ir_emissivity", sir_em)
                    
                    # --- Other Optional Fields ---
                    if "blind_to_glass_distance" in shading_params:
                        blind_mat.Distance_between_Slat_and_Glazing = shading_params["blind_to_glass_distance"]
                    if "blind_top_opening_multiplier" in shading_params: # E+ has one Slat_Opening_Multiplier
                         blind_mat.Slat_Opening_Multiplier = shading_params["blind_top_opening_multiplier"]
                    # Add other multipliers if your E+ version supports them or if you simplify them to one value
                    if "minimum_slat_angle" in shading_params: # Check I/O ref for actual field name if this is intended for WindowMaterial:Blind
                        blind_mat.Minimum_Slat_Angle = shading_params["minimum_slat_angle"] # Example field name
                    if "maximum_slat_angle" in shading_params:
                        blind_mat.Maximum_Slat_Angle = shading_params["maximum_slat_angle"] # Example field name


                    logger.debug(f"[{window_id}] Successfully created WindowMaterial:Blind '{blind_mat.Name}'.")

                # 3) Create or retrieve WindowShadingControl object
                shading_ctrl_name = f"ShadingCtrl_{window_id}"
                logger.debug(f"[{window_id}] Target WindowShadingControl name: '{shading_ctrl_name}'")

                existing_shading_ctrls_objects = idf.idfobjects.get("WINDOWSHADINGCONTROL", [])
                found_shading_ctrl = next((sc for sc in existing_shading_ctrls_objects if sc.Name == shading_ctrl_name), None)
                
                shading_ctrl_obj_to_assign_name = shading_ctrl_name # Default to the name

                if found_shading_ctrl:
                    logger.info(
                        f"[{window_id}] WindowShadingControl '{shading_ctrl_name}' already exists. Reusing."
                    )
                    # shading_ctrl_obj_to_assign_name = found_shading_ctrl.Name # Already set
                else:
                    logger.info(f"[{window_id}] Creating new WindowShadingControl '{shading_ctrl_name}'.")
                    shading_ctrl = idf.newidfobject("WINDOWSHADINGCONTROL")
                    shading_ctrl.Name = shading_ctrl_name
                    
                    # Determine Shading_Type based on blind_to_glass_distance or a param
                    # Defaulting to ExteriorBlind if distance is positive or not specified, Interior if negative
                    blind_dist = shading_params.get("blind_to_glass_distance", 0.05) # Default to exterior
                    shading_device_type_ep = "ExteriorBlind"
                    if isinstance(blind_dist, (int, float)) and blind_dist < 0:
                        shading_device_type_ep = "InteriorBlind"
                    # Could also be driven by a parameter in shading_params:
                    # shading_device_type_ep = shading_params.get("shading_device_type_ep", "ExteriorBlind")
                    shading_ctrl.Shading_Type = shading_device_type_ep
                    
                    shading_ctrl.Shading_Device_Material_Name = blind_mat_name # Use the name of the WindowMaterial:Blind
                    
                    # Control Type (defaulting to FixedSlatAngle)
                    shading_ctrl.Type_of_Slats_Control_for_Blinds = shading_params.get("slat_control_type", "FixedSlatAngle")
                    
                    # Slat Angle for Fixed Control
                    if shading_ctrl.Type_of_Slats_Control_for_Blinds.lower() == "fixedslatangle":
                        shading_ctrl.Slat_Angle_Control_for_Fixed_Slat_Angle = shading_params.get("slat_angle_deg", 45.0)
                    
                    # Schedule for deployment (e.g., AlwaysOn, or a specific schedule)
                    # Defaulting to "No" schedule, meaning it's always available to be controlled by other means if not AlwaysOn
                    shading_ctrl.Shading_Control_Is_Scheduled = shading_params.get("shading_control_is_scheduled", "No") 
                    if shading_ctrl.Shading_Control_Is_Scheduled.lower() == "yes":
                        shading_ctrl.Shading_Control_Schedule_Name = shading_params.get("shading_control_schedule_name", "AlwaysOnSchedule") # Ensure this schedule exists
                    
                    # Glare Control
                    shading_ctrl.Glare_Control_Is_Active = shading_params.get("glare_control_is_active", "No")
                    # Other fields like Setpoint, ShadingControlSetpointScheduleName etc. for advanced control can be added from shading_params

                    logger.debug(f"[{window_id}] Successfully created WindowShadingControl '{shading_ctrl.Name}'.")
                    # shading_ctrl_obj_to_assign_name = shading_ctrl.Name # Already set

                # 4) Link the shading control to this fenestration surface
                logger.info(f"[{window_id}] Attempting to assign Shading_Control_Name: '{shading_ctrl_obj_to_assign_name}' to fenestration surface: '{fen_name_attr}'")
                try:
                    # Ensure the fen object allows direct attribute assignment for Shading_Control_Name
                    # This is typical for geomeppy/eppy objects.
                    fen.Shading_Control_Name = shading_ctrl_obj_to_assign_name
                    # Verification step:
                    assigned_sc_name = getattr(fen, 'Shading_Control_Name', 'FIELD_NOT_FOUND_OR_EMPTY_AFTER_ASSIGN')
                    logger.info(f"[{window_id}] After assignment, {fen_name_attr}.Shading_Control_Name is: '{assigned_sc_name}'")
                    if assigned_sc_name != shading_ctrl_obj_to_assign_name:
                        logger.error(f"[{window_id}] FAILED to verify Shading_Control_Name assignment. Expected '{shading_ctrl_obj_to_assign_name}', got '{assigned_sc_name}'.")
                    else:
                        logger.info(f"[{window_id}] Successfully linked shading control '{shading_ctrl_obj_to_assign_name}'.")
                        if assigned_shading_log is not None and window_id is not None: # Log success
                            if window_id not in assigned_shading_log:
                                assigned_shading_log[window_id] = {}
                            assigned_shading_log[window_id]["shading_creation_status"] = f"Success: Linked to {shading_ctrl_obj_to_assign_name}"
                            assigned_shading_log[window_id]["shading_control_name_assigned"] = shading_ctrl_obj_to_assign_name
                            assigned_shading_log[window_id]["blind_material_name_used"] = blind_mat_name


                except AttributeError as e_attr:
                    logger.error(
                        f"[{window_id}] AttributeError: Failed to assign Shading_Control_Name. Does the FENESTRATIONSURFACE:DETAILED object have a 'Shading_Control_Name' field/attribute? Error: {e_attr}"
                    )
                except Exception as e_assign:
                    logger.error(
                        f"[{window_id}] Exception: Failed to assign Shading_Control_Name to {fen_name_attr}: {e_assign}"
                    )
                    if assigned_shading_log is not None and window_id is not None: # Log failure
                        if window_id not in assigned_shading_log:
                            assigned_shading_log[window_id] = {}
                        assigned_shading_log[window_id]["shading_creation_status"] = f"Failed: Linking error {e_assign}"


            except Exception as e_fen_processing:
                logger.error(
                    f"Error processing blind for fenestration surface '{window_id}': {e_fen_processing}",
                    exc_info=True # Provides traceback
                )
                if assigned_shading_log is not None and window_id is not None: # Log failure
                    if window_id not in assigned_shading_log:
                        assigned_shading_log[window_id] = {}
                    assigned_shading_log[window_id]["shading_creation_status"] = f"Failed: Outer processing error {e_fen_processing}"
                continue  # Move to the next fenestration surface
        logger.info("Finished processing blind shading for fenestration surfaces.")


    # --- Create Geometry-Based Shading (e.g., Overhangs, Fins) ---
    if create_geometry_shading:
        logger.info(
            f"Attempting to create geometry-based shading using shading_type_key: '{shading_type_key}'"
        )
        # This typically would not loop per window unless geometry is window-specific.
        # The _create_overhang_example is a global example.
        # You might need a list of building elements or a different context for these.
        _create_overhang_example(
            idf,
            building_row,  # Pass context
            shading_type_key=shading_type_key,  # Use the main key, or a specific one for geometry
            strategy=strategy,
            user_config_shading=user_config_shading,  # Pass overrides if applicable to geometry
        )
    
    num_blind_mats_final = len(idf.idfobjects.get("WINDOWMATERIAL:BLIND", []))
    num_shading_ctrls_final = len(idf.idfobjects.get("WINDOWSHADINGCONTROL", []))
    logger.info(f"Exiting add_shading_objects. Total WindowMaterial:Blind objects in IDF: {num_blind_mats_final}")
    logger.info(f"Exiting add_shading_objects. Total WindowShadingControl objects in IDF: {num_shading_ctrls_final}")


def _create_overhang_example(
    idf, building_row_context, shading_type_key, strategy, user_config_shading
):
    """
    Example function to demonstrate geometry-based shading (Shading:Building:Detailed).
    In real usage, you’d compute or retrieve the overhang geometry from
    building_row_context, other geometric inputs, or detailed shading_params.
    This is a placeholder and creates a fixed, illustrative overhang.

    Parameters
    ----------
    idf : IDF object
    building_row_context : dict or object
        Contextual data (e.g., building dimensions, orientation) that could inform geometry.
    shading_type_key : str
        Key to look up base parameters, potentially for overhang depth, etc.
    strategy : str
        Strategy for picking values from ranges.
    user_config_shading : dict or None
        Overrides for parameters relevant to this geometric shading.
    """
    logger.info("Executing _create_overhang_example.")
    # Suppose we pick some shading params that define the overhang depth
    # For geometry, the 'window_id' for pick_shading_params might be a generic name
    # if the overhang is not tied to a specific window but rather a facade or building.
    shading_params = pick_shading_params(
        window_id="Global_Overhang_Example",  # Generic ID for logging these params
        shading_type_key=shading_type_key,  # Could be a specific key like "my_building_overhang"
        strategy=strategy,
        user_config=user_config_shading,  # Pass relevant part of user_config
    )

    if not shading_params:
        logger.warning(
            f"No parameters resolved for overhang example with key '{shading_type_key}'. Skipping overhang creation."
        )
        return

    # Let's say we expect an "overhang_depth" from shading_params
    # or use a default if not found.
    overhang_depth = shading_params.get("overhang_depth", 1.0)  # Default 1m depth
    overhang_name = shading_params.get("overhang_name", "Overhang_North_Example")

    # Check if this shading object already exists
    existing_shading_geom = [
        sg.Name for sg in idf.idfobjects.get("SHADING:BUILDING:DETAILED", [])
    ]
    if overhang_name in existing_shading_geom:
        logger.info(
            f"Shading:Building:Detailed '{overhang_name}' already exists. Skipping creation."
        )
        return

    try:
        shading_obj = idf.newidfobject("SHADING:BUILDING:DETAILED")
        shading_obj.Name = overhang_name
        # Base_Surface_Name: Optional, if the overhang is attached to a specific surface.
        # Transmittance_Schedule_Name: Optional, if transmittance varies.

        # Hard-coded example geometry (4 vertices for a simple rectangular overhang):
        # This is purely illustrative. You’d typically compute X/Y/Z coordinates based on
        # building_row_context (e.g., facade width, window position, orientation),
        # and parameters like overhang_depth, width, tilt from shading_params.

        # Example: A 5m wide overhang, 1m deep, at Z=3.0, on a North facade (Y positive)
        # Vertices are typically counter-clockwise when viewed from outside.
        shading_obj.Number_of_Vertices = 4

        # Vertex 1 (Bottom-Left from outside view)
        shading_obj.Vertex_1_X_coordinate = (
            0.0  # Assuming start at X=0 of facade segment
        )
        shading_obj.Vertex_1_Y_coordinate = (
            0.0  # Y=0 is the facade plane for this local definition
        )
        shading_obj.Vertex_1_Z_coordinate = 3.0  # Height

        # Vertex 2 (Bottom-Right)
        shading_obj.Vertex_2_X_coordinate = 5.0  # Width of overhang = 5m
        shading_obj.Vertex_2_Y_coordinate = 0.0
        shading_obj.Vertex_2_Z_coordinate = 3.0

        # Vertex 3 (Top-Right, projecting outwards)
        shading_obj.Vertex_3_X_coordinate = 5.0
        shading_obj.Vertex_3_Y_coordinate = overhang_depth  # Projects 'overhang_depth' outwards (e.g., in positive Y if North wall is at Y=0)
        shading_obj.Vertex_3_Z_coordinate = 3.0  # Assuming flat overhang for simplicity

        # Vertex 4 (Top-Left, projecting outwards)
        shading_obj.Vertex_4_X_coordinate = 0.0
        shading_obj.Vertex_4_Y_coordinate = overhang_depth
        shading_obj.Vertex_4_Z_coordinate = 3.0

        # Note: The coordinate system for SHADING:BUILDING:DETAILED is absolute world coordinates.
        # The example above assumes a local definition relative to a point, which would then
        # need to be transformed to world coordinates based on building_row_context.
        # For simplicity here, these are treated as if they are already world coordinates.

        logger.debug(
            f"Created Shading:Building:Detailed '{shading_obj.Name}' with depth {overhang_depth}m."
        )

    except Exception as e:
        logger.error(f"Error creating Shading:Building:Detailed '{overhang_name}': {e}", exc_info=True)


def add_shading_schedule(
    idf, schedule_name="DefaultShadingSchedule", schedule_type="Fraction"
):
    """
    Example of how you might create a schedule for dynamic shading control
    (e.g., for Shading_Control_Schedule_Name in WindowShadingControl).

    Parameters
    ----------
    idf : IDF object
    schedule_name : str
        Name for the new schedule.
    schedule_type : str
        Type of schedule, e.g., "Fraction", "OnOff", "Temperature".

    Returns
    -------
    EpBunch or equivalent schedule object
        The created schedule object, or None if creation fails.
    """
    logger.info(
        f"Attempting to create schedule: '{schedule_name}' of type '{schedule_type}'."
    )

    # Check if schedule already exists
    existing_schedules_compact = [
        s.Name for s in idf.idfobjects.get("SCHEDULE:COMPACT", [])
    ]
    # Add checks for other schedule types if you use them (SCHEDULE:YEAR, SCHEDULE:CONSTANT etc.)
    if schedule_name in existing_schedules_compact:
        logger.info(f"Schedule:Compact '{schedule_name}' already exists. Reusing.")
        # Find and return the existing schedule object if needed by the caller
        for s_obj in idf.idfobjects["SCHEDULE:COMPACT"]:
            if s_obj.Name == schedule_name:
                return s_obj
        return None # Should not happen if name was found in list comprehension

    try:
        # Using SCHEDULE:COMPACT for simplicity.
        sched = idf.newidfobject("SCHEDULE:COMPACT")
        sched.Name = schedule_name

        # Schedule_Type_Limits_Name links to a ScheduleTypeLimits object.
        stl_name = schedule_type  # Assuming ScheduleTypeLimits Name matches type for simplicity
        existing_stls = [
            stl.Name for stl in idf.idfobjects.get("SCHEDULETYPELIMITS", [])
        ]
        if stl_name not in existing_stls:
            logger.warning(
                f"ScheduleTypeLimits '{stl_name}' not found. Creating a basic one for '{schedule_name}'."
            )
            new_stl = idf.newidfobject("SCHEDULETYPELIMITS")
            new_stl.Name = stl_name
            if schedule_type.lower() == "fraction":
                new_stl.Lower_Limit_Value = 0.0
                new_stl.Upper_Limit_Value = 1.0
                new_stl.Numeric_Type = "Continuous"
            elif schedule_type.lower() == "onoff": # Common for availability
                new_stl.Lower_Limit_Value = 0.0
                new_stl.Upper_Limit_Value = 1.0
                new_stl.Numeric_Type = "Discrete"
            elif schedule_type.lower() == "temperature":
                new_stl.Lower_Limit_Value = -100.0 # Example
                new_stl.Upper_Limit_Value = 200.0  # Example
                new_stl.Numeric_Type = "Continuous"
            else:
                logger.warning(
                    f"No default setup for ScheduleTypeLimits '{schedule_type}'. It might be invalid. Defaulting to Fraction-like limits."
                )
                new_stl.Lower_Limit_Value = 0.0
                new_stl.Upper_Limit_Value = 1.0
                new_stl.Numeric_Type = "Continuous" # Or Discrete if more appropriate for unknown type

        sched.Schedule_Type_Limits_Name = stl_name

        # Simple example: always 1.0 (e.g., shades always active if scheduled)
        # Field format for SCHEDULE:COMPACT: "Through: MM/DD", "For: Days", "Until: HH:MM, Value", ...
        sched.Field_1 = "Through: 12/31"  # Through end of year
        sched.Field_2 = "For: AllDays"  # For all day types
        sched.Field_3 = "Until: 24:00, 1.0"  # Until midnight, value is 1.0
        # Add more fields for complex schedules.

        logger.debug(f"Created Schedule:Compact '{sched.Name}'.")
        return sched
    except Exception as e:
        logger.error(f"Error creating schedule '{schedule_name}': {e}", exc_info=True)
        return None

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\wshading\shading_overrides_from_excel.py
============================================================
"""
shading_overrides_from_excel.py

If you want to read shading overrides from an Excel file (e.g., different
blind angles per season, or custom user settings for certain building IDs),
you can do that here.

Analogous to geometry_overrides_from_excel.py or dict_override_excel.py:
 - parse the Excel
 - store each row in a rules dictionary
 - 'pick_shading_params_from_rules' uses those rules to find
   the best match for a building/window context
"""

import pandas as pd
import logging

logger = logging.getLogger(__name__)

def read_shading_overrides_excel(excel_path):
    """
    Reads an Excel file containing shading override rules.

    Example columns might be:
        building_id
        shading_type_key
        slat_angle_deg_min
        slat_angle_deg_max
        slat_width  # Example of a single value override
        # ... other parameters ...

    Returns
    -------
    list
        A list of dictionaries, where each dictionary represents a row (a rule)
        from the Excel sheet. Returns an empty list if the file cannot be read
        or is empty.
    
    Raises
    ------
    ValueError
        If required columns are missing.
    """
    try:
        df = pd.read_excel(excel_path)
    except FileNotFoundError:
        logger.error(f"Excel override file not found: {excel_path}")
        return []
    except Exception as e:
        logger.error(f"Error reading Excel override file {excel_path}: {e}")
        return []

    if df.empty:
        logger.warning(f"Shading overrides Excel file is empty: {excel_path}")
        return []

    # We define a minimal required set of columns
    required_cols = ["building_id", "shading_type_key"]
    missing = [c for c in required_cols if c not in df.columns]
    if missing:
        raise ValueError(f"Missing columns in shading_overrides Excel ({excel_path}): {missing}")

    override_rules = []
    for index, row in df.iterrows():
        rule = {}
        try:
            rule["building_id"] = str(row["building_id"]).strip()
            rule["shading_type_key"] = str(row["shading_type_key"]).strip()

            # --- Handle range parameters ---
            # Example: slat_angle_deg_range
            if "slat_angle_deg_min" in df.columns and "slat_angle_deg_max" in df.columns:
                min_ang = row["slat_angle_deg_min"]
                max_ang = row["slat_angle_deg_max"]
                if pd.notna(min_ang) and pd.notna(max_ang):
                    try:
                        rule["slat_angle_deg_range"] = (float(min_ang), float(max_ang))
                    except ValueError:
                        logger.warning(
                            f"Invalid float value for slat_angle_deg_min/max in Excel row {index + 2}. "
                            f"Skipping slat_angle_deg_range for this rule."
                        )
                elif pd.notna(min_ang) or pd.notna(max_ang):
                    logger.warning(
                        f"Partial slat_angle_deg_min/max definition in Excel row {index + 2}. "
                        f"Both must be provided. Skipping slat_angle_deg_range for this rule."
                    )
            
            # TODO: Add more explicit range parameter handling here if needed
            # Example for another range parameter "parameter_foo_range":
            # if "parameter_foo_min" in df.columns and "parameter_foo_max" in df.columns:
            #     min_val = row["parameter_foo_min"]
            #     max_val = row["parameter_foo_max"]
            #     if pd.notna(min_val) and pd.notna(max_val):
            #         try:
            #             rule["parameter_foo_range"] = (float(min_val), float(max_val))
            #         except ValueError:
            #              logger.warning(f"Invalid float for parameter_foo_min/max in Excel row {index + 2}.")
            #     elif pd.notna(min_val) or pd.notna(max_val):
            #         logger.warning(f"Partial parameter_foo_min/max in Excel row {index + 2}.")


            # --- Handle single value parameters ---
            # Add other specific single-value parameters that can be overridden from Excel.
            # Ensure they are parsed to the correct type.
            # Example:
            # if "slat_width" in df.columns and pd.notna(row["slat_width"]):
            #     try:
            #         rule["slat_width"] = float(row["slat_width"])
            #     except ValueError:
            #         logger.warning(f"Invalid float value for slat_width in Excel row {index + 2}. Skipping.")
            
            # Generic approach: Add all other non-empty columns from the Excel row to the rule.
            # These will be used as direct overrides in `pick_shading_params`.
            # The `pick_shading_params` function will then decide how to use them (e.g., if it's a range or single value).
            for col_name in df.columns:
                if col_name not in required_cols and \
                   not col_name.endswith(("_min", "_max")) and \
                   col_name not in rule and \
                   pd.notna(row[col_name]):
                    rule[col_name] = row[col_name] # Keep original type for now, or convert as needed

            override_rules.append(rule)
        except Exception as e:
            logger.error(f"Error processing row {index + 2} in {excel_path}: {e}. Skipping this rule.")
            continue
            
    return override_rules


def pick_shading_params_from_rules(
    building_id,
    shading_type_key,
    all_rules,
    fallback=None
):
    """
    Looks through the list of override_rules (from read_shading_overrides_excel)
    to find a matching rule for the given building_id and shading_type_key.

    The matching is case-insensitive for building_id and shading_type_key.
    If multiple rules match, the last one found in the `all_rules` list takes precedence.

    Parameters
    ----------
    building_id : str or int
        The identifier of the building.
    shading_type_key : str
        The key identifying the type of shading (e.g., "my_external_louvers").
    all_rules : list
        A list of rule dictionaries, typically from `read_shading_overrides_excel`.
    fallback : any, optional
        Value to return if no matching rule is found. Defaults to None.

    Returns
    -------
    dict or any
        A dictionary containing the override parameters if a match is found.
        These parameters are the ones to be applied, excluding "building_id"
        and "shading_type_key". Returns `fallback` if no rule matches.
        Example override dict: {"slat_angle_deg_range": (30, 60), "slat_width": 0.05}
    """
    if not all_rules:
        return fallback

    best_rule_content = None
    building_id_str = str(building_id).lower()
    shading_type_key_str = str(shading_type_key).lower()

    for rule in all_rules:
        # building_id must match (case-insensitive)
        rule_building_id = str(rule.get("building_id", "")).lower()
        if rule_building_id != building_id_str:
            continue

        # shading_type_key must match (case-insensitive)
        rule_shading_type_key = str(rule.get("shading_type_key", "")).lower()
        if rule_shading_type_key != shading_type_key_str:
            continue
        
        # If we are here, both IDs matched.
        # The last match in the list takes precedence.
        current_overrides = dict(rule)
        current_overrides.pop("building_id", None)
        current_overrides.pop("shading_type_key", None)
        best_rule_content = current_overrides

    if best_rule_content is None:
        return fallback

    return best_rule_content
------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_creation.py
============================================================
"""
idf_creation.py

Handles the creation of EnergyPlus IDF files for a list of buildings,
plus optional simulation runs and post-processing.

Key functionalities:
  1) create_idf_for_building(...) builds a single IDF using geomeppy,
     applying geometry, fenestration, HVAC, etc.
  2) create_idfs_for_all_buildings(...) loops over multiple buildings,
     then optionally runs simulations and merges results in one or more ways.

Updated to allow writing logs/results inside a specific job folder via logs_base_dir.
"""

import os
import logging
import pandas as pd

# geomeppy for IDF manipulation
from geomeppy import IDF

# --- Import your custom submodules ---
from idf_objects.geomz.building import create_building_with_roof_type
from idf_objects.fenez.fenestration import add_fenestration
from idf_objects.fenez.materials import (
    update_construction_materials,
    assign_constructions_to_surfaces
)
from idf_objects.Elec.lighting import add_lights_and_parasitics
from idf_objects.eequip.equipment import add_electric_equipment
from idf_objects.DHW.water_heater import add_dhw_to_idf
from idf_objects.HVAC.custom_hvac import add_HVAC_Ideal_to_all_zones
from idf_objects.ventilation.add_ventilation import add_ventilation_to_idf
from idf_objects.wshading.create_shading_objects import add_shading_objects
from idf_objects.setzone.add_outdoor_air_and_zone_sizing_to_all_zones import add_outdoor_air_and_zone_sizing_to_all_zones
from idf_objects.tempground.add_ground_temperatures import add_ground_temperatures
from idf_objects.other.zonelist import create_zonelist

# Output & simulation modules
from idf_objects.outputdef.assign_output_settings import assign_output_settings
from idf_objects.outputdef.add_output_definitions import add_output_definitions
from postproc.merge_results import merge_all_results
from epw.run_epw_sims import simulate_all

###############################################################################
# Global Default IDF Config
# (Override these via environment variables or main_config if needed.)
###############################################################################
idf_config = {
    "iddfile": "EnergyPlus/Energy+.idd",         # Default path to the IDD file
    "idf_file_path": "EnergyPlus/Minimal.idf",   # Default path to a minimal base IDF
    "output_dir": "output/output_IDFs"           # Default folder to save generated IDFs
}


def create_idf_for_building(
    building_row,
    building_index,
    scenario="scenario1",
    calibration_stage="pre_calibration",
    strategy="B",
    random_seed=42,
    # Geometry
    user_config_geom=None,
    assigned_geom_log=None,
    # Lighting
    user_config_lighting=None,
    assigned_lighting_log=None,
    # Electric equipment
    user_config_equipment=None,
    assigned_equip_log=None,
    # DHW
    user_config_dhw=None,
    assigned_dhw_log=None,
    # Fenestration
    res_data=None,
    nonres_data=None,
    assigned_fenez_log=None,
    # Window Shading
    user_config_shading=None,
    assigned_shading_log=None,
    # HVAC
    user_config_hvac=None,
    assigned_hvac_log=None,
    # Vent
    user_config_vent=None,
    assigned_vent_log=None,
    # Zone sizing
    assigned_setzone_log=None,
    # Ground temps
    assigned_groundtemp_log=None,
    # Output definitions
    output_definitions=None
):
    """
    Build an IDF for a single building, applying geometry, fenestration, window
    shading, lighting, HVAC, ventilation, zone sizing, ground temps, and user
    overrides.

    Returns
    -------
    out_path : str
        File path to the saved IDF.
    """
    # 1) Setup IDF from the minimal template
    IDF.setiddname(idf_config["iddfile"])
    idf = IDF(idf_config["idf_file_path"])

    # 2) Basic building object settings
    building_obj = idf.newidfobject("BUILDING")
    building_obj.Name = f"Sample_Building_{building_index}"

    orientation = building_row.get("building_orientation", 0.0)



    # for orientation correction this changed 
    #if not pd.isna(orientation):
    #    building_obj.North_Axis = orientation






    if pd.isna(orientation):
        orientation = 0.0

    # Apply orientation when creating geometry.  The BUILDING object's
    # North_Axis is kept at 0 so that the rotated geometry correctly
    # represents the building's orientation in the world coordinate system.
    building_obj.North_Axis = 0.0









    # 3) Create geometry
    if assigned_geom_log is not None and building_row.get("ogc_fid") not in assigned_geom_log:
        assigned_geom_log[building_row.get("ogc_fid")] = {}

    edge_types = []
    for side_col in ["north_side", "east_side", "south_side", "west_side"]:
        edge_types.append(building_row.get(side_col, "Facade"))

    create_building_with_roof_type(
        idf=idf,
        area=building_row.get("area", 100.0),
        perimeter=building_row.get("perimeter", 40.0),
        orientation=orientation,
        building_row=building_row,
        edge_types=edge_types,
        calibration_stage=calibration_stage,
        strategy=strategy,
        random_seed=random_seed,
        user_config=user_config_geom,
        assigned_geom_log=assigned_geom_log
    )

    # 4) Update materials & constructions
    construction_map = update_construction_materials(
        idf=idf,
        building_row=building_row,
        building_index=building_index,
        scenario=scenario,
        calibration_stage=calibration_stage,
        strategy=strategy,
        random_seed=random_seed,
        user_config_fenez=None,  # not used directly
        assigned_fenez_log=assigned_fenez_log
    )
    assign_constructions_to_surfaces(idf, construction_map)

    # Create zone list for convenience
    create_zonelist(idf, zonelist_name="ALL_ZONES")

    # 5) Fenestration
    add_fenestration(
        idf=idf,
        building_row=building_row,
        scenario=scenario,
        calibration_stage=calibration_stage,
        strategy=strategy,
        random_seed=random_seed,
        res_data=res_data,
        nonres_data=nonres_data,
        assigned_fenez_log=assigned_fenez_log
    )

    # 6) Window shading (e.g., blinds)
    add_shading_objects(
        idf=idf,
        building_row=building_row,
        strategy=strategy,
        random_seed=random_seed,
        user_config_shading=user_config_shading,
        assigned_shading_log=assigned_shading_log,
    )

    # 7) Lighting
    add_lights_and_parasitics(
        idf=idf,
        building_row=building_row,
        calibration_stage=calibration_stage,
        strategy=strategy,
        random_seed=random_seed,
        user_config=user_config_lighting,
        assigned_values_log=assigned_lighting_log
    )

    # 8) Electric equipment
    add_electric_equipment(
        idf=idf,
        building_row=building_row,
        calibration_stage=calibration_stage,
        strategy=strategy,
        random_seed=random_seed,
        user_config=user_config_equipment,
        assigned_values_log=assigned_equip_log,
        zonelist_name="ALL_ZONES",
    )
    # 9) DHW
    add_dhw_to_idf(
        idf=idf,
        building_row=building_row,
        calibration_stage=calibration_stage,
        strategy=strategy,
        random_seed=random_seed,
        name_suffix=f"MyDHW_{building_index}",
        user_config_dhw=user_config_dhw,
        assigned_dhw_log=assigned_dhw_log,
        use_nta=True
    )

    # 10) HVAC
    add_HVAC_Ideal_to_all_zones(
        idf=idf,
        building_row=building_row,
        calibration_stage=calibration_stage,
        strategy=strategy,
        random_seed=random_seed,
        user_config_hvac=user_config_hvac,
        assigned_hvac_log=assigned_hvac_log
    )

    # 11) Ventilation
    add_ventilation_to_idf(
        idf=idf,
        building_row=building_row,
        calibration_stage=calibration_stage,
        strategy=strategy,
        random_seed=random_seed,
        user_config_vent=user_config_vent,
        assigned_vent_log=assigned_vent_log,
        infiltration_model="weather",
    )

    # 12) Zone sizing
    add_outdoor_air_and_zone_sizing_to_all_zones(
        idf=idf,
        building_row=building_row,
        calibration_stage=calibration_stage,
        strategy=strategy,
        random_seed=random_seed,
        assigned_setzone_log=assigned_setzone_log
    )

    # 13) Ground temperatures
    add_ground_temperatures(
        idf=idf,
        calibration_stage=calibration_stage,
        strategy=strategy,
        random_seed=random_seed,
        assigned_groundtemp_log=assigned_groundtemp_log
    )

    # 14) Output definitions
    if output_definitions is None:
        output_definitions = {
            "desired_variables": ["Facility Total Electric Demand Power", "Zone Air Temperature"],
            "desired_meters": ["Electricity:Facility"],
            "override_variable_frequency": "Hourly",
            "override_meter_frequency": "Hourly",
            "include_tables": True,
            "include_summary": True
        }
    out_settings = assign_output_settings(
        desired_variables=output_definitions.get("desired_variables", []),
        desired_meters=output_definitions.get("desired_meters", []),
        override_variable_frequency=output_definitions.get("override_variable_frequency", "Hourly"),
        override_meter_frequency=output_definitions.get("override_meter_frequency", "Hourly"),
        include_tables=output_definitions.get("include_tables", True),
        include_summary=output_definitions.get("include_summary", True)
    )
    add_output_definitions(idf, out_settings)

    # 15) Save final IDF
    os.makedirs(idf_config["output_dir"], exist_ok=True)
    idf_filename = f"building_{building_index}.idf"
    out_path = os.path.join(idf_config["output_dir"], idf_filename)
    idf.save(out_path)
    print(f"[create_idf_for_building] IDF saved at: {out_path}")

    return out_path


def create_idfs_for_all_buildings(
    df_buildings,
    scenario="scenario1",
    calibration_stage="pre_calibration",
    strategy="B",
    random_seed=42,
    # partial user configs
    user_config_geom=None,
    user_config_lighting=None,
    user_config_equipment=None,
    user_config_dhw=None,
    res_data=None,
    nonres_data=None,
    user_config_shading=None,
    assigned_shading_log=None,
    user_config_hvac=None,
    user_config_vent=None,
    user_config_epw=None,  # pass epw config or list if relevant
    # output definitions
    output_definitions=None,
    # simulation & postprocess
    run_simulations=True,
    simulate_config=None,
    post_process=True,
    post_process_config=None,
    # NEW: Where to store logs and results
    logs_base_dir=None
):
    """
    Loops over df_buildings, calls create_idf_for_building for each building,
    optionally runs E+ simulations in parallel, and merges results if
    post_process=True. Window shading overrides can be passed via
    ``user_config_shading`` and logged to ``assigned_shading_log``.

    If logs_base_dir is provided, all assigned_*.csv and merged results go under that folder
    (e.g. logs_base_dir/assigned, logs_base_dir/Sim_Results, etc.).
    """
    logger = logging.getLogger(__name__)

    # A) Prepare dictionaries to store final picks for each module
    assigned_geom_log       = {}
    assigned_lighting_log   = {}
    assigned_equip_log      = {}
    assigned_dhw_log        = {}
    assigned_fenez_log      = {}
    assigned_hvac_log       = {}
    assigned_vent_log       = {}
    assigned_epw_log        = {}
    assigned_groundtemp_log = {}
    assigned_setzone_log    = {}
    assigned_shading_log    = {}

    # B) Create an IDF for each building
    for idx, row in df_buildings.iterrows():
        bldg_id = row.get("ogc_fid", idx)
        logger.info(f"--- Creating IDF for building index {idx}, ogc_fid={bldg_id} ---")

        idf_path = create_idf_for_building(
            building_row=row,
            building_index=idx,
            scenario=scenario,
            calibration_stage=calibration_stage,
            strategy=strategy,
            random_seed=random_seed,
            # geometry
            user_config_geom=user_config_geom,
            assigned_geom_log=assigned_geom_log,
            # lighting
            user_config_lighting=user_config_lighting,
            assigned_lighting_log=assigned_lighting_log,
            # electric equipment
            user_config_equipment=user_config_equipment,
            assigned_equip_log=assigned_equip_log,
            # DHW
            user_config_dhw=user_config_dhw,
            assigned_dhw_log=assigned_dhw_log,
            # Fenestration
            res_data=res_data,
            nonres_data=nonres_data,
            assigned_fenez_log=assigned_fenez_log,
            # Window shading
            user_config_shading=user_config_shading,
            assigned_shading_log=assigned_shading_log,
            # HVAC
            user_config_hvac=user_config_hvac,
            assigned_hvac_log=assigned_hvac_log,
            # Vent
            user_config_vent=user_config_vent,
            assigned_vent_log=assigned_vent_log,
            # zone sizing
            assigned_setzone_log=assigned_setzone_log,
            # ground temps
            assigned_groundtemp_log=assigned_groundtemp_log,
            # output definitions
            output_definitions=output_definitions
        )
        # Store the final IDF filename in df_buildings
        df_buildings.loc[idx, "idf_name"] = os.path.basename(idf_path)

    # C) If we’re told to run simulations
    if run_simulations:
        logger.info("[create_idfs_for_all_buildings] => Running simulations ...")
        if simulate_config is None:
            simulate_config = {}

        # Decide on a base_output_dir for sim results
        if logs_base_dir:
            sim_output_dir = os.path.join(logs_base_dir, "Sim_Results")
        else:
            sim_output_dir = simulate_config.get("base_output_dir", "output/Sim_Results")

        idf_directory = idf_config["output_dir"]
        iddfile       = idf_config["iddfile"]

        simulate_all(
            df_buildings=df_buildings,
            idf_directory=idf_directory,
            iddfile=iddfile,
            base_output_dir=sim_output_dir,
            user_config_epw=user_config_epw,
            assigned_epw_log=assigned_epw_log,
            num_workers=simulate_config.get("num_workers", 4)
            # ep_force_overwrite=simulate_config.get("ep_force_overwrite", False)
        )

    # D) Post-processing
    if post_process:
        logger.info("[create_idfs_for_all_buildings] => Post-processing results & writing logs ...")

        if post_process_config is None:
            post_process_config = {
                "base_output_dir": "output/Sim_Results",
                "outputs": [
                    {
                        "convert_to_daily": False,
                        "convert_to_monthly": False,
                        "aggregator": "none",
                        "output_csv": "output/results/merged_as_is.csv"
                    }
                ]
            }

        # If logs_base_dir is set, we override base_output_dir
        if logs_base_dir:
            post_process_config["base_output_dir"] = os.path.join(logs_base_dir, "Sim_Results")

        base_output_dir = post_process_config.get("base_output_dir", "output/Sim_Results")
        multiple_outputs = post_process_config.get("outputs", [])

        # Possibly handle multiple post-process outputs
        for proc_item in multiple_outputs:
            convert_daily = proc_item.get("convert_to_daily", False)
            convert_monthly = proc_item.get("convert_to_monthly", False)
            aggregator = proc_item.get("aggregator", "mean")  # daily aggregator
            out_csv = proc_item.get("output_csv", "output/results/merged_default.csv")

            # If logs_base_dir is set and the out_csv is still something like "output/results/..."
            # We can relocate it under logs_base_dir, e.g. logs_base_dir/results
            # Let's do a check:
            if logs_base_dir and "output/" in out_csv:
                # redirect to logs_base_dir
                # e.g. logs_base_dir/results/merged_default.csv
                # you can pick your subfolder naming
                rel_filename = out_csv.split("output/")[-1]  # e.g. results/merged_default.csv
                out_csv = os.path.join(logs_base_dir, rel_filename)

            # Make sure directory exists
            os.makedirs(os.path.dirname(out_csv), exist_ok=True)

            # Now merge the results
            merge_all_results(
                base_output_dir=base_output_dir,
                output_csv=out_csv,
                convert_to_daily=convert_daily,
                daily_aggregator=aggregator,
                convert_to_monthly=convert_monthly
            )

        # Write CSV logs for assigned parameters
        _write_geometry_csv(assigned_geom_log, logs_base_dir)
        _write_lighting_csv(assigned_lighting_log, logs_base_dir)
        _write_equipment_csv(assigned_equip_log, logs_base_dir)
        _write_fenestration_csv(assigned_fenez_log, logs_base_dir)
        _write_dhw_csv(assigned_dhw_log, logs_base_dir)
        _write_hvac_csv(assigned_hvac_log, logs_base_dir)
        _write_vent_csv(assigned_vent_log, logs_base_dir)
        _write_shading_csv(assigned_shading_log, logs_base_dir)
        # (If needed, also EPW or groundtemp logs, do similarly)

        logger.info("[create_idfs_for_all_buildings] => Done post-processing.")

    return df_buildings  # includes "idf_name" column


###############################################################################
# Internal Helper Functions to Write Assigned Logs
# -- Now accept logs_base_dir so we can place them in job_output_dir
###############################################################################
def _make_assigned_path(filename, logs_base_dir):
    """Helper to build the path for assigned_*.csv, given logs_base_dir."""
    if logs_base_dir:
        assigned_dir = os.path.join(logs_base_dir, "assigned")
    else:
        assigned_dir = "output/assigned"

    os.makedirs(assigned_dir, exist_ok=True)
    return os.path.join(assigned_dir, filename)


def _write_geometry_csv(assigned_geom_log, logs_base_dir):
    rows = []
    for bldg_id, param_dict in assigned_geom_log.items():
        for param_name, param_val in param_dict.items():
            rows.append({
                "ogc_fid": bldg_id,
                "param_name": param_name,
                "assigned_value": param_val
            })
    if not rows:
        return
    df = pd.DataFrame(rows)
    out_path = _make_assigned_path("assigned_geometry.csv", logs_base_dir)
    df.to_csv(out_path, index=False)


def _write_lighting_csv(assigned_lighting_log, logs_base_dir):
    rows = []
    for bldg_id, param_dict in assigned_lighting_log.items():
        for param_name, subdict in param_dict.items():
            assigned_val = subdict.get("assigned_value")
            min_v = subdict.get("min_val")
            max_v = subdict.get("max_val")
            obj_name = subdict.get("object_name", "")
            rows.append({
                "ogc_fid": bldg_id,
                "object_name": obj_name,
                "param_name": param_name,
                "assigned_value": assigned_val,
                "min_val": min_v,
                "max_val": max_v
            })
    if not rows:
        return
    df = pd.DataFrame(rows)
    out_path = _make_assigned_path("assigned_lighting.csv", logs_base_dir)
    df.to_csv(out_path, index=False)


def _write_fenestration_csv(assigned_fenez_log, logs_base_dir):
    rows = []
    for bldg_id, param_dict in assigned_fenez_log.items():
        for key, val in param_dict.items():
            rows.append({
                "ogc_fid": bldg_id,
                "param_name": key,
                "assigned_value": val
            })
    if not rows:
        return
    df = pd.DataFrame(rows)
    out_path = _make_assigned_path("assigned_fenez_params.csv", logs_base_dir)
    df.to_csv(out_path, index=False)


def _write_dhw_csv(assigned_dhw_log, logs_base_dir):
    rows = []
    for bldg_id, param_dict in assigned_dhw_log.items():
        for param_name, param_val in param_dict.items():
            rows.append({
                "ogc_fid": bldg_id,
                "param_name": param_name,
                "assigned_value": param_val
            })
    if not rows:
        return
    df = pd.DataFrame(rows)
    out_path = _make_assigned_path("assigned_dhw_params.csv", logs_base_dir)
    df.to_csv(out_path, index=False)


def _write_hvac_csv(assigned_hvac_log, logs_base_dir):
    rows = []
    for bldg_id, param_dict in assigned_hvac_log.items():
        for param_name, param_val in param_dict.items():
            rows.append({
                "ogc_fid": bldg_id,
                "param_name": param_name,
                "assigned_value": param_val
            })
    if not rows:
        return
    df = pd.DataFrame(rows)
    out_path = _make_assigned_path("assigned_hvac_params.csv", logs_base_dir)
    df.to_csv(out_path, index=False)


def _write_vent_csv(assigned_vent_log, logs_base_dir):
    rows = []
    for bldg_id, param_dict in assigned_vent_log.items():
        for param_name, param_val in param_dict.items():
            rows.append({
                "ogc_fid": bldg_id,
                "param_name": param_name,
                "assigned_value": param_val
            })
    if not rows:
        return
    df = pd.DataFrame(rows)
    out_path = _make_assigned_path("assigned_ventilation.csv", logs_base_dir)
    df.to_csv(out_path, index=False)


def _write_equipment_csv(assigned_equip_log, logs_base_dir):
    """Write ``assigned_equipment.csv`` in the same style as lighting.

    ``assigned_equip_log`` is produced by ``assign_equipment_parameters`` and
    stores a nested ``"assigned"`` dictionary for each building.  Each
    parameter entry contains ``object_name``, ``assigned_value``, ``min_val`` and
    ``max_val``.  We mirror ``_write_lighting_csv`` so that downstream scenario
    functions can expect the same columns.
    """

    rows = []
    for bldg_id, param_dict in assigned_equip_log.items():
        # Older logs might only contain the inner dict.  Default to that format
        assigned = param_dict.get("assigned", param_dict)
        for param_name, subdict in assigned.items():
            rows.append({
                "ogc_fid": bldg_id,
                "object_name": subdict.get("object_name", ""),
                "param_name": param_name,
                "assigned_value": subdict.get("assigned_value"),
                "min_val": subdict.get("min_val"),
                "max_val": subdict.get("max_val"),
            })
    if not rows:
        return
    df = pd.DataFrame(rows)
    out_path = _make_assigned_path("assigned_equipment.csv", logs_base_dir)
    df.to_csv(out_path, index=False)


def _write_shading_csv(assigned_shading_log, logs_base_dir):
    """Write ``assigned_shading_params.csv`` from ``assigned_shading_log``."""
    rows = []
    for window_id, param_dict in assigned_shading_log.items():
        shading_params = param_dict.get("shading_params", param_dict)
        for param_name, param_val in shading_params.items():
            rows.append({
                "window_id": window_id,
                "param_name": param_name,
                "assigned_value": param_val,
            })
    if not rows:
        return
    df = pd.DataFrame(rows)
    out_path = _make_assigned_path("assigned_shading_params.csv", logs_base_dir)
    df.to_csv(out_path, index=False)

------------------------------------------------------------

