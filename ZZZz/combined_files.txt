File: D:\Documents\E_Plus_2030_py\idf_objects\wshading\assign_shading_values.py
============================================================
"""
assign_shading_values.py

This module picks the final shading parameters from shading_lookup.py
and optionally user overrides or Excel-based rules. The actual creation
of EnergyPlus objects (e.g. WindowMaterial:Blind, Shading:Building:Detailed, etc.)
will happen in another file (e.g. create_shading_objects.py).
"""

import random
import logging
from .shading_lookup import shading_lookup # Assuming shading_lookup.py is in the same directory

# Configure logger for this module
logger = logging.getLogger(__name__)
# Set a default logging level if no handlers are configured by the main application
# This prevents "No handler found" warnings and allows debug messages to be seen if
# the main app configures logging at DEBUG level for this logger or a parent.
if not logger.hasHandlers():
    # BasicConfig should ideally be called only once at the application entry point.
    # If called here, it might affect other modules' logging if they haven't set up their own.
    # For library code, it's often better to let the application configure logging.
    # However, for debugging during development, this can be helpful.
    # logging.basicConfig(level=logging.DEBUG, format='[%(asctime)s] %(levelname)s - %(name)s - %(message)s')
    # A less intrusive way for a library module:
    # logger.addHandler(logging.NullHandler())
    # For active debugging, let's assume we want to see the messages if the root logger is set to DEBUG.
    pass


def pick_val_from_range(rng_tuple, strategy="A", param_name_for_log="<unknown_param>"):
    """
    Helper function to pick a numeric value from a (min_val, max_val) tuple.

    - If strategy="A", picks the midpoint.
    - If strategy="B", picks a random value in [min_val, max_val].
    - Otherwise (e.g., strategy="C" or any other string), picks min_val.

    Parameters
    ----------
    rng_tuple : tuple or None
        A tuple of two numeric values (min_val, max_val) or None.
    strategy : str, optional
        The strategy to use for picking the value ("A", "B", or other). Defaults to "A".
    param_name_for_log : str, optional
        Name of the parameter this range belongs to, for logging.

    Returns
    -------
    float or int or None
        The picked numeric value, or None if input is invalid or values are missing.
    """
    logger.debug(f"pick_val_from_range called for '{param_name_for_log}' with range: {rng_tuple}, strategy: '{strategy}'")

    if not rng_tuple or not isinstance(rng_tuple, tuple) or len(rng_tuple) != 2:
        if rng_tuple is not None:
             logger.warning(f"Invalid rng_tuple for '{param_name_for_log}': {rng_tuple}. Expected a 2-element tuple or None.")
        else:
             logger.debug(f"rng_tuple for '{param_name_for_log}' is None.")
        return None

    min_val, max_val = rng_tuple

    if min_val is None and max_val is None:
        logger.debug(f"Both min_val and max_val are None for '{param_name_for_log}'. Returning None.")
        return None
    if min_val is None:
        logger.debug(f"min_val is None for '{param_name_for_log}', returning max_val: {max_val}")
        return max_val
    if max_val is None:
        logger.debug(f"max_val is None for '{param_name_for_log}', returning min_val: {min_val}")
        return min_val

    if not all(isinstance(v, (int, float)) for v in [min_val, max_val]):
        logger.warning(f"Non-numeric values in rng_tuple for '{param_name_for_log}': {rng_tuple}. Cannot pick value.")
        return None

    chosen_value = None
    if min_val == max_val:
        chosen_value = min_val
        logger.debug(f"min_val equals max_val for '{param_name_for_log}'. Picked: {chosen_value}")
    elif min_val > max_val:
        logger.warning(
            f"For '{param_name_for_log}', min_val ({min_val}) is greater than max_val ({max_val}). "
            f"Using min_val ({min_val}) as the value, as random.uniform requires min <= max."
        )
        # Defaulting to min_val in this swapped case, or could swap them if strategy 'B' is critical.
        # For strategy 'A', midpoint would be calculated on swapped values.
        # For safety and predictability with strategy 'B', let's just pick min_val.
        chosen_value = min_val # Or swap: temp_min, temp_max = max_val, min_val
    else:
        if strategy == "A":
            chosen_value = 0.5 * (min_val + max_val)
            logger.debug(f"Strategy 'A' (midpoint) for '{param_name_for_log}'. Picked: {chosen_value}")
        elif strategy == "B":
            chosen_value = random.uniform(min_val, max_val)
            logger.debug(f"Strategy 'B' (random) for '{param_name_for_log}'. Picked: {chosen_value}")
        else: # Default or other strategies pick min_val
            chosen_value = min_val
            logger.debug(f"Strategy '{strategy}' (default/min_val) for '{param_name_for_log}'. Picked: {chosen_value}")
    
    return chosen_value

def pick_shading_params(
    window_id, 
    shading_type_key="my_external_louvers",
    strategy="A",
    user_config=None, # This should be specific to the shading_type_key
    assigned_shading_log=None
):
    """
    1) Looks up default shading parameters from shading_lookup[shading_type_key].
    2) If user_config is provided, overrides or adjusts some values.
    3) Based on 'strategy', picks final numeric values from any ranges.
    4) Optionally logs the final picks in assigned_shading_log.

    Parameters (same as before) ...

    Returns
    -------
    dict
        A dictionary of final shading parameters with single numeric values.
        Returns an empty dictionary if base_params for shading_type_key are not found.
    """
    logger.debug(f"pick_shading_params called for window_id: '{window_id}', shading_type_key: '{shading_type_key}', strategy: '{strategy}'")
    
    base_params = shading_lookup.get(shading_type_key)
    if not base_params:
        logger.error(f"Shading type key '{shading_type_key}' not found in shading_lookup.")
        if assigned_shading_log is not None and window_id is not None:
            if window_id not in assigned_shading_log:
                assigned_shading_log[window_id] = {}
            assigned_shading_log[window_id]["shading_params_error"] = f"Key '{shading_type_key}' not in lookup."
        return {}
    
    logger.debug(f"Base parameters for '{shading_type_key}' from lookup: {base_params}")

    # Start with a copy of base_params. Using dict() creates a shallow copy.
    final_params = dict(base_params)

    # 2) Apply user overrides
    if user_config and isinstance(user_config, dict):
        logger.debug(f"Applying user_config for '{shading_type_key}': {user_config}")
        for key, override_val in user_config.items():
            if key in final_params:
                logger.debug(f"  Overriding '{key}': from '{final_params[key]}' to '{override_val}'")
            else:
                logger.debug(f"  Adding new param '{key}' with value '{override_val}'")
            final_params[key] = override_val
    else:
        logger.debug(f"No user_config provided or it's not a dict for '{shading_type_key}'.")

    logger.debug(f"Parameters after applying user_config (before range picking) for '{shading_type_key}': {final_params}")

    # 3) Convert all "*_range" fields to single numeric picks
    #    Also, if a non-range field was overridden with a tuple by user_config,
    #    and we want to interpret that as a range to be picked, this logic needs to be robust.
    #    Current logic primarily acts on keys explicitly ending with "_range".
    
    processed_params = {} # Store picked values here
    # Iterate over a copy of keys if modifying the dictionary during iteration (though here we build a new one)
    
    for field_key in list(final_params.keys()): # list() for a stable copy of keys
        field_val = final_params[field_key]
        
        if field_key.endswith("_range"):
            param_name_base = field_key[:-6]  # remove "_range" suffix
            
            if isinstance(field_val, tuple): # It's a range, pick a value
                logger.debug(f"  Processing range field '{field_key}' with value {field_val}")
                chosen_val = pick_val_from_range(field_val, strategy=strategy, param_name_for_log=field_key)
                if chosen_val is not None:
                    processed_params[param_name_base] = chosen_val
                    logger.debug(f"    Picked value for '{param_name_base}': {chosen_val}")
                else:
                    # If pick_val_from_range returns None, param_name_base won't be in processed_params.
                    # This means it will be missing from the final output if not set otherwise.
                    logger.warning(f"    Could not pick value for '{field_key}' (value: {field_val}) for {shading_type_key}. Parameter '{param_name_base}' will be missing or use its non-range value if one exists.")
                
                # Remove the original _range key from final_params as we've processed it into processed_params
                # However, it's safer to build up processed_params and then update final_params,
                # or construct a completely new dictionary for the return.
                # Let's remove it from the original `final_params` copy to avoid confusion later.
                # final_params.pop(field_key, None) # This was modifying during iteration if not on list(final_params.keys())
            else: 
                # Field ends with _range but isn't a tuple (e.g., overridden by a single value)
                logger.warning(f"  Field '{field_key}' for {shading_type_key} ends with '_range' but is not a tuple: {field_val}. Using value directly for '{param_name_base}'.")
                processed_params[param_name_base] = field_val
                # final_params.pop(field_key, None)
        else:
            # This is a non-range key. Keep its value as is from final_params.
            # These will be merged with picked range values.
            # If a user overrode 'slat_width' with a tuple e.g. ("slat_width": (0.1,0.2))
            # and it's NOT slat_width_range, it would remain a tuple here.
            # The current design expects explicit _range suffix for picking.
            processed_params[field_key] = field_val
            logger.debug(f"  Keeping non-range field '{field_key}' with value: {field_val}")


    # The `processed_params` dictionary now contains all original non-range parameters
    # and the processed (picked) values for the range parameters.
    # This becomes the new `final_params`.
    final_params_picked = processed_params

    logger.debug(f"Final processed parameters for '{shading_type_key}' (after range picking): {final_params_picked}")

    # 4) Log if needed
    if assigned_shading_log is not None and window_id is not None:
        if window_id not in assigned_shading_log:
            assigned_shading_log[window_id] = {}
        # Store a copy of the final picked parameters
        assigned_shading_log[window_id]["shading_params_picked"] = dict(final_params_picked)
        assigned_shading_log[window_id]["shading_type_key_used"] = shading_type_key
        assigned_shading_log[window_id]["strategy_used"] = strategy
        logger.debug(f"Logged final picked parameters for window_id '{window_id}'")

    return final_params_picked

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\wshading\shading_lookup.py
============================================================
"""
shading_lookup.py

Contains default (hardcoded) shading parameters for different blind types,
overhangs, louvers, etc. This is analogous to geometry_lookup.py or
materials_lookup.py, storing dictionary-based defaults.

Each key in the `shading_lookup` dictionary represents a specific type of shading.
The associated value is a dictionary of its parameters. Parameters intended
to be a range (min, max) from which a value will be picked should have a
key ending with "_range".

Example:
  "slat_width_range": (0.025, 0.050)  # Slat width can be between 0.025m and 0.050m

Values for these ranges will be selected by the `pick_val_from_range` function
in `assign_shading_values.py` based on the chosen strategy (e.g., midpoint, random).
"""

shading_lookup = {
    # Example: external horizontal louvers/blinds
    "my_external_louvers": {
        # This name will be used as a base for the EnergyPlus WindowMaterial:Blind object name
        "blind_name": "MyExternalLouvers",
        "slat_orientation": "Horizontal", # Or "Vertical"
        "slat_width_range": (0.025, 0.025), # Slat width in meters
        "slat_separation_range": (0.020, 0.020), # Slat separation (distance between front of one slat and next) in meters
        "slat_thickness_range": (0.001, 0.001), # Slat thickness in meters
        "slat_angle_deg_range": (45.0, 45.0), # Slat angle in degrees (0=horizontal, 90=vertical profile)
        "slat_conductivity_range": (160.0, 160.0), # Slat conductivity in W/m-K (e.g., for aluminum)

        # Solar trans/reflect properties (beam & diffuse):
        # These are for the slat material itself.
        "slat_beam_solar_transmittance_range": (0.0, 0.0), # Fraction of beam solar radiation transmitted directly through slat
        "slat_beam_solar_reflectance_range": (0.7, 0.7), # Fraction of beam solar radiation reflected by front/back of slat (assumed same for front/back here)
        "slat_diffuse_solar_transmittance_range": (0.0, 0.0),# Fraction of diffuse solar radiation transmitted directly through slat
        "slat_diffuse_solar_reflectance_range": (0.7, 0.7), # Fraction of diffuse solar radiation reflected by front/back of slat (assumed same for front/back here)

        # Visible trans/reflect properties (beam & diffuse):
        "slat_beam_visible_transmittance_range": (0.0, 0.0),
        "slat_beam_visible_reflectance_range": (0.7, 0.7), # Assumed same for front/back here
        "slat_diffuse_visible_transmittance_range": (0.0, 0.0),
        "slat_diffuse_visible_reflectance_range": (0.7, 0.7), # Assumed same for front/back here

        # IR / emissivity properties
        "slat_ir_transmittance_range": (0.0, 0.0), # Infrared transmittance of slat material
        "slat_ir_emissivity_range": (0.9, 0.9), # Infrared emissivity of slat material (assumed same for front/back here)

        # Blind geometry offsets and details
        "blind_to_glass_distance_range": (0.05, 0.05), # Distance from glazing to blind in meters (positive for exterior, negative for interior)
        
        # Slat_Opening_Multiplier for WindowMaterial:Blind (EnergyPlus has only one such field)
        # This replaces the previous four (top, bottom, left, right) multipliers for this specific blind type
        # to better align with the E+ WindowMaterial:Blind object.
        # The value 0.5 is chosen as it appeared in your sample IDF output. Adjust if another default is preferred.
        "slat_opening_multiplier_range": (0.5, 0.5), # Multiplier for air flow opening (0.0 = no opening, 0.5 = half open, 1.0 = fully open based on slat separation)

        # Slat angle limits (if dynamic control is used, not directly used by fixed angle in WindowMaterial:Blind)
        "slat_angle_min_deg_range": (0.0, 0.0), # Minimum slat angle in degrees
        "slat_angle_max_deg_range": (90.0, 90.0), # Maximum slat angle in degrees (some systems might go to 180)

        # For Shading:Building:Detailed type objects (if this key were for an overhang/fin)
        # These are examples and would typically be in a different lookup entry specific to those shading types.
        # "overhang_depth_range": (0.5, 1.0), 
        # "fin_depth_range": (0.3, 0.6),      
    },

    # Example: interior roller blind (dark)
    "my_interior_roller_blind_dark": {
        "blind_name": "InteriorRollerDark",
        "slat_orientation": "Horizontal", # Roller blinds are effectively horizontal slats of fabric
        # For a roller blind, "slat width" and "slat separation" are less about individual slats 
        # and more about the fabric properties when deployed. 
        # The E+ WindowMaterial:Blind model still uses these terms.
        # A "fully closed" roller blind effectively has slat width = separation if modeled as slats.
        # Thickness is the fabric thickness. Angle is 0 when flat.
        "slat_width_range": (0.05, 0.05), # Effective width; can be small if considering it as a continuous sheet.
        "slat_separation_range": (0.05, 0.05), # Effective separation
        "slat_thickness_range": (0.0005, 0.0005), # Fabric thickness
        "slat_angle_deg_range": (0.0, 0.0), # Always flat when down for a roller blind
        "slat_conductivity_range": (0.1, 0.1), # Fabric conductivity

        "slat_beam_solar_transmittance_range": (0.05, 0.05),
        "slat_beam_solar_reflectance_range": (0.1, 0.1),
        "slat_diffuse_solar_transmittance_range": (0.05, 0.05),
        "slat_diffuse_solar_reflectance_range": (0.1, 0.1),

        "slat_beam_visible_transmittance_range": (0.03, 0.03),
        "slat_beam_visible_reflectance_range": (0.05, 0.05),
        "slat_diffuse_visible_transmittance_range": (0.03, 0.03),
        "slat_diffuse_visible_reflectance_range": (0.05, 0.05),

        "slat_ir_transmittance_range": (0.0, 0.0),
        "slat_ir_emissivity_range": (0.85, 0.85),

        "blind_to_glass_distance_range": (-0.03, -0.03), # Negative for interior
        "slat_opening_multiplier_range": (0.0, 0.0), # Typically 0 for a closed roller blind (no gaps)
    },

    # Add more predefined shading “types” here as needed, for example:
    # "my_vertical_fins": {
    #     "shading_element_name": "VerticalFinSystem", # Generic name for the element
    #     "fin_depth_range": (0.3, 0.5),          # Depth of fins in meters
    #     "fin_spacing_range": (0.5, 0.7),        # Spacing between fins in meters
    #     "fin_height_or_length": "WindowHeight", # Placeholder, could be numeric or a keyword
    #     "fin_offset_from_window_edge_range": (0.0, 0.1) # Offset from the side of the window
    #     # ... other relevant geometric or material properties
    #     # Note: Geometric shading like fins/overhangs are typically Shading:Building:Detailed
    #     # or Shading:Zone:Detailed and don't use WindowMaterial:Blind parameters.
    # },
    # "my_fixed_overhang": {
    #     "shading_element_name": "FixedBuildingOverhang",
    #     "overhang_depth_range": (0.5, 1.2),       # Projection depth in meters
    #     "overhang_width_or_length": "WindowWidthPlusExtensions", # Placeholder
    #     "overhang_height_above_window_top_range": (0.0, 0.2) # Height above window top
    #     # ... other relevant geometric or material properties
    # },
}
------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\wshading\create_shading_objects.py
============================================================
"""
create_shading_objects.py

This module creates EnergyPlus shading objects in the IDF
(e.g., WindowMaterial:Blind, WindowShadingControl,
 Shading:Building:Detailed, schedules, etc.).

It calls pick_shading_params(...) from assign_shading_values.py
to get final numeric parameter values. You can pass user/Excel overrides
to customize these parameters.

Usage:
  from idf_objects.wshading.create_shading_objects import add_shading_objects

  add_shading_objects(
      idf=idf,
      building_row=some_dict, # Or other context identifier
      shading_type_key="my_external_louvers",
      strategy="A", # Or "B"
      random_seed=42,
      user_config_shading=shading_overrides_for_this_type, # Dict of overrides for this specific shading_type_key
      assigned_shading_log=shading_log_dict,
      create_blinds=True,
      create_geometry_shading=False
  )
"""

import random
import logging
from .assign_shading_values import pick_shading_params

logger = logging.getLogger(__name__)
# Configure logger if not already configured by the main application
if not logger.hasHandlers():
    logging.basicConfig(level=logging.INFO, format='[%(asctime)s] %(levelname)s - %(name)s - %(message)s')


def add_shading_objects(
    idf,
    building_row,  # Used for context, e.g., if shading depends on building properties
    shading_type_key="my_external_louvers",
    strategy="A",
    random_seed=42,
    user_config_shading=None,
    assigned_shading_log=None,
    create_blinds=True,
    create_geometry_shading=False,
):
    """
    Creates the necessary shading objects in the IDF: e.g. WindowMaterial:Blind,
    WindowShadingControl, or geometry-based Shading:Building:Detailed.

    1) Loops over fenestration surfaces (if creating blinds per window) or processes
       once for global shading elements.
    2) Calls pick_shading_params(...) to get final numeric values (slat angles, etc.).
    3) Creates EnergyPlus shading devices (e.g., WindowMaterial:Blind + ShadingControl).
    4) Optionally, creates an E+ schedule if dynamic shading is needed (example provided).
    5) Optionally, creates Shading:Building:Detailed geometry if requested.

    Parameters
    ----------
    idf : IDF object
        The IDF object (e.g., from geomeppy or eppy) where new objects will be added.
    building_row : dict or pandas.Series or object
        Contextual data for the building/element being processed. Can be used to
        derive window IDs or influence shading choices if needed.
    shading_type_key : str
        Key in shading_lookup (from shading_lookup.py) to define the base shading
        parameters, e.g., "my_external_louvers".
    strategy : str
        Strategy for picking values from ranges ("A" for midpoint, "B" for random,
        other for min_val). Passed to pick_shading_params.
    random_seed : int, optional
        Seed for random number generation if strategy="B". Defaults to 42.
    user_config_shading : dict or None
        A dictionary of overrides for the specified `shading_type_key`.
        E.g., {"slat_angle_deg_range": (30, 60), "slat_width": 0.05}.
        These are applied on top of `shading_lookup` defaults.
    assigned_shading_log : dict or None
        If provided, final shading params are stored here. Keys could be window_id
        or another relevant identifier.
    create_blinds : bool
        If True, attempts to create blind-based shading objects (WindowMaterial:Blind
        + WindowShadingControl) for fenestration surfaces.
    create_geometry_shading : bool
        If True, attempts to create Shading:Building:Detailed geometry-based shading
        (e.g., overhangs), using an example function.
    """
    if random_seed is not None:
        random.seed(random_seed)

    if not idf:
        logger.error("IDF object is None. Cannot add shading objects.")
        return

    logger.info(f"Starting add_shading_objects for shading_type_key: '{shading_type_key}'")

    # --- Create Blind Shading for Fenestration Surfaces ---
    if create_blinds:
        logger.info("Attempting to create blind shading for fenestration surfaces.")
        try:
            # Ensure 'FENESTRATIONSURFACE:DETAILED' key exists in idf.idfobjects
            fen_surfaces = idf.idfobjects.get("FENESTRATIONSURFACE:DETAILED", [])
            if not fen_surfaces:
                logger.warning(
                    "No 'FENESTRATIONSURFACE:DETAILED' objects found in IDF. Skipping blind creation."
                )
            else:
                logger.info(f"Found {len(fen_surfaces)} FENESTRATIONSURFACE:DETAILED objects to process.")
        except Exception as e: # Catch broader exceptions if idf.idfobjects itself is problematic
            logger.error(
                f"Could not retrieve FENESTRATIONSURFACE:DETAILED from IDF: {e}", exc_info=True
            )
            fen_surfaces = []

        for fen_idx, fen_surface_obj in enumerate(fen_surfaces):
            fen_name_attr = getattr(fen_surface_obj, "Name", None)
            # Use a more robust default name if the actual name is missing or empty
            window_id = fen_name_attr if fen_name_attr and fen_name_attr.strip() else f"FenSurface_Unnamed_{fen_idx}"
            
            logger.info(f"Processing fenestration surface: '{window_id}' (Index: {fen_idx})")

            try:
                # 1) Pick shading params (combines shading_lookup + user overrides)
                logger.debug(f"[{window_id}] Picking shading parameters with key '{shading_type_key}' and strategy '{strategy}'.")
                shading_params = pick_shading_params(
                    window_id=window_id,  # Used for logging within pick_shading_params
                    shading_type_key=shading_type_key,
                    strategy=strategy,
                    user_config=user_config_shading,  # Pass the specific overrides for this type
                    assigned_shading_log=assigned_shading_log,
                )

                if not shading_params:
                    logger.warning(
                        f"[{window_id}] No shading parameters resolved for key '{shading_type_key}'. Skipping blind creation for this window."
                    )
                    if assigned_shading_log is not None:
                        if window_id not in assigned_shading_log:
                            assigned_shading_log[window_id] = {}
                        assigned_shading_log[window_id]["shading_creation_status"] = f"Failed: No params for key {shading_type_key}"
                    continue

                logger.debug(f"[{window_id}] Resolved shading parameters: {shading_params}")

                # 2) Create or retrieve a WindowMaterial:Blind object
                base_blind_material_name_from_params = shading_params.get("blind_name", "DefaultBlindMaterial")
                # Ensure blind_mat_name is valid for E+ (no spaces, etc.)
                blind_mat_name = f"{base_blind_material_name_from_params}_{window_id.replace(' ', '_').replace(':', '_')}"
                
                logger.debug(f"[{window_id}] Target WindowMaterial:Blind name: '{blind_mat_name}'")

                existing_blind_mats_objects = idf.idfobjects.get("WINDOWMATERIAL:BLIND", [])
                blind_mat = next((bm for bm in existing_blind_mats_objects if getattr(bm, 'Name', None) == blind_mat_name), None)

                if blind_mat:
                    logger.info(
                        f"[{window_id}] WindowMaterial:Blind '{blind_mat_name}' already exists. Reusing."
                    )
                else:
                    logger.info(f"[{window_id}] Creating new WindowMaterial:Blind '{blind_mat_name}'.")
                    blind_mat = idf.newidfobject("WINDOWMATERIAL:BLIND")
                    blind_mat.Name = blind_mat_name

                    # --- Assign common blind material properties with defaults ---
                    blind_mat.Slat_Orientation = shading_params.get("slat_orientation", "Horizontal")
                    blind_mat.Slat_Width = shading_params.get("slat_width", 0.025)
                    blind_mat.Slat_Separation = shading_params.get("slat_separation", 0.020)
                    blind_mat.Slat_Thickness = shading_params.get("slat_thickness", 0.001)
                    blind_mat.Slat_Angle = shading_params.get("slat_angle_deg", 45.0) # This is for the material definition, not control
                    blind_mat.Slat_Conductivity = shading_params.get("slat_conductivity", 160.0)

                    # --- Optical Properties (ensure defaults if params are missing) ---
                    sbsr = shading_params.get("slat_beam_solar_reflectance", 0.7)
                    sdsr = shading_params.get("slat_diffuse_solar_reflectance", 0.7)
                    sbvr = shading_params.get("slat_beam_visible_reflectance", 0.7)
                    sdvr = shading_params.get("slat_diffuse_visible_reflectance", 0.7)
                    sir_em = shading_params.get("slat_ir_emissivity", 0.9)

                    blind_mat.Slat_Beam_Solar_Transmittance = shading_params.get("slat_beam_solar_transmittance", 0.0)
                    blind_mat.Front_Side_Slat_Beam_Solar_Reflectance = sbsr
                    blind_mat.Back_Side_Slat_Beam_Solar_Reflectance = shading_params.get("back_side_slat_beam_solar_reflectance", sbsr)

                    blind_mat.Slat_Diffuse_Solar_Transmittance = shading_params.get("slat_diffuse_solar_transmittance", 0.0)
                    blind_mat.Front_Side_Slat_Diffuse_Solar_Reflectance = sdsr
                    blind_mat.Back_Side_Slat_Diffuse_Solar_Reflectance = shading_params.get("back_side_slat_diffuse_solar_reflectance", sdsr)

                    blind_mat.Slat_Beam_Visible_Transmittance = shading_params.get("slat_beam_visible_transmittance", 0.0)
                    blind_mat.Front_Side_Slat_Beam_Visible_Reflectance = sbvr
                    blind_mat.Back_Side_Slat_Beam_Visible_Reflectance = shading_params.get("back_side_slat_beam_visible_reflectance", sbvr)

                    blind_mat.Slat_Diffuse_Visible_Transmittance = shading_params.get("slat_diffuse_visible_transmittance", 0.0)
                    blind_mat.Front_Side_Slat_Diffuse_Visible_Reflectance = sdvr
                    blind_mat.Back_Side_Slat_Diffuse_Visible_Reflectance = shading_params.get("back_side_slat_diffuse_visible_reflectance", sdvr)
                    
                    blind_mat.Slat_Infrared_Hemispherical_Transmittance = shading_params.get("slat_ir_transmittance", 0.0)
                    blind_mat.Front_Side_Slat_Infrared_Hemispherical_Emissivity = sir_em
                    blind_mat.Back_Side_Slat_Infrared_Hemispherical_Emissivity = shading_params.get("back_side_slat_ir_emissivity", sir_em)
                    
                    # --- Standard Optional Fields for WindowMaterial:Blind ---
                    if "blind_to_glass_distance" in shading_params: # E+ Field: Distance_between_Slat_and_Glazing
                        blind_mat.Distance_between_Slat_and_Glazing = shading_params["blind_to_glass_distance"]
                    
                    # E+ Field: Slat_Opening_Multiplier. Uses 'slat_opening_multiplier' from updated lookup/params.
                    # Default to 0.5 if not found, which was in the IDF.
                    slat_opening_mult = shading_params.get("slat_opening_multiplier", 0.5) 
                    blind_mat.Slat_Opening_Multiplier = slat_opening_mult
                    
                    # Minimum_Output_Signal and Maximum_Output_Signal are not typically set directly unless complex control.
                    # The fields "Minimum Slat Angle" and "Maximum Slat Angle" are NOT part of WindowMaterial:Blind.
                    # They are part of WindowShadingControl for certain control types.

                    logger.debug(f"[{window_id}] Successfully created/configured WindowMaterial:Blind '{blind_mat.Name}'.")

                # 3) Create or retrieve WindowShadingControl object
                shading_ctrl_name = f"ShadingCtrl_{window_id.replace(' ', '_').replace(':', '_')}"
                logger.debug(f"[{window_id}] Target WindowShadingControl name: '{shading_ctrl_name}'")

                # Determine the zone name by looking up the base surface of the fenestration
                zone_name = None
                base_surface_name = getattr(fen_surface_obj, "Building_Surface_Name", None)
                if base_surface_name:
                    base_surfaces = idf.idfobjects.get("BUILDINGSURFACE:DETAILED", [])
                    bs_obj = next((bs for bs in base_surfaces if getattr(bs, 'Name', None) == base_surface_name), None)
                    if bs_obj:
                        zone_name = getattr(bs_obj, "Zone_Name", None)
                
                if zone_name is None or not zone_name.strip():
                    logger.error(f"[{window_id}] Cannot determine Zone Name for WindowShadingControl '{shading_ctrl_name}'. Skipping this control object.")
                    if assigned_shading_log is not None:
                        if window_id not in assigned_shading_log: assigned_shading_log[window_id] = {}
                        assigned_shading_log[window_id]["shading_creation_status"] = "Failed: Zone Name for ShadingControl could not be determined."
                    continue # Skip to the next fenestration surface

                existing_shading_ctrls_objects = idf.idfobjects.get("WINDOWSHADINGCONTROL", [])
                shading_ctrl = next((sc for sc in existing_shading_ctrls_objects if getattr(sc, 'Name', None) == shading_ctrl_name), None)

                if shading_ctrl:
                    logger.info(
                        f"[{window_id}] WindowShadingControl '{shading_ctrl_name}' already exists. Reusing."
                    )
                else:
                    logger.info(f"[{window_id}] Creating new WindowShadingControl '{shading_ctrl_name}'.")
                    shading_ctrl = idf.newidfobject("WINDOWSHADINGCONTROL")
                    shading_ctrl.Name = shading_ctrl_name
                    shading_ctrl.Zone_Name = zone_name # Zone Name is required and now validated

                    # Determine Shading_Type based on blind_to_glass_distance or a param
                    blind_dist = shading_params.get("blind_to_glass_distance", 0.05)  # Default to positive (exterior)
                    shading_device_type_ep = "ExteriorBlind"
                    if isinstance(blind_dist, (int, float)) and blind_dist < 0:
                        shading_device_type_ep = "InteriorBlind"
                    # Other types: "ExteriorScreen", "InteriorScreen", "BetweenGlassBlind", "BetweenGlassScreen", "Shade"
                    # This logic could be expanded if shading_params includes a more direct "shading_device_ep_type"
                    shading_ctrl.Shading_Type = shading_params.get("shading_device_ep_type", shading_device_type_ep)
                    
                    shading_ctrl.Shading_Device_Material_Name = blind_mat_name

                    shading_ctrl.Shading_Control_Type = shading_params.get("shading_control_type", "AlwaysOn") # E.g., AlwaysOn, OnIfHighSolarOnWindow, Scheduled
                    
                    # Slat control type, relevant if Shading_Type is a blind
                    if "Blind" in shading_ctrl.Shading_Type: # Covers InteriorBlind, ExteriorBlind, BetweenGlassBlind
                        shading_ctrl.Type_of_Slats_Control_for_Blinds = shading_params.get("slat_control_type", "FixedSlatAngle") # E.g., FixedSlatAngle, ScheduledSlatAngle, BlockBeamSolar

                        # Set Fixed_Slat_Angle if control type is FixedSlatAngle
                        if shading_ctrl.Type_of_Slats_Control_for_Blinds.lower() == "fixedslatangle":
                            # Use the corrected field name: Fixed_Slat_Angle
                            shading_ctrl.Fixed_Slat_Angle = shading_params.get("slat_angle_deg", 45.0)
                        
                        # Example for ScheduledSlatAngle (add more logic if using this)
                        # if shading_ctrl.Type_of_Slats_Control_for_Blinds.lower() == "scheduledslatangle":
                        #     shading_ctrl.Slat_Angle_Schedule_Name = shading_params.get("slat_angle_schedule_name", "DefaultSlatAngleSchedule")
                        #     # Ensure "DefaultSlatAngleSchedule" exists or is created.

                    # If Shading_Control_Type is "Scheduled"
                    if shading_ctrl.Shading_Control_Type.lower() == "scheduled":
                         shading_ctrl.Schedule_Name = shading_params.get("shading_control_schedule_name", "AlwaysOnSchedule") # Ensure this schedule exists
                         # The field "Shading_Control_Is_Scheduled" is not directly in WindowShadingControl.
                         # The presence of a Schedule_Name when Shading_Control_Type is "Scheduled" implies it.
                    
                    shading_ctrl.Glare_Control_Is_Active = shading_params.get("glare_control_is_active", "No")
                    # Add other fields like Setpoint, Glare_Control_Daylighting_Illuminance_Setpoint, etc. as needed.

                    logger.debug(f"[{window_id}] Successfully created/configured WindowShadingControl '{shading_ctrl.Name}'.")

                # Ensure the current fenestration surface is listed in the control object's extensible fields
                # This part can be tricky with IDF libraries. Geomeppy might have an add_extensible method.
                # Assuming a direct indexed approach for now, ensuring it doesn't overwrite.
                # Check if the fenestration surface is already in this control object
                is_fen_listed = False
                for i in range(1, 101): # Max extensible fields, adjust if needed
                    field_name = f"Fenestration_Surface_{i}_Name"
                    current_fen_on_ctrl = getattr(shading_ctrl, field_name, None)
                    if current_fen_on_ctrl == fen_name_attr:
                        is_fen_listed = True
                        break
                    if current_fen_on_ctrl is None or not current_fen_on_ctrl.strip(): # Found an empty slot
                        if not is_fen_listed: # Add if not already listed
                            setattr(shading_ctrl, field_name, fen_name_attr)
                            logger.debug(f"[{window_id}] Assigned fenestration '{fen_name_attr}' to {field_name} of '{shading_ctrl_name}'.")
                        is_fen_listed = True # Mark as listed (or handled)
                        break
                if not is_fen_listed:
                     logger.warning(f"[{window_id}] Could not assign fenestration '{fen_name_attr}' to WindowShadingControl '{shading_ctrl_name}' (no empty slots or already present).")


                if assigned_shading_log is not None:
                    if window_id not in assigned_shading_log:
                        assigned_shading_log[window_id] = {}
                    assigned_shading_log[window_id]["shading_creation_status"] = f"Linked to {shading_ctrl_name}"
                    assigned_shading_log[window_id]["shading_control_name_assigned"] = shading_ctrl_name
                    assigned_shading_log[window_id]["blind_material_name_used"] = blind_mat_name

            except Exception as e_fen_processing:
                logger.error(
                    f"Error processing blind for fenestration surface '{window_id}': {e_fen_processing}",
                    exc_info=True 
                )
                if assigned_shading_log is not None:
                    if window_id not in assigned_shading_log:
                        assigned_shading_log[window_id] = {}
                    assigned_shading_log[window_id]["shading_creation_status"] = f"Failed: Outer processing error - {str(e_fen_processing)}"
                continue  # Move to the next fenestration surface
        logger.info("Finished processing blind shading for fenestration surfaces.")


    # --- Create Geometry-Based Shading (e.g., Overhangs, Fins) ---
    if create_geometry_shading:
        logger.info(
            f"Attempting to create geometry-based shading using shading_type_key: '{shading_type_key}'"
        )
        # This typically would not loop per window unless geometry is window-specific.
        # The _create_overhang_example is a global example.
        # You might need a list of building elements or a different context for these.
        # Ensure user_config_shading passed here is relevant for geometric shading.
        _create_overhang_example(
            idf,
            building_row,  # Pass context
            shading_type_key=shading_type_key, # This key should be for geometric shading in shading_lookup
            strategy=strategy,
            user_config_shading=user_config_shading, 
        )
    
    num_blind_mats_final = len(idf.idfobjects.get("WINDOWMATERIAL:BLIND", []))
    num_shading_ctrls_final = len(idf.idfobjects.get("WINDOWSHADINGCONTROL", []))
    logger.info(f"Exiting add_shading_objects. Total WindowMaterial:Blind objects in IDF: {num_blind_mats_final}")
    logger.info(f"Exiting add_shading_objects. Total WindowShadingControl objects in IDF: {num_shading_ctrls_final}")


def _create_overhang_example(
    idf, building_row_context, shading_type_key, strategy, user_config_shading
):
    """
    Example function to demonstrate geometry-based shading (Shading:Building:Detailed).
    In real usage, you’d compute or retrieve the overhang geometry from
    building_row_context, other geometric inputs, or detailed shading_params.
    This is a placeholder and creates a fixed, illustrative overhang.

    Parameters
    ----------
    idf : IDF object
    building_row_context : dict or object
        Contextual data (e.g., building dimensions, orientation) that could inform geometry.
    shading_type_key : str
        Key to look up base parameters, potentially for overhang depth, etc.
        This should point to an entry in shading_lookup.py suitable for geometric shading.
    strategy : str
        Strategy for picking values from ranges.
    user_config_shading : dict or None
        Overrides for parameters relevant to this geometric shading.
    """
    logger.info(f"Executing _create_overhang_example for shading_type_key: {shading_type_key}.")
    
    # For geometry, the 'window_id' for pick_shading_params might be a generic name
    # if the overhang is not tied to a specific window but rather a facade or building.
    # The `user_config_shading` passed here should be the specific overrides for this `shading_type_key`.
    shading_params = pick_shading_params(
        window_id="GeometricShading_Example",  # Generic ID for logging these params
        shading_type_key=shading_type_key,
        strategy=strategy,
        user_config=user_config_shading, 
    )

    if not shading_params:
        logger.warning(
            f"No parameters resolved for geometric shading example with key '{shading_type_key}'. Skipping creation."
        )
        return

    # Example: Expecting "shading_element_name" and "overhang_depth" from shading_params
    overhang_name = shading_params.get("shading_element_name", "Default_Overhang_Example")
    overhang_depth = shading_params.get("overhang_depth", 1.0)  # Default 1m depth if not in params

    # Ensure name is valid for E+
    overhang_name = overhang_name.replace(' ', '_').replace(':', '_')

    # Check if this shading object already exists
    existing_shading_geom_objects = idf.idfobjects.get("SHADING:BUILDING:DETAILED", [])
    if any(getattr(sg, 'Name', None) == overhang_name for sg in existing_shading_geom_objects):
        logger.info(
            f"Shading:Building:Detailed '{overhang_name}' already exists. Skipping creation."
        )
        return

    try:
        shading_obj = idf.newidfobject("SHADING:BUILDING:DETAILED")
        shading_obj.Name = overhang_name
        # Base_Surface_Name: Optional, if the overhang is attached to a specific surface.
        # Transmittance_Schedule_Name: Optional, if transmittance varies.

        # --- Illustrative Geometry ---
        # This is purely illustrative. Real geometry calculation is complex and depends heavily on
        # building_row_context (facade dimensions, window positions, building orientation)
        # and detailed parameters from shading_params (width, tilt, offsets, etc.).
        # The coordinates MUST be in absolute world coordinates.

        logger.info(f"Illustrative geometry for '{overhang_name}': This is a placeholder and needs actual geometric calculation.")
        
        # Example: A 5m wide overhang, 'overhang_depth' deep, at Z=3.0, on a conceptual North facade (Y positive from facade plane)
        # These coordinates would need to be calculated based on the actual building.
        # Assume facade starts at X=0, Y=0 (local to facade segment) and is oriented North.
        # World coordinates would depend on building's position and orientation.
        
        # For simplicity, let's define a rectangle parallel to XY plane, offset in Y.
        # This is NOT a realistic overhang calculation.
        x_start = 0.0
        width = 5.0
        z_level = 3.0
        y_facade = 0.0 # Assuming facade is at Y=0 for this example segment

        shading_obj.Number_of_Vertices = 4
        # Vertices are typically counter-clockwise when viewed from outside looking towards the building.
        # For an overhang on a North wall (Y-positive is "out"), this means Y increases.

        # Vertex 1 (Bottom-Left of overhang, at facade)
        shading_obj.Vertex_1_X_coordinate = x_start
        shading_obj.Vertex_1_Y_coordinate = y_facade 
        shading_obj.Vertex_1_Z_coordinate = z_level

        # Vertex 2 (Bottom-Right of overhang, at facade)
        shading_obj.Vertex_2_X_coordinate = x_start + width
        shading_obj.Vertex_2_Y_coordinate = y_facade
        shading_obj.Vertex_2_Z_coordinate = z_level

        # Vertex 3 (Top-Right of overhang, projecting outwards)
        shading_obj.Vertex_3_X_coordinate = x_start + width
        shading_obj.Vertex_3_Y_coordinate = y_facade + overhang_depth # Projects 'overhang_depth'
        shading_obj.Vertex_3_Z_coordinate = z_level 

        # Vertex 4 (Top-Left of overhang, projecting outwards)
        shading_obj.Vertex_4_X_coordinate = x_start
        shading_obj.Vertex_4_Y_coordinate = y_facade + overhang_depth
        shading_obj.Vertex_4_Z_coordinate = z_level

        logger.debug(
            f"Created placeholder Shading:Building:Detailed '{shading_obj.Name}' with illustrative depth {overhang_depth}m."
        )

    except Exception as e:
        logger.error(f"Error creating Shading:Building:Detailed '{overhang_name}': {e}", exc_info=True)


def add_shading_schedule(
    idf, schedule_name="DefaultShadingSchedule", schedule_type="Fraction"
):
    """
    Example of how you might create a schedule for dynamic shading control
    (e.g., for Shading_Control_Schedule_Name in WindowShadingControl).

    Parameters
    ----------
    idf : IDF object
    schedule_name : str
        Name for the new schedule.
    schedule_type : str
        Type of schedule, e.g., "Fraction", "OnOff", "Temperature".

    Returns
    -------
    The created schedule object, or None if creation fails.
    """
    logger.info(
        f"Attempting to create/retrieve schedule: '{schedule_name}' of type '{schedule_type}'."
    )
    
    # Ensure schedule_name is valid for E+
    schedule_name_ep = schedule_name.replace(' ', '_').replace(':', '_')


    # Check if schedule already exists (assuming Schedule:Compact for this example)
    # More robust checking would involve checking other schedule types too.
    schedule_objects = idf.idfobjects.get("SCHEDULE:COMPACT", [])
    existing_schedule = next((s for s in schedule_objects if getattr(s, 'Name', None) == schedule_name_ep), None)
    
    if existing_schedule:
        logger.info(f"Schedule:Compact '{schedule_name_ep}' already exists. Reusing.")
        return existing_schedule

    try:
        # Using SCHEDULE:COMPACT for simplicity.
        sched = idf.newidfobject("SCHEDULE:COMPACT")
        sched.Name = schedule_name_ep

        # Schedule_Type_Limits_Name links to a ScheduleTypeLimits object.
        # Assume ScheduleTypeLimits Name matches the schedule_type for simplicity,
        # e.g., if schedule_type is "Fraction", it looks for a ScheduleTypeLimits named "Fraction".
        stl_name = schedule_type 
        
        stl_objects = idf.idfobjects.get("SCHEDULETYPELIMITS", [])
        existing_stl = next((stl for stl in stl_objects if getattr(stl, 'Name', None) == stl_name), None)

        if not existing_stl:
            logger.warning(
                f"ScheduleTypeLimits '{stl_name}' not found. Creating a basic one for '{schedule_name_ep}'."
            )
            new_stl = idf.newidfobject("SCHEDULETYPELIMITS")
            new_stl.Name = stl_name
            if schedule_type.lower() == "fraction":
                new_stl.Lower_Limit_Value = 0.0
                new_stl.Upper_Limit_Value = 1.0
                new_stl.Numeric_Type = "Continuous" # Or Discrete if it's 0 or 1 steps
            elif schedule_type.lower() == "onoff": 
                new_stl.Lower_Limit_Value = 0.0
                new_stl.Upper_Limit_Value = 1.0
                new_stl.Numeric_Type = "Discrete"
            elif schedule_type.lower() == "temperature":
                new_stl.Lower_Limit_Value = -100.0 
                new_stl.Upper_Limit_Value = 200.0  
                new_stl.Numeric_Type = "Continuous"
            else: # Default for unknown types
                logger.warning(
                    f"No default setup for ScheduleTypeLimits '{schedule_type}'. Defaulting to Fraction-like limits (0-1, Continuous)."
                )
                new_stl.Lower_Limit_Value = 0.0
                new_stl.Upper_Limit_Value = 1.0
                new_stl.Numeric_Type = "Continuous" 

        sched.Schedule_Type_Limits_Name = stl_name

        # Simple example: always 1.0 (e.g., shades always active if scheduled and this schedule is used)
        # Field format for SCHEDULE:COMPACT: "Through: MM/DD", "For: Days", "Until: HH:MM, Value", ...
        sched.Field_1 = "Through: 12/31"  # Through end of year
        sched.Field_2 = "For: AllDays"  # For all day types
        sched.Field_3 = "Until: 24:00"   # Until midnight
        sched.Field_4 = "1.0"            # Value is 1.0
        # Add more fields for complex schedules.

        logger.debug(f"Created Schedule:Compact '{sched.Name}'.")
        return sched
    except Exception as e:
        logger.error(f"Error creating schedule '{schedule_name_ep}': {e}", exc_info=True)
        return None

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\wshading\shading_overrides_from_excel.py
============================================================
"""
shading_overrides_from_excel.py

If you want to read shading overrides from an Excel file (e.g., different
blind angles per season, or custom user settings for certain building IDs),
you can do that here.

Analogous to geometry_overrides_from_excel.py or dict_override_excel.py:
 - parse the Excel
 - store each row in a rules dictionary
 - 'pick_shading_params_from_rules' uses those rules to find
   the best match for a building/window context
"""

import pandas as pd
import logging

logger = logging.getLogger(__name__)

def read_shading_overrides_excel(excel_path):
    """
    Reads an Excel file containing shading override rules.

    Example columns might be:
        building_id
        shading_type_key
        slat_angle_deg_min
        slat_angle_deg_max
        slat_width  # Example of a single value override
        # ... other parameters ...

    Returns
    -------
    list
        A list of dictionaries, where each dictionary represents a row (a rule)
        from the Excel sheet. Returns an empty list if the file cannot be read
        or is empty.
    
    Raises
    ------
    ValueError
        If required columns are missing.
    """
    try:
        df = pd.read_excel(excel_path)
    except FileNotFoundError:
        logger.error(f"Excel override file not found: {excel_path}")
        return []
    except Exception as e:
        logger.error(f"Error reading Excel override file {excel_path}: {e}")
        return []

    if df.empty:
        logger.warning(f"Shading overrides Excel file is empty: {excel_path}")
        return []

    # We define a minimal required set of columns
    required_cols = ["building_id", "shading_type_key"]
    missing = [c for c in required_cols if c not in df.columns]
    if missing:
        raise ValueError(f"Missing columns in shading_overrides Excel ({excel_path}): {missing}")

    override_rules = []
    for index, row in df.iterrows():
        rule = {}
        try:
            rule["building_id"] = str(row["building_id"]).strip()
            rule["shading_type_key"] = str(row["shading_type_key"]).strip()

            # --- Handle range parameters ---
            # Example: slat_angle_deg_range
            if "slat_angle_deg_min" in df.columns and "slat_angle_deg_max" in df.columns:
                min_ang = row["slat_angle_deg_min"]
                max_ang = row["slat_angle_deg_max"]
                if pd.notna(min_ang) and pd.notna(max_ang):
                    try:
                        rule["slat_angle_deg_range"] = (float(min_ang), float(max_ang))
                    except ValueError:
                        logger.warning(
                            f"Invalid float value for slat_angle_deg_min/max in Excel row {index + 2}. "
                            f"Skipping slat_angle_deg_range for this rule."
                        )
                elif pd.notna(min_ang) or pd.notna(max_ang):
                    logger.warning(
                        f"Partial slat_angle_deg_min/max definition in Excel row {index + 2}. "
                        f"Both must be provided. Skipping slat_angle_deg_range for this rule."
                    )
            
            # TODO: Add more explicit range parameter handling here if needed
            # Example for another range parameter "parameter_foo_range":
            # if "parameter_foo_min" in df.columns and "parameter_foo_max" in df.columns:
            #     min_val = row["parameter_foo_min"]
            #     max_val = row["parameter_foo_max"]
            #     if pd.notna(min_val) and pd.notna(max_val):
            #         try:
            #             rule["parameter_foo_range"] = (float(min_val), float(max_val))
            #         except ValueError:
            #              logger.warning(f"Invalid float for parameter_foo_min/max in Excel row {index + 2}.")
            #     elif pd.notna(min_val) or pd.notna(max_val):
            #         logger.warning(f"Partial parameter_foo_min/max in Excel row {index + 2}.")


            # --- Handle single value parameters ---
            # Add other specific single-value parameters that can be overridden from Excel.
            # Ensure they are parsed to the correct type.
            # Example:
            # if "slat_width" in df.columns and pd.notna(row["slat_width"]):
            #     try:
            #         rule["slat_width"] = float(row["slat_width"])
            #     except ValueError:
            #         logger.warning(f"Invalid float value for slat_width in Excel row {index + 2}. Skipping.")
            
            # Generic approach: Add all other non-empty columns from the Excel row to the rule.
            # These will be used as direct overrides in `pick_shading_params`.
            # The `pick_shading_params` function will then decide how to use them (e.g., if it's a range or single value).
            for col_name in df.columns:
                if col_name not in required_cols and \
                   not col_name.endswith(("_min", "_max")) and \
                   col_name not in rule and \
                   pd.notna(row[col_name]):
                    rule[col_name] = row[col_name] # Keep original type for now, or convert as needed

            override_rules.append(rule)
        except Exception as e:
            logger.error(f"Error processing row {index + 2} in {excel_path}: {e}. Skipping this rule.")
            continue
            
    return override_rules


def pick_shading_params_from_rules(
    building_id,
    shading_type_key,
    all_rules,
    fallback=None
):
    """
    Looks through the list of override_rules (from read_shading_overrides_excel)
    to find a matching rule for the given building_id and shading_type_key.

    The matching is case-insensitive for building_id and shading_type_key.
    If multiple rules match, the last one found in the `all_rules` list takes precedence.

    Parameters
    ----------
    building_id : str or int
        The identifier of the building.
    shading_type_key : str
        The key identifying the type of shading (e.g., "my_external_louvers").
    all_rules : list
        A list of rule dictionaries, typically from `read_shading_overrides_excel`.
    fallback : any, optional
        Value to return if no matching rule is found. Defaults to None.

    Returns
    -------
    dict or any
        A dictionary containing the override parameters if a match is found.
        These parameters are the ones to be applied, excluding "building_id"
        and "shading_type_key". Returns `fallback` if no rule matches.
        Example override dict: {"slat_angle_deg_range": (30, 60), "slat_width": 0.05}
    """
    if not all_rules:
        return fallback

    best_rule_content = None
    building_id_str = str(building_id).lower()
    shading_type_key_str = str(shading_type_key).lower()

    for rule in all_rules:
        # building_id must match (case-insensitive)
        rule_building_id = str(rule.get("building_id", "")).lower()
        if rule_building_id != building_id_str:
            continue

        # shading_type_key must match (case-insensitive)
        rule_shading_type_key = str(rule.get("shading_type_key", "")).lower()
        if rule_shading_type_key != shading_type_key_str:
            continue
        
        # If we are here, both IDs matched.
        # The last match in the list takes precedence.
        current_overrides = dict(rule)
        current_overrides.pop("building_id", None)
        current_overrides.pop("shading_type_key", None)
        best_rule_content = current_overrides

    if best_rule_content is None:
        return fallback

    return best_rule_content
------------------------------------------------------------

