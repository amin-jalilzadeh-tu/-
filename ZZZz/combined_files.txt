File: D:\Documents\E_Plus_2030_py\idf_objects\Elec\constants.py
============================================================
# Elec/constants.py

"""
Global constants or default fallback values for the lighting module.
These can be overridden by user configs or Excel-based overrides.
"""

# Default power density values (W/mÂ²)
DEFAULT_LIGHTING_WM2 = 10.0
DEFAULT_PARASITIC_WM2 = 0.285

# Default burning hours if not found in the lookup
DEFAULT_TD = 2000
DEFAULT_TN = 300

# Optional: If you want fraction parameter defaults here
# (instead of defining them in the fallback block of assign_lighting_values.py),
# you can do so, e.g.:
DEFAULT_LIGHTS_FRACTION_RADIANT = 0.7
DEFAULT_LIGHTS_FRACTION_VISIBLE = 0.2
DEFAULT_LIGHTS_FRACTION_REPLACEABLE = 1.0

DEFAULT_EQUIP_FRACTION_RADIANT = 0.0
DEFAULT_EQUIP_FRACTION_LOST = 1.0

# You can import & use these defaults in assign_lighting_values.py
# or wherever you handle fraction parameters.

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\Elec\assign_lighting_values.py
============================================================
# Elec/assign_lighting_values.py

import random
from .lighting_lookup import lighting_lookup
from .constants import (
    DEFAULT_LIGHTING_WM2,
    DEFAULT_PARASITIC_WM2,
    DEFAULT_TD,
    DEFAULT_TN,
    # If needed:
    # DEFAULT_EQUIP_FRACTION_LOST,
)
from .overrides_helper import find_applicable_overrides


def assign_lighting_parameters(
    building_id: int,
    building_type: str,
    age_range=None,
    calibration_stage: str = "pre_calibration",
    strategy: str = "A",
    random_seed: int = None,
    user_config: list = None,     # list of override dicts from lighting.json
    assigned_log: dict = None     # optional dictionary to store final picks
):
    """
    Determines final lighting parameters for a given building,
    merging any user overrides from `lighting.json` with default 
    ranges found in lighting_lookup[calibration_stage][building_type].

    The returned dict has keys like "lights_wm2", "parasitic_wm2", 
    "tD", "tN", "lights_fraction_radiant", etc. Each key maps to a
    sub-dict of the form:
      {
        "assigned_value": float,
        "min_val": float,
        "max_val": float,
        "object_name": "LIGHTS" or "ELECTRICEQUIPMENT" etc.
      }

    Steps:
      1) Identify default ranges from `lighting_lookup[calibration_stage][building_type]`.
         If building_type not found, fallback to constants.
      2) If user_config is provided, find all rows that match (building_id, building_type, age_range).
      3) Override the relevant ranges with those rows (either fixed_value => (v,v) or min_val/max_val).
      4) Pick the final assigned value from the resulting range using strategy:
         - "A" => midpoint
         - "B" => random.uniform
         - else => pick the lower bound
      5) Construct a final dict describing the assigned values 
         and (optionally) store in assigned_log[building_id].

    Parameters
    ----------
    building_id : int
        Unique identifier for the building (e.g. ogc_fid).
    building_type : str
        A string matching the keys in lighting_lookup[stage], e.g. "Residential" or "Non-Residential".
    age_range : str, optional
        If you want to filter overrides by age_range.
    calibration_stage : str, default "pre_calibration"
        Typically "pre_calibration" or "post_calibration" (used as a top-level key in lighting_lookup).
    strategy : {"A","B"}, default "A"
        "A" => pick midpoint in [min_val, max_val], "B" => pick random in that range.
    random_seed : int, optional
        If you want reproducible random picks, pass an integer seed.
    user_config : list of dicts, optional
        The override data from lighting.json. Each dict can have fields like:
          {
             "building_id": 4136730,
             "building_type": "Residential",
             "param_name": "lights_wm2",
             "min_val": 8.0,
             "max_val": 10.0
          }
        or "fixed_value": ...
    assigned_log : dict, optional
        If provided, the final structured picks are stored as assigned_log[building_id].

    Returns
    -------
    dict
        A dictionary describing final picks, e.g.:
        {
          "lights_wm2": {
            "assigned_value": 9.0,
            "min_val": 8.0,
            "max_val": 10.0,
            "object_name": "LIGHTS"
          },
          ...
        }
    """

    # (A) Set random seed if specified
    if random_seed is not None:
        random.seed(random_seed)

    # (B) Get the "stage_dict" for the given calibration_stage
    if calibration_stage not in lighting_lookup:
        calibration_stage = "pre_calibration"
    stage_dict = lighting_lookup[calibration_stage]

    # Convert building_type to a consistent case if needed, e.g. "Residential" => "Residential"
    # and "non_residential" => "Non-Residential" if that's your dictionary's exact key.
    # Example:
    if building_type.lower() == "residential":
        building_type = "Residential"
    elif building_type.lower() == "non_residential":
        building_type = "Non-Residential"

    # (C) If building_type not in the stage dict => fallback to "defaults"
    if building_type not in stage_dict:
        # Fallback block
        fallback = {
            "lights_wm2": {
                "assigned_value": DEFAULT_LIGHTING_WM2,
                "min_val": DEFAULT_LIGHTING_WM2,
                "max_val": DEFAULT_LIGHTING_WM2,
                "object_name": "LIGHTS"
            },
            "parasitic_wm2": {
                "assigned_value": DEFAULT_PARASITIC_WM2,
                "min_val": DEFAULT_PARASITIC_WM2,
                "max_val": DEFAULT_PARASITIC_WM2,
                "object_name": "ELECTRICEQUIPMENT"
            },
            "tD": {
                "assigned_value": DEFAULT_TD,
                "min_val": DEFAULT_TD,
                "max_val": DEFAULT_TD,
                "object_name": "LIGHTS_SCHEDULE"
            },
            "tN": {
                "assigned_value": DEFAULT_TN,
                "min_val": DEFAULT_TN,
                "max_val": DEFAULT_TN,
                "object_name": "LIGHTS_SCHEDULE"
            },
            "lights_fraction_radiant": {
                "assigned_value": 0.7,
                "min_val": 0.7,
                "max_val": 0.7,
                "object_name": "LIGHTS.Fraction_Radiant"
            },
            "lights_fraction_visible": {
                "assigned_value": 0.2,
                "min_val": 0.2,
                "max_val": 0.2,
                "object_name": "LIGHTS.Fraction_Visible"
            },
            "lights_fraction_replaceable": {
                "assigned_value": 1.0,
                "min_val": 1.0,
                "max_val": 1.0,
                "object_name": "LIGHTS.Fraction_Replaceable"
            },
            "equip_fraction_radiant": {
                "assigned_value": 0.0,
                "min_val": 0.0,
                "max_val": 0.0,
                "object_name": "ELECTRICEQUIPMENT.Fraction_Radiant"
            },
            "equip_fraction_lost": {
                "assigned_value": 1.0,
                "min_val": 1.0,
                "max_val": 1.0,
                "object_name": "ELECTRICEQUIPMENT.Fraction_Lost"
            }
        }
        if assigned_log is not None:
            assigned_log[building_id] = fallback
        return fallback

    # Otherwise, retrieve the param_dict for that building_type
    param_dict = stage_dict[building_type]

    # (D) Extract default ranges
    lights_rng    = param_dict.get("LIGHTS_WM2_range", (DEFAULT_LIGHTING_WM2, DEFAULT_LIGHTING_WM2))
    parasitic_rng = param_dict.get("PARASITIC_WM2_range", (DEFAULT_PARASITIC_WM2, DEFAULT_PARASITIC_WM2))
    tD_rng        = param_dict.get("tD_range", (DEFAULT_TD, DEFAULT_TD))
    tN_rng        = param_dict.get("tN_range", (DEFAULT_TN, DEFAULT_TN))

    lights_fraction_radiant_rng     = param_dict.get("lights_fraction_radiant_range", (0.7, 0.7))
    lights_fraction_visible_rng     = param_dict.get("lights_fraction_visible_range", (0.2, 0.2))
    lights_fraction_replace_rng     = param_dict.get("lights_fraction_replaceable_range", (1.0, 1.0))

    equip_fraction_radiant_rng = param_dict.get("equip_fraction_radiant_range", (0.0, 0.0))
    equip_fraction_lost_rng    = param_dict.get("equip_fraction_lost_range", (1.0, 1.0))

    # (E) Find any user overrides that apply
    if user_config is not None:
        matches = find_applicable_overrides(building_id, building_type, age_range, user_config)
    else:
        matches = []

    # Debug: See which overrides matched
    print(f"[DEBUG lighting] bldg_id={building_id}, type='{building_type}', matched overrides => {matches}")

    # (F) Override default ranges with user-config
    for row in matches:
        pname = row.get("param_name", "").strip().lower()
        fv = row.get("fixed_value", None)  # optional direct fix
        mn = row.get("min_val", None)
        mx = row.get("max_val", None)

        # If row has a fixed_value => treat it as (fv, fv)
        if fv is not None:
            rng = (float(fv), float(fv))
        elif mn is not None and mx is not None:
            rng = (float(mn), float(mx))
        else:
            rng = None

        if rng:
            if pname == "lights_wm2":
                lights_rng = rng
            elif pname == "parasitic_wm2":
                parasitic_rng = rng
            elif pname == "td":
                tD_rng = rng
            elif pname == "tn":
                tN_rng = rng
            elif pname == "lights_fraction_radiant":
                lights_fraction_radiant_rng = rng
            elif pname == "lights_fraction_visible":
                lights_fraction_visible_rng = rng
            elif pname == "lights_fraction_replaceable":
                lights_fraction_replace_rng = rng
            elif pname == "equip_fraction_radiant":
                equip_fraction_radiant_rng = rng
            elif pname == "equip_fraction_lost":
                equip_fraction_lost_rng = rng
            # else param_name not recognized => ignore

    # Helper to pick final value from a (min,max) range
    def pick_val(r):
        if strategy == "A":   # midpoint
            return (r[0] + r[1]) / 2.0
        elif strategy == "B": # random
            return random.uniform(r[0], r[1])
        else:
            # fallback => pick min
            return r[0]

    # (G) Pick final values
    assigned_lights = pick_val(lights_rng)
    assigned_paras  = pick_val(parasitic_rng)
    assigned_tD     = pick_val(tD_rng)
    assigned_tN     = pick_val(tN_rng)

    assigned_lights_frac_rad = pick_val(lights_fraction_radiant_rng)
    assigned_lights_frac_vis = pick_val(lights_fraction_visible_rng)
    assigned_lights_frac_rep = pick_val(lights_fraction_replace_rng)
    assigned_equip_frac_rad  = pick_val(equip_fraction_radiant_rng)
    assigned_equip_frac_lost = pick_val(equip_fraction_lost_rng)

    # (H) Build final dict
    assigned = {
        "lights_wm2": {
            "assigned_value": assigned_lights,
            "min_val": lights_rng[0],
            "max_val": lights_rng[1],
            "object_name": "LIGHTS"
        },
        "parasitic_wm2": {
            "assigned_value": assigned_paras,
            "min_val": parasitic_rng[0],
            "max_val": parasitic_rng[1],
            "object_name": "ELECTRICEQUIPMENT"
        },
        "tD": {
            "assigned_value": assigned_tD,
            "min_val": tD_rng[0],
            "max_val": tD_rng[1],
            "object_name": "LIGHTS_SCHEDULE"
        },
        "tN": {
            "assigned_value": assigned_tN,
            "min_val": tN_rng[0],
            "max_val": tN_rng[1],
            "object_name": "LIGHTS_SCHEDULE"
        },

        "lights_fraction_radiant": {
            "assigned_value": assigned_lights_frac_rad,
            "min_val": lights_fraction_radiant_rng[0],
            "max_val": lights_fraction_radiant_rng[1],
            "object_name": "LIGHTS.Fraction_Radiant"
        },
        "lights_fraction_visible": {
            "assigned_value": assigned_lights_frac_vis,
            "min_val": lights_fraction_visible_rng[0],
            "max_val": lights_fraction_visible_rng[1],
            "object_name": "LIGHTS.Fraction_Visible"
        },
        "lights_fraction_replaceable": {
            "assigned_value": assigned_lights_frac_rep,
            "min_val": lights_fraction_replace_rng[0],
            "max_val": lights_fraction_replace_rng[1],
            "object_name": "LIGHTS.Fraction_Replaceable"
        },

        "equip_fraction_radiant": {
            "assigned_value": assigned_equip_frac_rad,
            "min_val": equip_fraction_radiant_rng[0],
            "max_val": equip_fraction_radiant_rng[1],
            "object_name": "ELECTRICEQUIPMENT.Fraction_Radiant"
        },
        "equip_fraction_lost": {
            "assigned_value": assigned_equip_frac_lost,
            "min_val": equip_fraction_lost_rng[0],
            "max_val": equip_fraction_lost_rng[1],
            "object_name": "ELECTRICEQUIPMENT.Fraction_Lost"
        }
    }

    # (I) Optionally store in assigned_log
    if assigned_log is not None:
        assigned_log[building_id] = assigned

    return assigned

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\Elec\lighting_lookup.py
============================================================
# Elec/lighting_lookup.py

"""
Lighting Lookup Table (Pre/Post Calibration)
---------------------------------------------
This version includes fraction parameters for both LIGHTS
and ELECTRICEQUIPMENT objects, so that they can be overridden
just like lights_wm2 and parasitic_wm2.
"""

lighting_lookup = {
    "pre_calibration": {
        # ===============================
        # 1) RESIDENTIAL (all sub-types)
        # ===============================
        # Per NTA 8800 references (example): 
        # lights_wm2/parasitic_wm2 => 0.0
        # fraction radiant => 0.7, fraction visible => 0.2, fraction replaceable => 1.0
        # eq_obj fraction radiant => 0.0, fraction lost => 1.0
        "Residential": {
            "Corner House": {
                "LIGHTS_WM2_range": (0.0, 0.0),
                "PARASITIC_WM2_range": (0.0, 0.0),
                "tD_range": (0, 0),
                "tN_range": (0, 0),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Apartment": {
                "LIGHTS_WM2_range": (0.0, 0.0),
                "PARASITIC_WM2_range": (0.0, 0.0),
                "tD_range": (0, 0),
                "tN_range": (0, 0),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Terrace or Semi-detached House": {
                "LIGHTS_WM2_range": (0.0, 0.0),
                "PARASITIC_WM2_range": (0.0, 0.0),
                "tD_range": (0, 0),
                "tN_range": (0, 0),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Detached House": {
                "LIGHTS_WM2_range": (0.0, 0.0),
                "PARASITIC_WM2_range": (0.0, 0.0),
                "tD_range": (0, 0),
                "tN_range": (0, 0),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Two-and-a-half-story House": {
                "LIGHTS_WM2_range": (0.0, 0.0),
                "PARASITIC_WM2_range": (0.0, 0.0),
                "tD_range": (0, 0),
                "tN_range": (0, 0),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            }
        },

        # ===============================
        # 2) NON-RESIDENTIAL
        # ===============================
        "Non-Residential": {
            "Meeting Function": {
                "LIGHTS_WM2_range": (16.0, 18.0),
                "PARASITIC_WM2_range": (0.28, 0.30),
                "tD_range": (2100, 2300),
                "tN_range": (300, 400),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Healthcare Function": {
                "LIGHTS_WM2_range": (17.0, 19.0),
                "PARASITIC_WM2_range": (0.28, 0.31),
                "tD_range": (2100, 4200),
                "tN_range": (300, 1100),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Sport Function": {
                "LIGHTS_WM2_range": (16.0, 18.0),
                "PARASITIC_WM2_range": (0.28, 0.30),
                "tD_range": (2100, 2300),
                "tN_range": (700, 900),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Cell Function": {
                "LIGHTS_WM2_range": (16.0, 18.0),
                "PARASITIC_WM2_range": (0.28, 0.30),
                "tD_range": (3800, 4200),
                "tN_range": (900, 1100),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Retail Function": {
                "LIGHTS_WM2_range": (29.0, 31.0),
                "PARASITIC_WM2_range": (0.28, 0.30),
                "tD_range": (2600, 2800),
                "tN_range": (300, 500),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Industrial Function": {
                "LIGHTS_WM2_range": (16.0, 18.0),
                "PARASITIC_WM2_range": (0.28, 0.30),
                "tD_range": (2100, 2300),
                "tN_range": (300, 400),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Accommodation Function": {
                "LIGHTS_WM2_range": (16.0, 18.0),
                "PARASITIC_WM2_range": (0.28, 0.30),
                "tD_range": (3800, 4200),
                "tN_range": (900, 1100),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Office Function": {
                "LIGHTS_WM2_range": (15.0, 17.0),
                "PARASITIC_WM2_range": (0.28, 0.29),
                "tD_range": (2100, 2300),
                "tN_range": (300, 400),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Education Function": {
                "LIGHTS_WM2_range": (13.0, 16.0),
                "PARASITIC_WM2_range": (0.28, 0.30),
                "tD_range": (1500, 1700),
                "tN_range": (200, 400),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Other Use Function": {
                "LIGHTS_WM2_range": (15.0, 18.0),
                "PARASITIC_WM2_range": (0.28, 0.30),
                "tD_range": (2000, 2500),
                "tN_range": (200, 500),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            }
        }
    },

    # ----------------------------------------------------------------
    # Post-calibration stage: narrower or locked values (example only)
    # ----------------------------------------------------------------
    "post_calibration": {
        "Residential": {
            "Corner House": {
                "LIGHTS_WM2_range": (0.0, 0.0),
                "PARASITIC_WM2_range": (0.0, 0.0),
                "tD_range": (0, 0),
                "tN_range": (0, 0),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Apartment": {
                "LIGHTS_WM2_range": (0.0, 0.0),
                "PARASITIC_WM2_range": (0.0, 0.0),
                "tD_range": (0, 0),
                "tN_range": (0, 0),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Terrace or Semi-detached House": {
                "LIGHTS_WM2_range": (0.0, 0.0),
                "PARASITIC_WM2_range": (0.0, 0.0),
                "tD_range": (0, 0),
                "tN_range": (0, 0),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Detached House": {
                "LIGHTS_WM2_range": (0.0, 0.0),
                "PARASITIC_WM2_range": (0.0, 0.0),
                "tD_range": (0, 0),
                "tN_range": (0, 0),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Two-and-a-half-story House": {
                "LIGHTS_WM2_range": (0.0, 0.0),
                "PARASITIC_WM2_range": (0.0, 0.0),
                "tD_range": (0, 0),
                "tN_range": (0, 0),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            }
        },
        "Non-Residential": {
            "Meeting Function": {
                "LIGHTS_WM2_range": (17.0, 17.0),
                "PARASITIC_WM2_range": (0.285, 0.285),
                "tD_range": (2200, 2200),
                "tN_range": (300, 300),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Healthcare Function": {
                "LIGHTS_WM2_range": (18.0, 18.0),
                "PARASITIC_WM2_range": (0.29, 0.29),
                "tD_range": (4000, 4000),
                "tN_range": (1000, 1000),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Sport Function": {
                "LIGHTS_WM2_range": (17.0, 17.0),
                "PARASITIC_WM2_range": (0.285, 0.285),
                "tD_range": (2200, 2200),
                "tN_range": (800, 800),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Cell Function": {
                "LIGHTS_WM2_range": (17.0, 17.0),
                "PARASITIC_WM2_range": (0.285, 0.285),
                "tD_range": (4000, 4000),
                "tN_range": (1000, 1000),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Retail Function": {
                "LIGHTS_WM2_range": (30.0, 30.0),
                "PARASITIC_WM2_range": (0.285, 0.285),
                "tD_range": (2700, 2700),
                "tN_range": (400, 400),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Industrial Function": {
                "LIGHTS_WM2_range": (17.0, 17.0),
                "PARASITIC_WM2_range": (0.285, 0.285),
                "tD_range": (2200, 2200),
                "tN_range": (300, 300),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Accommodation Function": {
                "LIGHTS_WM2_range": (17.0, 17.0),
                "PARASITIC_WM2_range": (0.285, 0.285),
                "tD_range": (4000, 4000),
                "tN_range": (1000, 1000),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Office Function": {
                "LIGHTS_WM2_range": (16.0, 16.0),
                "PARASITIC_WM2_range": (0.285, 0.285),
                "tD_range": (2200, 2200),
                "tN_range": (300, 300),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Education Function": {
                "LIGHTS_WM2_range": (15.0, 15.0),
                "PARASITIC_WM2_range": (0.285, 0.285),
                "tD_range": (1600, 1600),
                "tN_range": (300, 300),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Other Use Function": {
                "LIGHTS_WM2_range": (16.0, 16.0),
                "PARASITIC_WM2_range": (0.285, 0.285),
                "tD_range": (2200, 2200),
                "tN_range": (300, 300),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            }
        }
    }
}

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\Elec\lighting_overrides_from_excel.py
============================================================
# lighting_overrides_from_excel.py
import pandas as pd
import copy

def read_lighting_overrides_from_excel(excel_path):
    """
    Reads lighting_overrides.xlsx and returns a structure like:
      override_data[calibration_stage][building_type][param_name] = (min_val, max_val) or (val, val)

    Expected columns:
      - calibration_stage
      - building_type
      - param_name (like 'lights_wm2', 'parasitic_wm2', 'tD', 'tN', etc.)
      - min_val
      - max_val
      - fixed_value
    """
    df = pd.read_excel(excel_path)

    required_cols = ["calibration_stage", "building_type", "param_name", "min_val", "max_val", "fixed_value"]
    for c in required_cols:
        if c not in df.columns:
            raise ValueError(f"Missing column '{c}' in {excel_path}")

    override_data = {}

    for _, row in df.iterrows():
        stage = str(row["calibration_stage"]).strip()
        btype = str(row["building_type"]).strip()
        pname = str(row["param_name"]).strip()   # e.g. "lights_wm2", "tD", "PARASITIC_WM2"
        fv = row["fixed_value"]
        mn = row["min_val"]
        mx = row["max_val"]

        if stage not in override_data:
            override_data[stage] = {}
        if btype not in override_data[stage]:
            override_data[stage][btype] = {}

        # final range
        if pd.notna(fv):
            # if fixed_value => (fv, fv)
            override_data[stage][btype][pname] = (float(fv), float(fv))
        elif pd.notna(mn) and pd.notna(mx):
            override_data[stage][btype][pname] = (float(mn), float(mx))
        else:
            # if neither => skip or store None
            continue

    return override_data


def apply_lighting_overrides_to_lookup(default_lookup, override_data):
    """
    Merges override_data into default_lookup in place (or you can copy first).
    default_lookup => e.g. lighting_lookup from lighting_lookup.py

    For each stage/btype/param_name, we set or override the 
      param_name_range in default_lookup[stage][btype].

    E.g. if param_name is "lights_wm2", we need to store it as "LIGHTS_WM2_range".
    If param_name is "tD", store it as "tD_range". 
    We'll do a small map or direct approach.
    """

    # you could do copy if you want:
    new_lookup = default_lookup

    for stage, btypes_dict in override_data.items():
        if stage not in new_lookup:
            new_lookup[stage] = {}
        for btype, param_dict in btypes_dict.items():
            if btype not in new_lookup[stage]:
                new_lookup[stage][btype] = {}
            for pname, rng_tuple in param_dict.items():
                # we transform e.g. "lights_wm2" => "LIGHTS_WM2_range"
                # or "tD" => "tD_range"
                # uppercase might matter if your existing dict uses "LIGHTS_WM2_range".
                
                # A small helper map:
                # If your existing keys are "LIGHTS_WM2_range", 
                # you might do a dictionary or just do pattern replacements:
                
                # pattern => uppercase param, + "_range"
                # e.g. "lights_wm2" => "LIGHTS_WM2_range"
                # if param_name already uppercase => "PARASITIC_WM2" => we might skip re-uppercasing
                # We'll do a naive approach:
                
                # Convert to uppercase (except tD/tN we keep as is?), up to you:
                if pname.lower() == "lights_wm2":
                    range_key = "LIGHTS_WM2_range"
                elif pname.lower() == "parasitic_wm2":
                    range_key = "PARASITIC_WM2_range"
                else:
                    # e.g. tD => "tD_range", tN => "tN_range"
                    range_key = f"{pname}_range"

                new_lookup[stage][btype][range_key] = rng_tuple

    return new_lookup

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\Elec\lighting.py
============================================================
# Elec/lighting.py

from .assign_lighting_values import assign_lighting_parameters
from .schedules import create_lighting_schedule, create_parasitic_schedule

def get_building_category_and_subtype(building_row):
    """
    Returns (building_category, sub_type) strings based on building_row.
    Adjust the logic as needed, depending on how your CSV or DB fields
    are structured.

    If building_row["building_function"] is something like "Residential"
    or "Meeting Function", use that as your sub_type.
    If building_row["building_function"] says "Residential", set building_category="Residential".
    Otherwise, assume building_category="Non-Residential".

    Update as necessary for your own classification logic.
    """
    bldg_func = building_row.get("building_function", "").strip()
    if not bldg_func:
        # fallback
        return ("Non-Residential", "Other Use Function")

    # Example simple logic:
    if "resid" in bldg_func.lower():
        building_category = "Residential"
        sub_type = bldg_func  # e.g. "Residential" or "Corner House"
    else:
        building_category = "Non-Residential"
        sub_type = bldg_func  # e.g. "Office Function", "Meeting Function"

    return (building_category, sub_type)


def add_lights_and_parasitics(
    idf,
    building_row,
    calibration_stage="pre_calibration",
    strategy="A",
    random_seed=None,
    user_config=None,
    assigned_values_log=None,
    zonelist_name="ALL_ZONES"
):
    """
    1) Determine building_category (Residential/Non-Residential) and sub_type.
    2) Retrieve assigned lighting parameters (including fraction fields).
    3) Create schedules in IDF:
       - A lighting schedule for the LIGHTS object
       - An always-on parasitic schedule for ELECTRICEQUIPMENT
    4) Add LIGHTS and ELECTRICEQUIPMENT objects referencing a ZoneList in the IDF.

    The assigned parameters and final picks are stored in assigned_values_log[ogc_fid]
    if assigned_values_log is provided.
    """

    # 1) Get building_category / sub_type
    building_category, sub_type = get_building_category_and_subtype(building_row)

    # 2) Retrieve lighting parameters
    bldg_id = int(building_row.get("ogc_fid", 0))

    assigned_dict = assign_lighting_parameters(
        building_id=bldg_id,
        building_type=sub_type,
        # Optional:
        # age_range=building_row.get("age_range", None),
        calibration_stage=calibration_stage,
        strategy=strategy,
        random_seed=random_seed,
        user_config=user_config,
        assigned_log=assigned_values_log  # logs the final sub-dict structure
    )

    # Extract main power densities
    lights_wm2 = assigned_dict["lights_wm2"]["assigned_value"]
    parasitic_wm2 = assigned_dict["parasitic_wm2"]["assigned_value"]

    # Extract fraction parameters for LIGHTS
    lights_frac_radiant = assigned_dict["lights_fraction_radiant"]["assigned_value"]
    lights_frac_visible = assigned_dict["lights_fraction_visible"]["assigned_value"]
    lights_frac_replace = assigned_dict["lights_fraction_replaceable"]["assigned_value"]

    # Extract fraction parameters for EQUIPMENT
    equip_frac_radiant = assigned_dict["equip_fraction_radiant"]["assigned_value"]
    equip_frac_lost = assigned_dict["equip_fraction_lost"]["assigned_value"]

    # 3) Create schedules
    lights_sched_name = create_lighting_schedule(
        idf,
        building_category=building_category,
        sub_type=sub_type,
        schedule_name="LightsSchedule"
    )
    paras_sched_name = create_parasitic_schedule(idf, sched_name="ParasiticSchedule")

    # 4) Add a single LIGHTS object for the entire ZoneList
    lights_obj = idf.newidfobject("LIGHTS")
    lights_obj.Name = f"Lights_{zonelist_name}"
    lights_obj.Zone_or_ZoneList_or_Space_or_SpaceList_Name = zonelist_name
    lights_obj.Schedule_Name = lights_sched_name
    lights_obj.Design_Level_Calculation_Method = "Watts/Area"
    lights_obj.Watts_per_Zone_Floor_Area = lights_wm2

    # Apply fraction fields
    lights_obj.Fraction_Radiant = lights_frac_radiant
    lights_obj.Fraction_Visible = lights_frac_visible
    lights_obj.Fraction_Replaceable = lights_frac_replace

    # Add ELECTRICEQUIPMENT object for parasitic loads
    eq_obj = idf.newidfobject("ELECTRICEQUIPMENT")
    eq_obj.Name = f"Parasitic_{zonelist_name}"
    eq_obj.Zone_or_ZoneList_or_Space_or_SpaceList_Name = zonelist_name
    eq_obj.Schedule_Name = paras_sched_name
    eq_obj.Design_Level_Calculation_Method = "Watts/Area"
    eq_obj.Watts_per_Zone_Floor_Area = parasitic_wm2

    # Apply fraction fields
    eq_obj.Fraction_Radiant = equip_frac_radiant
    eq_obj.Fraction_Lost = equip_frac_lost

    # Optionally, you can also set eq_obj.Fraction_Visible if needed,
    # but typically for "Parasitic" loads we do not.

    return lights_obj, eq_obj

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\Elec\schedule_def.py
============================================================
# Elec/schedule_def.py

import pandas as pd

"""
This file holds:
1) A default SCHEDULE_DEFINITIONS dictionary for lighting usage patterns
   (weekday vs. weekend) for Residential & Non-Residential sub-types.
2) (Optional) Functions to read & apply schedule overrides from Excel,
   which lets you adjust the (start_hour, end_hour, fraction) blocks.

You can import SCHEDULE_DEFINITIONS and pass it to your 'create_lighting_schedule'
function in schedules.py or lighting.py.
"""

# 1) Default SCHEDULE Definitions
SCHEDULE_DEFINITIONS = {
    "Residential": {
        "Corner House": {
            "weekday": [
                (0, 6, 0.05),
                (6, 8, 0.30),
                (8, 17, 0.10),
                (17, 22, 0.50),
                (22, 24, 0.05),
            ],
            "weekend": [
                (0, 8, 0.10),
                (8, 22, 0.40),
                (22, 24, 0.10),
            ],
        },
        "Apartment": {
            "weekday": [
                (0, 6, 0.05),
                (6, 8, 0.20),
                (8, 18, 0.10),
                (18, 23, 0.60),
                (23, 24, 0.05),
            ],
            "weekend": [
                (0, 9, 0.15),
                (9, 22, 0.50),
                (22, 24, 0.15),
            ],
        },
        "Terrace or Semi-detached House": {
            "weekday": [
                (0, 7, 0.05),
                (7, 9, 0.20),
                (9, 17, 0.10),
                (17, 22, 0.60),
                (22, 24, 0.05),
            ],
            "weekend": [
                (0, 9, 0.10),
                (9, 22, 0.50),
                (22, 24, 0.10),
            ],
        },
        "Detached House": {
            "weekday": [
                (0, 7, 0.05),
                (7, 9, 0.20),
                (9, 17, 0.10),
                (17, 22, 0.60),
                (22, 24, 0.05),
            ],
            "weekend": [
                (0, 9, 0.10),
                (9, 22, 0.50),
                (22, 24, 0.10),
            ],
        },
        "Two-and-a-half-story House": {
            "weekday": [
                (0, 6, 0.05),
                (6, 9, 0.20),
                (9, 18, 0.10),
                (18, 23, 0.60),
                (23, 24, 0.05),
            ],
            "weekend": [
                (0, 9, 0.10),
                (9, 22, 0.50),
                (22, 24, 0.10),
            ],
        },
    },
    "Non-Residential": {
        "Meeting Function": {
            "weekday": [
                (0, 6, 0.05),
                (6, 9, 0.50),
                (9, 12, 0.80),
                (12, 13, 0.50),
                (13, 18, 0.80),
                (18, 20, 0.50),
                (20, 24, 0.10),
            ],
            "weekend": [
                (0, 24, 0.10),
            ],
        },
        "Healthcare Function": {
            "weekday": [
                (0, 24, 0.80),  # Healthcare often 24/7
            ],
            "weekend": [
                (0, 24, 0.80),
            ],
        },
        "Sport Function": {
            "weekday": [
                (0, 6, 0.05),
                (6, 9, 0.20),
                (9, 12, 0.70),
                (12, 14, 0.50),
                (14, 22, 0.70),
                (22, 24, 0.10),
            ],
            "weekend": [
                (0, 9, 0.10),
                (9, 22, 0.70),
                (22, 24, 0.10),
            ],
        },
        "Cell Function": {
            "weekday": [
                (0, 24, 0.90),
            ],
            "weekend": [
                (0, 24, 0.90),
            ],
        },
        "Retail Function": {
            "weekday": [
                (0, 6, 0.05),
                (6, 9, 0.30),
                (9, 19, 0.90),
                (19, 21, 0.50),
                (21, 24, 0.05),
            ],
            "weekend": [
                (0, 8, 0.10),
                (8, 19, 0.80),
                (19, 22, 0.30),
                (22, 24, 0.10),
            ],
        },
        "Industrial Function": {
            "weekday": [
                (0, 6, 0.20),
                (6, 8, 0.50),
                (8, 17, 0.80),
                (17, 20, 0.50),
                (20, 24, 0.20),
            ],
            "weekend": [
                (0, 24, 0.20),
            ],
        },
        "Accommodation Function": {
            "weekday": [
                (0, 24, 0.70),
            ],
            "weekend": [
                (0, 24, 0.70),
            ],
        },
        "Office Function": {
            "weekday": [
                (0, 6, 0.10),
                (6, 9, 0.50),
                (9, 12, 0.90),
                (12, 13, 0.70),
                (13, 18, 0.90),
                (18, 20, 0.50),
                (20, 24, 0.10),
            ],
            "weekend": [
                (0, 24, 0.10),
            ],
        },
        "Education Function": {
            "weekday": [
                (0, 7, 0.05),
                (7, 8, 0.50),
                (8, 16, 0.80),
                (16, 18, 0.50),
                (18, 24, 0.05),
            ],
            "weekend": [
                (0, 24, 0.10),
            ],
        },
        "Other Use Function": {
            "weekday": [
                (0, 24, 0.30),
            ],
            "weekend": [
                (0, 24, 0.20),
            ],
        },
    },
}


# 2) (Optional) Functions to read & apply schedule overrides from Excel.

def read_schedule_overrides_from_excel(excel_path):
    """
    Example function to read schedule overrides from an Excel file.

    Expected columns (you can adjust to your needs):
      - building_category   (e.g. "Residential" or "Non-Residential")
      - sub_type            (e.g. "Apartment", "Office Function", etc.)
      - day_type            (e.g. "weekday" or "weekend")
      - start_hour
      - end_hour
      - fraction_value

    Returns a dict of form:
      overrides[building_category][sub_type][day_type] = [
         (start_hour, end_hour, fraction),
         ...
      ]
    """
    df = pd.read_excel(excel_path)
    required_cols = ["building_category", "sub_type", "day_type", 
                     "start_hour", "end_hour", "fraction_value"]
    for c in required_cols:
        if c not in df.columns:
            raise ValueError(f"Missing column '{c}' in {excel_path}")

    overrides = {}
    for _, row in df.iterrows():
        cat = str(row["building_category"]).strip()
        stype = str(row["sub_type"]).strip()
        dtype = str(row["day_type"]).strip().lower()  # "weekday" or "weekend"
        sh   = float(row["start_hour"])
        eh   = float(row["end_hour"])
        frac = float(row["fraction_value"])

        if cat not in overrides:
            overrides[cat] = {}
        if stype not in overrides[cat]:
            overrides[cat][stype] = {}
        if dtype not in overrides[cat][stype]:
            overrides[cat][stype][dtype] = []

        overrides[cat][stype][dtype].append((sh, eh, frac))

    return overrides


def apply_schedule_overrides_to_schedules(base_schedules, overrides):
    """
    Applies the schedule overrides from 'overrides' to 'base_schedules' in-place.
    'base_schedules' is typically SCHEDULE_DEFINITIONS.
    'overrides' is from read_schedule_overrides_from_excel.

    For each (cat, stype, day_type), we replace the entire list
    of (start_hour, end_hour, fraction) blocks with the override list.

    If you want partial merges or something more advanced, adapt as needed.
    """
    for cat, stype_dict in overrides.items():
        if cat not in base_schedules:
            # Create it if it doesn't exist
            base_schedules[cat] = {}
        for stype, daytypes_dict in stype_dict.items():
            if stype not in base_schedules[cat]:
                base_schedules[cat][stype] = {}

            for day_type, blocks_list in daytypes_dict.items():
                # e.g. "weekday", "weekend", or any custom day type
                base_schedules[cat][stype][day_type] = blocks_list

    # Return the updated dictionary
    return base_schedules

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\Elec\schedules.py
============================================================
# Elec/schedules.py

from .schedule_def import SCHEDULE_DEFINITIONS

"""
This module creates detailed lighting schedules for weekdays and weekends,
differentiating by building_category (Residential/Non-Residential)
and by sub_type (Apartment, Office Function, etc.).

We have two main functions:
1) create_lighting_schedule(idf, building_category, sub_type, schedule_name)
   - Creates a SCHEDULE:COMPACT with different time blocks for 'WeekDays',
     'Saturday', and 'Sunday' (or 'AllDays' if you prefer).
2) create_parasitic_schedule(idf, sched_name)
   - Creates an always-on (1.0) schedule, typically for parasitic loads.

Important:
- This code assumes you already loaded or potentially overrode
  SCHEDULE_DEFINITIONS in schedule_def.py (for instance, by calling
  `read_schedule_overrides_from_excel()` + `apply_schedule_overrides_to_schedules()`).
- If you want more advanced day-splitting, feel free to expand the logic below.
"""


def create_lighting_schedule(idf, building_category, sub_type, schedule_name="LightsSchedule"):
    """
    Create a SCHEDULE:COMPACT in the IDF using SCHEDULE_DEFINITIONS[building_category][sub_type].
    We define separate blocks for:
      - For: WeekDays
      - For: Saturday
      - For: Sunday

    If the sub_type is missing in SCHEDULE_DEFINITIONS, we fallback to a simple always-0.5 pattern.

    The final IDF object name is `schedule_name`. We return that string for convenience.
    """

    # Attempt to get sub-type dictionary from SCHEDULE_DEFINITIONS
    try:
        sub_dict = SCHEDULE_DEFINITIONS[building_category][sub_type]
    except KeyError:
        # Fallback: If not found, create a simple always-0.5 schedule
        sub_dict = {
            "weekday": [(0, 24, 0.5)],
            "weekend": [(0, 24, 0.5)],
        }

    # Some sub-types might not have a separate weekend pattern. 
    # So ensure we have 'weekday' and 'weekend' keys:
    if "weekday" not in sub_dict:
        sub_dict["weekday"] = [(0, 24, 0.5)]
    if "weekend" not in sub_dict:
        sub_dict["weekend"] = [(0, 24, 0.5)]

    # Create the schedule object
    schedule = idf.newidfobject("SCHEDULE:COMPACT")
    schedule.Name = schedule_name
    schedule.Schedule_Type_Limits_Name = "Fraction"

    # We'll define the entire year with "Through: 12/31" and break it down by day types
    # The pattern is:
    #   Field_1:  "Through: 12/31"
    #   Field_2:  "For: WeekDays"
    #   Field_3+: "Until: HH:MM,<fraction>"
    #
    # Then for Saturday, Sunday, etc.

    field_idx = 1
    setattr(schedule, f"Field_{field_idx}", "Through: 12/31")
    field_idx += 1

    # 1) WeekDays
    setattr(schedule, f"Field_{field_idx}", "For: WeekDays")
    field_idx += 1
    for (start_hour, end_hour, frac) in sub_dict["weekday"]:
        # e.g. "Until: 06:00,0.05"
        setattr(schedule, f"Field_{field_idx}",
                f"Until: {int(end_hour):02d}:00,{frac:.2f}")
        field_idx += 1

    # 2) Saturday
    setattr(schedule, f"Field_{field_idx}", "For: Saturday")
    field_idx += 1
    for (start_hour, end_hour, frac) in sub_dict["weekend"]:
        setattr(schedule, f"Field_{field_idx}",
                f"Until: {int(end_hour):02d}:00,{frac:.2f}")
        field_idx += 1

    # 3) Sunday
    setattr(schedule, f"Field_{field_idx}", "For: Sunday")
    field_idx += 1
    for (start_hour, end_hour, frac) in sub_dict["weekend"]:
        setattr(schedule, f"Field_{field_idx}",
                f"Until: {int(end_hour):02d}:00,{frac:.2f}")
        field_idx += 1

    return schedule.Name


def create_parasitic_schedule(idf, sched_name="ParasiticSchedule"):
    """
    Creates an always-on schedule (1.0) for parasitic loads (24/7).
    """
    schedule = idf.newidfobject("SCHEDULE:COMPACT")
    schedule.Name = sched_name
    schedule.Schedule_Type_Limits_Name = "Fraction"

    # Single block covering all days, 24 hours
    schedule.Field_1 = "Through: 12/31"
    schedule.Field_2 = "For: AllDays"
    schedule.Field_3 = "Until: 24:00,1.0"

    return schedule.Name

------------------------------------------------------------

