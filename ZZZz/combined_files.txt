File: D:\Documents\E_Plus_2030_py\idf_objects\geomz\assign_geometry_values.py
============================================================
# geomz/assign_geometry_values.py

import random
from .geometry_lookup import geometry_lookup
from .geometry_overrides_from_excel import pick_geom_params_from_rules


def find_geom_overrides(building_id, building_type, user_config):
    """
    Returns any matching rows from user_config for the given building_id / building_type.
    Each override can define:
      - building_id (exact match, if provided)
      - building_type (exact match, if provided)
      - param_name in ["perimeter_depth", "has_core"]
      - min_val, max_val (for numeric overrides)
      - fixed_value (for boolean or "lock" numeric)
    """
    matches = []
    for row in (user_config or []):
        # Match building_id if specified
        if "building_id" in row:
            if row["building_id"] != building_id:
                continue
        # Match building_type if specified
        if "building_type" in row:
            if row["building_type"] != building_type:
                continue
        matches.append(row)
    return matches


def pick_val_with_range(
    rng_tuple,
    strategy="A",
    log_dict=None,      # e.g. assigned_geom_log[bldg_id]
    param_name=None
):
    """
    rng_tuple = (min_val, max_val)
    strategy  = "A" => midpoint
                "B" => random uniform
                else => pick min_val
    log_dict  => dictionary for logging (if not None)
    param_name=> e.g. "perimeter_depth"

    We log both the range and the final chosen value:
       log_dict["perimeter_depth_range"] = (2.0, 3.0)
       log_dict["perimeter_depth"]       = 2.45
    """
    min_v, max_v = rng_tuple

    if strategy == "A":         # midpoint
        chosen = (min_v + max_v) / 2.0
    elif strategy == "B":       # random uniform
        chosen = random.uniform(min_v, max_v)
    else:
        chosen = min_v          # fallback => min

    if log_dict is not None and param_name is not None:
        log_dict[f"{param_name}_range"] = (min_v, max_v)
        log_dict[param_name] = chosen

    return chosen


def assign_geometry_values(
    building_row,
    calibration_stage="pre_calibration",
    strategy="A",
    random_seed=None,
    user_config=None,         # optional list of partial overrides from JSON
    assigned_geom_log=None,   # dictionary for logging
    excel_rules=None          # optional excel-based geometry rules
):
    """
    1) Identify building_function => "residential" or "non_residential".
    2) Identify sub-type => read "residential_type" or "non_residential_type".
    3) Start from geometry_lookup[ building_function ][ sub_type ][ calibration_stage ] => param_dict
       e.g. { "perimeter_depth_range": (2.0,3.0), "has_core": False }
    4) If excel_rules => override further (pick_geom_params_from_rules(...)).
    5) If user_config => partial override for "perimeter_depth" or "has_core".
       - If param_name="perimeter_depth" with min_val & max_val => update perimeter_depth_range.
         If "fixed_value":true => interpret it as (min_val, min_val) => no randomness.
       - If param_name="has_core" and fixed_value => set has_core = that boolean
    6) We pick final perimeter_depth using pick_val_with_range(...).
    7) Return a dictionary => {"perimeter_depth": X, "has_core": Y}.
    8) Log final picks (and numeric range) in assigned_geom_log if provided.
    """

    # optional reproducibility
    if random_seed is not None:
        random.seed(random_seed)

    bldg_id        = building_row.get("ogc_fid", 0)
    bldg_function  = building_row.get("building_function", "residential").lower()
    area           = building_row.get("area", 100.0)
    perimeter      = building_row.get("perimeter", 40.0)

    # 1) get sub-type
    if bldg_function == "residential":
        sub_type = building_row.get("residential_type", "Two-and-a-half-story House")
        dict_for_function = geometry_lookup.get("residential", {}).get(sub_type, {})
    else:
        sub_type = building_row.get("non_residential_type", "Office Function")
        dict_for_function = geometry_lookup.get("non_residential", {}).get(sub_type, {})

    # 2) if calibration_stage not found => fallback
    if calibration_stage not in dict_for_function:
        param_dict = {
            "perimeter_depth_range": (2.0, 3.0),
            "has_core": False
        }
    else:
        param_dict = dict_for_function[calibration_stage]

    # Start with these defaults
    perimeter_depth_range = param_dict.get("perimeter_depth_range", (2.0, 3.0))
    has_core_default      = param_dict.get("has_core", False)

    # 3) If excel_rules => apply
    if excel_rules:
        rule_result = pick_geom_params_from_rules(
            building_function=bldg_function,
            building_type=sub_type,
            area=area,
            perimeter=perimeter,
            all_rules=excel_rules,
            calibration_stage=calibration_stage
        )
        if rule_result:
            perimeter_depth_range = rule_result["perimeter_depth_range"]
            core_val = rule_result["has_core_override"]
            if core_val is not None:
                has_core_default = core_val

    # 4) Check user_config partial overrides
    matched_rows = []
    if user_config:
        matched_rows = find_geom_overrides(bldg_id, sub_type, user_config)

    for row in matched_rows:
        pname = row.get("param_name", "")
        if pname == "perimeter_depth":
            mn = row.get("min_val")
            mx = row.get("max_val")
            if mn is not None and mx is not None:
                # If "fixed_value": true => make it (mn, mn)
                if row.get("fixed_value") is True:
                    perimeter_depth_range = (mn, mn)
                else:
                    perimeter_depth_range = (mn, mx)

        elif pname == "has_core":
            val = row.get("fixed_value")
            if val is not None:
                has_core_default = bool(val)

    # 5) Logging dict
    if assigned_geom_log is not None and bldg_id not in assigned_geom_log:
        assigned_geom_log[bldg_id] = {}
    log_dict = assigned_geom_log[bldg_id] if assigned_geom_log and bldg_id else None

    # 6) Pick final perimeter_depth
    perimeter_depth = pick_val_with_range(
        rng_tuple=perimeter_depth_range,
        strategy=strategy,
        log_dict=log_dict,
        param_name="perimeter_depth"
    )

    # 7) has_core => store directly
    if log_dict is not None:
        log_dict["has_core"] = has_core_default

    # 8) Return final dictionary
    result = {
        "perimeter_depth": perimeter_depth,
        "has_core": has_core_default
    }
    return result

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\geomz\building.py
============================================================
# geomz/building.py

from .assign_geometry_values import assign_geometry_values
from .geometry import compute_dimensions_from_area_perimeter, create_building_base_polygon
from .zoning import create_zones_with_perimeter_depth, link_surfaces
import math
import pandas as pd

def create_building_with_roof_type(
    idf,
    area,
    perimeter,
    orientation,
    building_row,
    edge_types,
    wall_height=None,
    roof_slope_axis='length',
    ridge_position=0.5,
    calibration_stage="pre_calibration",
    strategy="A",
    random_seed=None,
    user_config=None,
    assigned_geom_log=None,
    excel_rules=None
):
    """
    Create building geometry in the IDF, multi-floor, optionally perimeter+core.
    Now includes logic to link each new floor's Floor to the old floor's Ceiling.
    """

     # --------------------------------------------------------------------
    # 1) Safely read gem_hoogte (float) and num_floors (int), with defaults
    # --------------------------------------------------------------------
    raw_hoogte = building_row.get("gem_hoogte", 3)  # default 3
    if pd.isna(raw_hoogte) or raw_hoogte is None:
        gem_hoogte = 3.0
    else:
        try:
            gem_hoogte = float(raw_hoogte)
        except ValueError:
            # In case it's a weird string
            gem_hoogte = 3.0

    # Safely get num_floors as an int
    raw_floors = building_row.get("gem_bouwlagen", 1)  # default 1
    if pd.isna(raw_floors) or raw_floors is None:
        num_floors = 1
    else:
        try:
            # Round or floor/ceil as needed
            num_floors = int(round(float(raw_floors)))
        except ValueError:
            # In case it's a weird string
            num_floors = 1

    # Guard against zero or negative floors
    if num_floors < 1:
        num_floors = 1






    # ------------------------------------------------
    # Approach A: Reconcile total height & floors
    # ------------------------------------------------
    bldg_func = building_row.get("building_function", "").lower()

    # Decide typical min/max floor heights per function
    if "residential" in bldg_func:
        typical_floor_height_min = 2.5
        typical_floor_height_max = 4.0
    else:
        # e.g. non-res might allow taller floors
        typical_floor_height_min = 3.0
        typical_floor_height_max = 6.0

    # implied floor height
    implied_floor_height = gem_hoogte / num_floors

    # If each floor is taller than max => increase floors
    if implied_floor_height > typical_floor_height_max:
        new_floors = int(round(gem_hoogte / typical_floor_height_max))
        if new_floors < 1:
            new_floors = 1
        num_floors = new_floors

    # Recompute after possible update above
    implied_floor_height = gem_hoogte / num_floors

    # If each floor is shorter than min => reduce floors (only if floors>1)
    if implied_floor_height < typical_floor_height_min and num_floors > 1:
        new_floors = int(round(gem_hoogte / typical_floor_height_min))
        if new_floors < 1:
            new_floors = 1
        num_floors = new_floors
















    if wall_height is None:
        if gem_hoogte is not None:
            total_height = gem_hoogte
        else:
            total_height = 3.0 * num_floors
        wall_height = total_height / num_floors

    # 2) Determine geometry parameters (perimeter_depth, has_core) from dictionary + overrides
    geom_params = assign_geometry_values(
        building_row=building_row,
        calibration_stage=calibration_stage,
        strategy=strategy,
        random_seed=random_seed,
        user_config=user_config,
        assigned_geom_log=assigned_geom_log,
        excel_rules=excel_rules
    )
    perimeter_depth = geom_params["perimeter_depth"]
    has_core = geom_params["has_core"]

    # 3) Rectangle dimensions from area & perimeter
    width, length = compute_dimensions_from_area_perimeter(area, perimeter)

    # 4) Create base polygon for ground floor
    A0, B0, C0, D0 = create_building_base_polygon(width, length, orientation)
    base_poly_0 = [A0, B0, C0, D0]

    # 5) Create each floor in a loop
    floors_zones = {}
    current_base_poly = base_poly_0

    prev_floor_zones = None  # Will store the zone surfaces from the previous floor
    for floor_i in range(1, num_floors + 1):
        # "Ground" for 1st floor, else "Internal"
        floor_type = "Ground" if floor_i == 1 else "Internal"
        is_top_floor = (floor_i == num_floors)

        # Create zones for this floor (could be single or perimeter+core)
        zones_data = create_zones_with_perimeter_depth(
            idf=idf,
            floor_i=floor_i,
            base_poly=current_base_poly,
            wall_height=wall_height,
            edge_types=edge_types,
            perimeter_depth=perimeter_depth,
            floor_type=floor_type,
            has_core=has_core,
            is_top_floor=is_top_floor
        )
        floors_zones[floor_i] = zones_data

        # -------------------------------------------------------
        #  LINK THIS FLOOR’S "FLOOR" SURFACES TO PREV FLOOR’S "CEILING" SURFACES
        # -------------------------------------------------------
        if floor_i > 1 and prev_floor_zones:
            # We'll do a basic approach: match zone names in sorted order
            old_zone_names = sorted(prev_floor_zones.keys())
            new_zone_names = sorted(zones_data.keys())

            for oz, nz in zip(old_zone_names, new_zone_names):
                old_zone_surfs = prev_floor_zones[oz][3]  # (bpoly, tpoly, surf_list) => index 3
                new_zone_surfs = zones_data[nz][3]

                # find the "Ceiling" in old zone
                old_ceiling = None
                for srf in old_zone_surfs:
                    if srf.Name.endswith("_Ceiling") or srf.Name.endswith("_Roof"):
                        # If the old floor was not top floor, we expect a "Ceiling"
                        # If the old floor was top floor (?), it might be a "Roof" -- but typically that wouldn't stack
                        old_ceiling = srf
                        break

                # find the "Floor" in new zone
                new_floor = new_zone_surfs[0]  # typically index=0 is the Floor object from create_zone_surfaces

                # If found both, link them (interzone conduction)
                if old_ceiling and new_floor:
                    link_surfaces(new_floor, old_ceiling)

        prev_floor_zones = zones_data

        # shift the base polygon upward by wall_height for the next floor
        current_base_poly = [(p[0], p[1], p[2] + wall_height) for p in current_base_poly]

    # (Optional) if you want to add pitched roof logic, do it after the top floor is created
    return floors_zones

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\geomz\geometry_lookup.py
============================================================
# geomz/geometry_lookup.py

geometry_lookup = {
    "non_residential": {
        "Accommodation Function": {
            "post_calibration": {
                "has_core": True,
                "perimeter_depth_range": (2.5, 2.5)
            },
            "pre_calibration": {
                "has_core": True,
                "perimeter_depth_range": (2.0, 3.0)
            }
        },
        "Cell Function": {
            "post_calibration": {
                "has_core": True,
                "perimeter_depth_range": (2.2, 2.2)
            },
            "pre_calibration": {
                "has_core": True,
                "perimeter_depth_range": (1.2, 2.2)
            }
        },
        "Education Function": {
            "post_calibration": {
                "has_core": True,
                "perimeter_depth_range": (2.5, 2.5)
            },
            "pre_calibration": {
                "has_core": True,
                "perimeter_depth_range": (2.0, 3.0)
            }
        },
        "Healthcare Function": {
            "post_calibration": {
                "has_core": True,
                "perimeter_depth_range": (3.5, 3.5)
            },
            "pre_calibration": {
                "has_core": True,
                "perimeter_depth_range": (3.0, 4.0)
            }
        },
        "Industrial Function": {
            "post_calibration": {
                "has_core": True,
                "perimeter_depth_range": (3.5, 3.5)
            },
            "pre_calibration": {
                "has_core": True,
                "perimeter_depth_range": (3.0, 4.0)
            }
        },
        "Meeting Function": {
            "post_calibration": {
                "has_core": True,
                "perimeter_depth_range": (2.0, 2.0)
            },
            "pre_calibration": {
                "has_core": True,
                "perimeter_depth_range": (1.0, 2.0)
            }
        },
        "Office Function": {
            "post_calibration": {
                "has_core": True,
                "perimeter_depth_range": (3.0, 3.0)
            },
            "pre_calibration": {
                "has_core": True,
                "perimeter_depth_range": (2.5, 3.5)
            }
        },
        "Other Use Function": {
            "post_calibration": {
                "has_core": True,
                "perimeter_depth_range": (2.3, 2.3)
            },
            "pre_calibration": {
                "has_core": True,
                "perimeter_depth_range": (1.8, 2.8)
            }
        },
        "Retail Function": {
            "post_calibration": {
                "has_core": True,
                "perimeter_depth_range": (2.5, 2.5)
            },
            "pre_calibration": {
                "has_core": True,
                "perimeter_depth_range": (2.0, 3.0)
            }
        },
        "Sport Function": {
            "post_calibration": {
                "has_core": True,
                "perimeter_depth_range": (2.5, 2.5)
            },
            "pre_calibration": {
                "has_core": True,
                "perimeter_depth_range": (1.5, 2.5)
            }
        }
    },
    "residential": {
        
        
        "Apartment": {
            "post_calibration": {
                "has_core": False,
                "perimeter_depth_range": (2.3, 2.8)
            },
            "pre_calibration": {
                "has_core": False,
                "perimeter_depth_range": (1.8, 2.3)
            }
        },
        "Corner House": {
            "post_calibration": {
                "has_core": False,
                "perimeter_depth_range": (2.5, 3.0)
            },
            "pre_calibration": {
                "has_core": False,
                "perimeter_depth_range": (2.0, 2.5)
            }
        },
        "Detached House": {
            "post_calibration": {
                "has_core": False,
                "perimeter_depth_range": (2.5, 3.0)
            },
            "pre_calibration": {
                "has_core": False,
                "perimeter_depth_range": (2.0, 2.5)
            }
        },
        "Terrace or Semi-detached House": {
            "post_calibration": {
                "has_core": False,
                "perimeter_depth_range": (2.5, 3.0)
            },
            "pre_calibration": {
                "has_core": False,
                "perimeter_depth_range": (2.0, 2.5)
            }
        },
        "Two-and-a-half-story House": {
            "post_calibration": {
                "has_core": True,
                "perimeter_depth_range": (2.5, 3.0)
            },
            "pre_calibration": {
                "has_core": False,
                "perimeter_depth_range": (2.0, 2.5)
            }
        }
    }
}

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\geomz\geometry.py
============================================================
import math
from math import sqrt, radians, cos, sin

def rotate_point(px, py, pz, orientation_rad):
    x_new = cos(orientation_rad) * px - sin(orientation_rad) * py
    y_new = sin(orientation_rad) * px + cos(orientation_rad) * py
    return (x_new, y_new, pz)

def compute_dimensions_from_area_perimeter(area, perimeter):
    """
    Solve for width (w) and length (l) using area (A) and perimeter (P):
      w = A / (P/4)
      l = A / w
    """
    if perimeter <= 0:
        raise ValueError("Perimeter must be positive.")
    if area <= 0:
        raise ValueError("Area must be positive.")
    width = area / (perimeter / 4.0)
    length = area / width
    return width, length

def create_building_base_polygon(width, length, orientation):
    """
    Return 4 points in XY plane for a rectangle, rotate them by orientation degrees.
    """
    A = (0, 0, 0)
    B = (width, 0, 0)
    C = (width, length, 0)
    D = (0, length, 0)

    if orientation != 0:
        orientation_rad = radians(orientation)
        A = rotate_point(*A, orientation_rad)
        B = rotate_point(*B, orientation_rad)
        C = rotate_point(*C, orientation_rad)
        D = rotate_point(*D, orientation_rad)

    return A, B, C, D

def polygon_area(poly):
    """Compute area in XY plane via Shoelace formula."""
    x = [p[0] for p in poly]
    y = [p[1] for p in poly]
    n = len(poly)
    area = 0.0
    for i in range(n):
        j = (i + 1) % n
        area += x[i] * y[j] - x[j] * y[i]
    return abs(area) / 2.0

def inward_offset_polygon(A, B, C, D, depth):
    """
    Inward offset of rectangle ABCD by depth, returning [A2,B2,C2,D2] or None if invalid.
    """
    def edge_offset(P1, P2, dist):
        vx = P2[0] - P1[0]
        vy = P2[1] - P1[1]
        length = sqrt(vx*vx + vy*vy)
        nx = -vy / length
        ny = vx / length
        return [
            (P1[0] + nx*dist, P1[1] + ny*dist, P1[2]),
            (P2[0] + nx*dist, P2[1] + ny*dist, P2[2])
        ]

    def line_intersect(p1, p2, p3, p4):
        x1, y1 = p1[0], p1[1]
        x2, y2 = p2[0], p2[1]
        x3, y3 = p3[0], p3[1]
        x4, y4 = p4[0], p4[1]
        denom = (y4 - y3)*(x2 - x1) - (x4 - x3)*(y2 - y1)
        if abs(denom) < 1e-12:
            return None
        ua = ((x4 - x3)*(y1 - y3) - (y4 - y3)*(x1 - x3)) / denom
        X = x1 + ua*(x2 - x1)
        Y = y1 + ua*(y2 - y1)
        return (X, Y, p1[2])

    front_line = edge_offset(A, B, depth)
    right_line = edge_offset(B, C, depth)
    rear_line = edge_offset(C, D, depth)
    left_line = edge_offset(D, A, depth)

    A2 = line_intersect(front_line[0], front_line[1], left_line[0], left_line[1])
    B2 = line_intersect(front_line[0], front_line[1], right_line[0], right_line[1])
    C2 = line_intersect(rear_line[0], rear_line[1], right_line[0], right_line[1])
    D2 = line_intersect(rear_line[0], rear_line[1], left_line[0], left_line[1])

    if A2 and B2 and C2 and D2:
        return [A2, B2, C2, D2]
    else:
        return None

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\geomz\zoning.py
============================================================
# D:\Documents\E_Plus_2030_py\geomz\zoning.py
# --------------------------------------------------------------------------
# This module handles the creation of zones (perimeter + core or single)
# for each floor in a building, plus optional interzone linking. 
# --------------------------------------------------------------------------

from .geometry import polygon_area, inward_offset_polygon

def link_surfaces(surface_a, surface_b):
    """
    Cross-link two surfaces as interzone partitions:
      1) Both Outside_Boundary_Condition = "Surface"
      2) Each references the other's name

    This is used for:
      - Perimeter zone to core zone partitions
      - Floor-to-ceiling linking between stories (in building.py)
    """
    surface_a.Outside_Boundary_Condition = "Surface"
    surface_b.Outside_Boundary_Condition = "Surface"
    surface_a.Outside_Boundary_Condition_Object = surface_b.Name
    surface_b.Outside_Boundary_Condition_Object = surface_a.Name


def create_zone_surfaces(
    idf,
    zone_name,
    base_poly,
    wall_height,
    floor_bc,
    wall_bcs,
    is_top_floor
):
    """
    Create a rectangular zone (Floor, 4 Walls, and a Roof or Ceiling).

    Parameters
    ----------
    idf : geomeppy.IDF
        The IDF to which we add surfaces.
    zone_name : str
        Name of the new Zone object (e.g. "Zone1", "Zone2_Core", etc.).
    base_poly : list of (x,y,z)
        4 corner points (in order) for the zone’s base polygon.
    wall_height : float
        Height of the walls for this floor (e.g. 2.5 m).
    floor_bc : str
        Boundary Condition for the floor (e.g. "Ground", "Adiabatic", "Outdoors").
    wall_bcs : list of str or dict
        4 items for the wall boundary conditions (one per edge).
        If a dict, e.g. {"bc": "Surface", "adj_surf_name": "..."},
        we can store info for cross-linking. If just a string, e.g. "Outdoors" or "Adiabatic".
    is_top_floor : bool
        If True => create a roof with Outdoors, else => a ceiling with "Adiabatic" (or a placeholder
        that can later be changed to "Surface" if linking to the floor above).

    Returns
    -------
    (zone_name, base_poly, top_poly, created_surfaces)
      zone_name        : str
      base_poly        : list of points (x,y,z) for the floor polygon
      top_poly         : list of points (x,y,z) for the upper polygon (floor + wall_height)
      created_surfaces : list of BUILDINGSURFACE:DETAILED objects created
    """
    zone = idf.newidfobject("ZONE")
    zone.Name = zone_name

    created_surfaces = []

    # ===== Floor =====
    floor_surf = idf.newidfobject("BUILDINGSURFACE:DETAILED")
    floor_surf.Name = f"{zone_name}_Floor"
    floor_surf.Surface_Type = "Floor"
    floor_surf.Zone_Name = zone_name
    floor_surf.Outside_Boundary_Condition = floor_bc

    # If we have "Outdoors", we set SunExposed, WindExposed; else NoSun/NoWind
    if floor_bc.lower() == "outdoors":
        floor_surf.Sun_Exposure = "SunExposed"
        floor_surf.Wind_Exposure = "WindExposed"
    else:
        floor_surf.Sun_Exposure = "NoSun"
        floor_surf.Wind_Exposure = "NoWind"

    # Reverse coords so the floor normal faces downward
    floor_surf.setcoords(base_poly[::-1])
    created_surfaces.append(floor_surf)

    # ===== Walls =====
    # The top polygon is base_poly + wall_height in Z
    top_poly = [(p[0], p[1], p[2] + wall_height) for p in base_poly]
    for i in range(4):
        p1 = base_poly[i]
        p2 = base_poly[(i + 1) % 4]
        p1t = top_poly[i]
        p2t = top_poly[(i + 1) % 4]

        wall_coords = [p1, p2, p2t, p1t]
        wall_obj = idf.newidfobject("BUILDINGSURFACE:DETAILED")
        wall_obj.Name = f"{zone_name}_Wall_{i}"
        wall_obj.Surface_Type = "Wall"
        wall_obj.Zone_Name = zone_name

        bc_info = wall_bcs[i]
        if isinstance(bc_info, dict):
            # If bc_info is a dict => can specify 'bc' and optionally 'adj_surf_name'
            bc_str = bc_info.get("bc", "Adiabatic")
            wall_obj.Outside_Boundary_Condition = bc_str
            if bc_str.lower() == "outdoors":
                wall_obj.Sun_Exposure = "SunExposed"
                wall_obj.Wind_Exposure = "WindExposed"
            else:
                wall_obj.Sun_Exposure = "NoSun"
                wall_obj.Wind_Exposure = "NoWind"

            # If "Surface", optionally set the adjacent surface name
            if bc_str.lower() == "surface":
                adj_name = bc_info.get("adj_surf_name", "")
                wall_obj.Outside_Boundary_Condition_Object = adj_name
        else:
            # bc_info is just a string
            wall_obj.Outside_Boundary_Condition = bc_info
            if bc_info.lower() == "outdoors":
                wall_obj.Sun_Exposure = "SunExposed"
                wall_obj.Wind_Exposure = "WindExposed"
            else:
                wall_obj.Sun_Exposure = "NoSun"
                wall_obj.Wind_Exposure = "NoWind"

        wall_obj.setcoords(wall_coords)
        created_surfaces.append(wall_obj)

    # ===== Ceiling or Roof =====
    if is_top_floor:
        # For top floors, we create a roof surface with "Outdoors"
        top_surf = idf.newidfobject("BUILDINGSURFACE:DETAILED")
        top_surf.Name = f"{zone_name}_Roof"
        top_surf.Surface_Type = "Roof"
        top_surf.Zone_Name = zone_name
        top_surf.Outside_Boundary_Condition = "Outdoors"
        top_surf.Sun_Exposure = "SunExposed"
        top_surf.Wind_Exposure = "WindExposed"
        top_surf.setcoords(top_poly)
        created_surfaces.append(top_surf)
    else:
        # For intermediate floors, we typically do "Ceiling" with "Adiabatic"
        # so it can be changed to "Surface" if we link it to the floor above.
        top_surf = idf.newidfobject("BUILDINGSURFACE:DETAILED")
        top_surf.Name = f"{zone_name}_Ceiling"
        top_surf.Surface_Type = "Ceiling"
        top_surf.Zone_Name = zone_name
        top_surf.Outside_Boundary_Condition = "Adiabatic"
        top_surf.Sun_Exposure = "NoSun"
        top_surf.Wind_Exposure = "NoWind"
        top_surf.setcoords(top_poly)
        created_surfaces.append(top_surf)

    # Return a 4-tuple: (zone_name, base_poly, top_poly, created_surfaces)
    return (zone_name, base_poly, top_poly, created_surfaces)


def create_zones_with_perimeter_depth(
    idf,
    floor_i,
    base_poly,
    wall_height,
    edge_types,
    perimeter_depth,
    floor_type,
    has_core,
    is_top_floor
):
    """
    Create multiple zones (4 perimeter + 1 core) or a single zone if no core.
    Then explicitly cross-link perimeter-to-core surfaces.

    Returns
    -------
    dict : { zone_name => (zname, bpoly, tpoly, list_of_surfaces) }

    Explanation:
      - "floor_type" can be "Ground" for the 1st floor (so floor BC="Ground"), or "Internal" for higher floors (so floor BC="Adiabatic" initially).
      - "edge_types" might be ["facade", "shared", ...], each mapping to "Outdoors" or "Adiabatic".
      - "has_core" => if True, we do perimeter+core. Otherwise, a single zone.

    The final dict has keys = zone_name ("Zone1", "Zone1_Core", etc.),
    each mapping to a tuple of 4 items: (zname, base_poly, top_poly, surfs_list).
    That means index [3] is the list of surfaces, so we can do zone_data[zname][3]
    in building.py.
    """
    def edge_to_bc(e):
        """
        Convert textual edge label to an EnergyPlus BC string:
          - "facade" => "Outdoors"
          - "shared" => "Adiabatic"
          - anything else => "Outdoors"
        """
        e_lower = e.lower().strip()
        if e_lower == "facade":
            return "Outdoors"
        elif e_lower == "shared":
            return "Adiabatic"
        else:
            return "Outdoors"

    zone_data = {}

    # Decide the floor boundary condition
    if floor_type.lower() == "ground":
        floor_bc = "Ground"
    else:
        # For intermediate floors, we temporarily set "Adiabatic"
        # The code in building.py can link surfaces for multi-story conduction.
        floor_bc = "Adiabatic"

    # Try to offset the polygon inward for a core
    A, B, C, D = base_poly
    inner_poly = None
    if has_core:
        inner_poly = inward_offset_polygon(A, B, C, D, perimeter_depth)
        if inner_poly:
            A2, B2, C2, D2 = inner_poly
            # Check if that offset polygon is large enough
            if polygon_area([A2, B2, C2, D2]) < 1e-3:
                inner_poly = None  # not valid => discard

    # ================= Single-Zone Case =================
    if not inner_poly:
        # Means no valid core => only one zone
        wall_bcs = [edge_to_bc(e) for e in edge_types]
        zname, bpoly, tpoly, surfs = create_zone_surfaces(
            idf,
            f"Zone{floor_i}",
            base_poly,
            wall_height,
            floor_bc,
            wall_bcs,
            is_top_floor
        )
        # Store 4 items => so we can do zone_data[zname][3] = surfaces later
        zone_data[zname] = (zname, bpoly, tpoly, surfs)
        return zone_data

    # ================= Perimeter + Core Case =================
    A2, B2, C2, D2 = inner_poly

    # We'll create 4 perimeter zones + 1 core zone

    # 1) Front perimeter
    front_bc = edge_to_bc(edge_types[0])
    front_base = [A, B, B2, A2]
    # We define the perimeter->core edge as the 3rd wall => "Surface"
    front_walls = [front_bc, "Adiabatic", "Surface", "Adiabatic"]
    zf, fbpoly, ftpoly, fsurfs = create_zone_surfaces(
        idf,
        f"Zone{floor_i}_FrontPerimeter",
        front_base,
        wall_height,
        floor_bc,
        front_walls,
        is_top_floor
    )
    zone_data[zf] = (zf, fbpoly, ftpoly, fsurfs)

    # 2) Right perimeter
    right_bc = edge_to_bc(edge_types[1])
    right_base = [B, C, C2, B2]
    right_walls = [right_bc, "Adiabatic", "Surface", "Adiabatic"]
    zr, rbpoly, rtpoly, rsurfs = create_zone_surfaces(
        idf,
        f"Zone{floor_i}_RightPerimeter",
        right_base,
        wall_height,
        floor_bc,
        right_walls,
        is_top_floor
    )
    zone_data[zr] = (zr, rbpoly, rtpoly, rsurfs)

    # 3) Rear perimeter
    rear_bc = edge_to_bc(edge_types[2])
    rear_base = [C, D, D2, C2]
    rear_walls = [rear_bc, "Adiabatic", "Surface", "Adiabatic"]
    zre, rebpoly, retpoly, resurfs = create_zone_surfaces(
        idf,
        f"Zone{floor_i}_RearPerimeter",
        rear_base,
        wall_height,
        floor_bc,
        rear_walls,
        is_top_floor
    )
    zone_data[zre] = (zre, rebpoly, retpoly, resurfs)

    # 4) Left perimeter
    left_bc = edge_to_bc(edge_types[3])
    left_base = [D, A, A2, D2]
    left_walls = [left_bc, "Adiabatic", "Surface", "Adiabatic"]
    zl, lbpoly, ltpoly, lsurfs = create_zone_surfaces(
        idf,
        f"Zone{floor_i}_LeftPerimeter",
        left_base,
        wall_height,
        floor_bc,
        left_walls,
        is_top_floor
    )
    zone_data[zl] = (zl, lbpoly, ltpoly, lsurfs)

    # 5) Core
    #
    # We pass a reversed polygon so each shared edge is reversed wrt the perimeter side:
    core_poly_reversed = [A2, D2, C2, B2]
    # All edges => "Surface" bc
    core_bc = ["Surface", "Surface", "Surface", "Surface"]
    zc, cbpoly, ctpoly, csurfs = create_zone_surfaces(
        idf,
        f"Zone{floor_i}_Core",
        core_poly_reversed,
        wall_height,
        floor_bc,
        core_bc,
        is_top_floor
    )
    zone_data[zc] = (zc, cbpoly, ctpoly, csurfs)

    # ===================== Cross-Linking Perimeter->Core =====================
    #
    # We assume:
    #  - The perimeter zone "Wall_2" (index=2 => array position=3 in the surfaces array) 
    #    is the interior partition to the core.
    #  - The matching core zone side is "Wall_x", using reversed polygon indexing logic.
    #
    # Because we reversed the core polygon, each perimeter edge B2->A2 lines up with A2->B2
    # in the core. We just have to ensure we pick the correct wall indexes.

    def get_wall(surfs, wall_idx):
        """
        For surfs array: 
          index 0 => Floor, 
          index 1..4 => Walls, 
          index 5 => Ceiling/Roof
        So the perimeter interior wall (index=2) => surfs[1+2] => surfs[3].
        """
        return surfs[1 + wall_idx]

    # front perimeter interior => index=2 => surfs[3]
    front_interior = get_wall(fsurfs, 2)
    right_interior = get_wall(rsurfs, 2)
    rear_interior  = get_wall(resurfs, 2)
    left_interior  = get_wall(lsurfs, 2)

    # In the core zone, we have reversed the polygon. We'll map:
    #   - front perimeter => core wall_3
    #   - right perimeter => core wall_2
    #   - rear perimeter  => core wall_1
    #   - left perimeter  => core wall_0
    core_wall_front = get_wall(csurfs, 3)
    core_wall_right = get_wall(csurfs, 2)
    core_wall_rear  = get_wall(csurfs, 1)
    core_wall_left  = get_wall(csurfs, 0)

    link_surfaces(front_interior, core_wall_front)
    link_surfaces(right_interior, core_wall_right)
    link_surfaces(rear_interior, core_wall_rear)
    link_surfaces(left_interior, core_wall_left)

    return zone_data

------------------------------------------------------------

