File: D:\Documents\E_Plus_2030_py\idf_objects\eequip\assign_equip_values.py
============================================================
# eequip/assign_equip_values.py

import random
from .equip_lookup import equip_lookup
from .overrides_helper import find_applicable_overrides  # if you use override logic

def assign_equipment_parameters(
    building_id: int,
    building_type: str,
    age_range=None,
    calibration_stage: str = "pre_calibration",
    strategy: str = "A",
    random_seed: int = None,
    user_config: list = None,     # override table (list of dicts)
    assigned_log: dict = None     # optional dictionary to store final picks
):
    """
    Returns a dict with "equip_wm2", "tD", "tN", etc. for electric equipment.

    Steps:
      1) Check calibration_stage in equip_lookup; else fallback to "pre_calibration".
      2) Get the dictionary for building_type (if missing => pick some default).
      3) If user_config is provided, find all matching override rows for (building_id, building_type, age_range).
      4) For each matching row, override the param's range (min_val, max_val).
      5) Pick final value from the resulting range using 'strategy':
         - A => midpoint
         - B => random
         - else => pick the min_val
      6) Return assigned dictionary, optionally log it in assigned_log[building_id].
    """

    if random_seed is not None:
        random.seed(random_seed)

    # 1) Grab the stage dictionary or fallback
    if calibration_stage not in equip_lookup:
        calibration_stage = "pre_calibration"
    stage_dict = equip_lookup[calibration_stage]

    # 2) Fallback if building_type not found
    if building_type not in stage_dict:
        # Minimal fallback approach
        equip_rng = (3.0, 3.0)
        tD_rng    = (500, 500)
        tN_rng    = (200, 200)
    else:
        param_dict = stage_dict[building_type]
        equip_rng = param_dict.get("EQUIP_WM2_range", (3.0, 3.0))
        tD_rng    = param_dict.get("tD_range", (500, 500))
        tN_rng    = param_dict.get("tN_range", (200, 200))

    # 3) Find override rows
    if user_config is not None:
        matches = find_applicable_overrides(building_id, building_type, age_range, user_config)
    else:
        matches = []

    # 4) Apply overrides
    for row in matches:
        pname = row["param_name"]  # e.g. "equip_wm2", "tD", "tN"
        mn = row["min_val"]
        mx = row["max_val"]

        # Update the relevant range
        if pname == "equip_wm2":
            equip_rng = (mn, mx)
        elif pname == "tD":
            tD_rng = (mn, mx)
        elif pname == "tN":
            tN_rng = (mn, mx)
        # else ignore

    # 5) Strategy to pick final values
    def pick_val(r):
        if strategy == "A":  # midpoint
            return (r[0] + r[1]) / 2.0
        elif strategy == "B":  # random
            return random.uniform(r[0], r[1])
        else:
            return r[0]

    assigned = {
        "equip_wm2": pick_val(equip_rng),
        "tD": pick_val(tD_rng),
        "tN": pick_val(tN_rng)
    }

    # 6) Optional logging
    if assigned_log is not None:
        assigned_log[building_id] = assigned

    return assigned

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\eequip\equip_lookup.py
============================================================
# eequip/equip_lookup.py
"""
Equipment Lookup Table (Pre/Post Calibration)
---------------------------------------------
This file defines default electric equipment parameters for both 
residential and non-residential buildings.

We store everything in a nested dictionary `equip_lookup`, keyed by:
    1) Calibration stage: "pre_calibration" or "post_calibration"
    2) Building category: e.g. "Residential" or "Non-Residential"
    3) Sub-type: e.g. "Corner House", "Office Function", etc.
    4) Parameter key: "EQUIP_WM2_range", "tD_range", "tN_range", etc.

Adjust the default values/ranges for your real-world scenario.
"""

equip_lookup = {
    "pre_calibration": {
        # ===============================
        # 1) RESIDENTIAL (example sub-types)
        # ===============================
        "Residential": {
            "Corner House": {
                "EQUIP_WM2_range": (3.0, 5.0),
                "tD_range": (400, 600),
                "tN_range": (100, 200)
            },
            "Apartment": {
                "EQUIP_WM2_range": (2.0, 4.0),
                "tD_range": (300, 500),
                "tN_range": (100, 200)
            },
            "Terrace or Semi-detached House": {
                "EQUIP_WM2_range": (3.0, 5.0),
                "tD_range": (400, 600),
                "tN_range": (100, 200)
            },
            "Detached House": {
                "EQUIP_WM2_range": (4.0, 6.0),
                "tD_range": (500, 700),
                "tN_range": (200, 300)
            },
            "Two-and-a-half-story House": {
                "EQUIP_WM2_range": (4.0, 6.0),
                "tD_range": (500, 700),
                "tN_range": (200, 300)
            }
        },
        # ===============================
        # 2) NON-RESIDENTIAL (example sub-types)
        # ===============================
        "Non-Residential": {
            "Meeting Function": {
                "EQUIP_WM2_range": (8.0, 10.0),
                "tD_range": (2000, 2200),
                "tN_range": (300, 400)
            },
            "Healthcare Function": {
                "EQUIP_WM2_range": (10.0, 12.0),
                "tD_range": (3000, 4000),
                "tN_range": (600, 800)
            },
            "Sport Function": {
                "EQUIP_WM2_range": (9.0, 11.0),
                "tD_range": (2500, 2700),
                "tN_range": (500, 700)
            },
            "Cell Function": {
                "EQUIP_WM2_range": (8.0, 10.0),
                "tD_range": (3500, 3800),
                "tN_range": (800, 1000)
            },
            "Retail Function": {
                "EQUIP_WM2_range": (10.0, 12.0),
                "tD_range": (2500, 2700),
                "tN_range": (400, 500)
            },
            "Industrial Function": {
                "EQUIP_WM2_range": (12.0, 15.0),
                "tD_range": (3000, 3200),
                "tN_range": (600, 800)
            },
            "Accommodation Function": {
                "EQUIP_WM2_range": (6.0, 8.0),
                "tD_range": (2500, 3000),
                "tN_range": (600, 800)
            },
            "Office Function": {
                "EQUIP_WM2_range": (8.0, 10.0),
                "tD_range": (2000, 2200),
                "tN_range": (300, 400)
            },
            "Education Function": {
                "EQUIP_WM2_range": (7.0, 9.0),
                "tD_range": (1500, 1700),
                "tN_range": (200, 400)
            },
            "Other Use Function": {
                "EQUIP_WM2_range": (5.0, 8.0),
                "tD_range": (1500, 2000),
                "tN_range": (200, 400)
            }
        }
    },

    # ------------------------------------------
    #  POST-CALIBRATION (example narrower ranges)
    # ------------------------------------------
    "post_calibration": {
        "Residential": {
            "Corner House": {
                "EQUIP_WM2_range": (4.0, 4.0),
                "tD_range": (500, 500),
                "tN_range": (150, 150)
            },
            "Apartment": {
                "EQUIP_WM2_range": (3.0, 3.0),
                "tD_range": (400, 400),
                "tN_range": (150, 150)
            },
            "Terrace or Semi-detached House": {
                "EQUIP_WM2_range": (4.0, 4.0),
                "tD_range": (500, 500),
                "tN_range": (150, 150)
            },
            "Detached House": {
                "EQUIP_WM2_range": (5.0, 5.0),
                "tD_range": (600, 600),
                "tN_range": (250, 250)
            },
            "Two-and-a-half-story House": {
                "EQUIP_WM2_range": (5.0, 5.0),
                "tD_range": (600, 600),
                "tN_range": (250, 250)
            }
        },
        "Non-Residential": {
            "Meeting Function": {
                "EQUIP_WM2_range": (9.0, 9.0),
                "tD_range": (2100, 2100),
                "tN_range": (350, 350)
            },
            "Healthcare Function": {
                "EQUIP_WM2_range": (11.0, 11.0),
                "tD_range": (3500, 3500),
                "tN_range": (700, 700)
            },
            "Sport Function": {
                "EQUIP_WM2_range": (10.0, 10.0),
                "tD_range": (2600, 2600),
                "tN_range": (600, 600)
            },
            "Cell Function": {
                "EQUIP_WM2_range": (9.0, 9.0),
                "tD_range": (3600, 3600),
                "tN_range": (900, 900)
            },
            "Retail Function": {
                "EQUIP_WM2_range": (11.0, 11.0),
                "tD_range": (2600, 2600),
                "tN_range": (450, 450)
            },
            "Industrial Function": {
                "EQUIP_WM2_range": (13.0, 13.0),
                "tD_range": (3100, 3100),
                "tN_range": (700, 700)
            },
            "Accommodation Function": {
                "EQUIP_WM2_range": (7.0, 7.0),
                "tD_range": (2700, 2700),
                "tN_range": (700, 700)
            },
            "Office Function": {
                "EQUIP_WM2_range": (9.0, 9.0),
                "tD_range": (2100, 2100),
                "tN_range": (350, 350)
            },
            "Education Function": {
                "EQUIP_WM2_range": (8.0, 8.0),
                "tD_range": (1600, 1600),
                "tN_range": (300, 300)
            },
            "Other Use Function": {
                "EQUIP_WM2_range": (6.0, 6.0),
                "tD_range": (1800, 1800),
                "tN_range": (300, 300)
            }
        }
    }
}

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\eequip\equipment.py
============================================================
"""equipment.py

Adds ELECTRICEQUIPMENT objects to an IDF using default lookup tables
and optional user overrides.
"""

from idf_objects.Elec.lighting import get_building_category_and_subtype
from .assign_equip_values import assign_equipment_parameters
from .schedules import create_equipment_schedule


def add_electric_equipment(
    idf,
    building_row,
    calibration_stage="pre_calibration",
    strategy="A",
    random_seed=None,
    user_config=None,
    assigned_values_log=None,
    zonelist_name="ALL_ZONES",
):
    """Create an ELECTRICEQUIPMENT object for the entire building.

    Parameters
    ----------
    idf : Eppy IDF
        The IDF object to modify.
    building_row : pd.Series or dict
        Row with at least ``ogc_fid`` and ``building_function`` fields.
    calibration_stage : str, default "pre_calibration"
        Lookup key for ``equip_lookup``.
    strategy : str, default "A"
        Selection strategy for value picking.
    random_seed : int, optional
        Seed for the random generator if strategy uses randomness.
    user_config : list of dicts, optional
        Override rows for equipment parameters.
    assigned_values_log : dict, optional
        If provided, the picked parameters are stored under
        ``assigned_values_log[building_id]``.
    zonelist_name : str, default "ALL_ZONES"
        ZoneList name to reference in the created object.
    """

    building_category, sub_type = get_building_category_and_subtype(building_row)
    bldg_id = int(building_row.get("ogc_fid", 0))

    picks = assign_equipment_parameters(
        building_id=bldg_id,
        building_type=sub_type,
        age_range=None,
        calibration_stage=calibration_stage,
        strategy=strategy,
        random_seed=random_seed,
        user_config=user_config,
        assigned_log=assigned_values_log,
    )

    equip_wm2 = picks["equip_wm2"]

    sched_name = create_equipment_schedule(
        idf,
        building_category=building_category,
        sub_type=sub_type,
        schedule_name="EquipSchedule",
    )

    eq_obj = idf.newidfobject("ELECTRICEQUIPMENT")
    eq_obj.Name = f"Equip_{zonelist_name}"
    eq_obj.Zone_or_ZoneList_or_Space_or_SpaceList_Name = zonelist_name
    eq_obj.Schedule_Name = sched_name
    eq_obj.Design_Level_Calculation_Method = "Watts/Area"
    eq_obj.Watts_per_Zone_Floor_Area = equip_wm2

    return eq_obj

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\eequip\schedule_def.py
============================================================
# eequip/schedule_def.py

"""
EQUIP_SCHEDULE_DEFINITIONS
===========================
This dictionary defines typical usage patterns for electric equipment
throughout the day, differentiating weekday vs. weekend, and by building
category (Residential vs. Non-Residential) and sub-type (e.g. "Corner House", 
"Office Function", etc.).

Each sub-type entry contains two keys:
 - "weekday": a list of (start_hour, end_hour, fraction)
 - "weekend": a list of (start_hour, end_hour, fraction)

The fraction represents the fraction of peak equipment load during that time.
"""

EQUIP_SCHEDULE_DEFINITIONS = {
    "Residential": {
        "Corner House": {
            "weekday": [
                (0, 6, 0.10),
                (6, 9, 0.40),
                (9, 17, 0.20),
                (17, 21, 0.60),
                (21, 24, 0.20),
            ],
            "weekend": [
                (0, 9, 0.25),
                (9, 22, 0.50),
                (22, 24, 0.25),
            ],
        },
        "Apartment": {
            "weekday": [
                (0, 6, 0.05),
                (6, 8, 0.20),
                (8, 18, 0.10),
                (18, 23, 0.60),
                (23, 24, 0.05),
            ],
            "weekend": [
                (0, 9, 0.15),
                (9, 22, 0.50),
                (22, 24, 0.15),
            ],
        },
        "Terrace or Semi-detached House": {
            "weekday": [
                (0, 7, 0.05),
                (7, 9, 0.20),
                (9, 17, 0.10),
                (17, 22, 0.60),
                (22, 24, 0.05),
            ],
            "weekend": [
                (0, 9, 0.10),
                (9, 22, 0.50),
                (22, 24, 0.10),
            ],
        },
        "Detached House": {
            "weekday": [
                (0, 7, 0.05),
                (7, 9, 0.20),
                (9, 17, 0.10),
                (17, 22, 0.60),
                (22, 24, 0.05),
            ],
            "weekend": [
                (0, 9, 0.10),
                (9, 22, 0.50),
                (22, 24, 0.10),
            ],
        },
        "Two-and-a-half-story House": {
            "weekday": [
                (0, 6, 0.05),
                (6, 9, 0.20),
                (9, 18, 0.10),
                (18, 23, 0.60),
                (23, 24, 0.05),
            ],
            "weekend": [
                (0, 9, 0.10),
                (9, 22, 0.50),
                (22, 24, 0.10),
            ],
        },
    },
    "Non-Residential": {
        "Meeting Function": {
            "weekday": [
                (0, 6, 0.05),
                (6, 9, 0.50),
                (9, 12, 0.80),
                (12, 13, 0.50),
                (13, 18, 0.80),
                (18, 20, 0.50),
                (20, 24, 0.10),
            ],
            "weekend": [
                (0, 24, 0.10),
            ],
        },
        "Healthcare Function": {
            "weekday": [
                (0, 24, 0.80),
            ],
            "weekend": [
                (0, 24, 0.80),
            ],
        },
        "Sport Function": {
            "weekday": [
                (0, 6, 0.05),
                (6, 9, 0.20),
                (9, 12, 0.70),
                (12, 14, 0.50),
                (14, 22, 0.70),
                (22, 24, 0.10),
            ],
            "weekend": [
                (0, 9, 0.10),
                (9, 22, 0.70),
                (22, 24, 0.10),
            ],
        },
        "Cell Function": {
            "weekday": [
                (0, 24, 0.90),
            ],
            "weekend": [
                (0, 24, 0.90),
            ],
        },
        "Retail Function": {
            "weekday": [
                (0, 6, 0.05),
                (6, 9, 0.30),
                (9, 19, 0.90),
                (19, 21, 0.50),
                (21, 24, 0.05),
            ],
            "weekend": [
                (0, 8, 0.10),
                (8, 19, 0.80),
                (19, 22, 0.30),
                (22, 24, 0.10),
            ],
        },
        "Industrial Function": {
            "weekday": [
                (0, 6, 0.20),
                (6, 8, 0.50),
                (8, 17, 0.80),
                (17, 20, 0.50),
                (20, 24, 0.20),
            ],
            "weekend": [
                (0, 24, 0.20),
            ],
        },
        "Accommodation Function": {
            "weekday": [
                (0, 24, 0.70),
            ],
            "weekend": [
                (0, 24, 0.70),
            ],
        },
        "Office Function": {
            "weekday": [
                (0, 6, 0.10),
                (6, 9, 0.50),
                (9, 12, 0.90),
                (12, 13, 0.70),
                (13, 18, 0.90),
                (18, 20, 0.50),
                (20, 24, 0.10),
            ],
            "weekend": [
                (0, 24, 0.10),
            ],
        },
        "Education Function": {
            "weekday": [
                (0, 7, 0.05),
                (7, 8, 0.50),
                (8, 16, 0.80),
                (16, 18, 0.50),
                (18, 24, 0.05),
            ],
            "weekend": [
                (0, 24, 0.10),
            ],
        },
        "Other Use Function": {
            "weekday": [
                (0, 24, 0.30),
            ],
            "weekend": [
                (0, 24, 0.20),
            ],
        },
    },
}


def read_schedule_overrides_from_excel(excel_path):
    """Read Excel overrides for schedule definitions."""
    import pandas as pd

    df = pd.read_excel(excel_path)
    required = [
        "building_category",
        "sub_type",
        "day_type",
        "start_hour",
        "end_hour",
        "fraction_value",
    ]
    for c in required:
        if c not in df.columns:
            raise ValueError(f"Missing column '{c}' in {excel_path}")

    overrides = {}
    for _, row in df.iterrows():
        cat = str(row["building_category"]).strip()
        stype = str(row["sub_type"]).strip()
        dtype = str(row["day_type"]).strip().lower()
        block = (float(row["start_hour"]), float(row["end_hour"]), float(row["fraction_value"]))

        overrides.setdefault(cat, {}).setdefault(stype, {}).setdefault(dtype, []).append(block)

    return overrides


def apply_schedule_overrides_to_schedules(base_schedules, overrides):
    """Merge schedule overrides into ``base_schedules`` in-place."""
    for cat, stypes in overrides.items():
        if cat not in base_schedules:
            base_schedules[cat] = {}
        for stype, days in stypes.items():
            if stype not in base_schedules[cat]:
                base_schedules[cat][stype] = {}
            for day_type, blocks in days.items():
                base_schedules[cat][stype][day_type] = blocks

    return base_schedules

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\eequip\schedules.py
============================================================
# eequip/schedules.py

from .schedule_def import EQUIP_SCHEDULE_DEFINITIONS

"""
This module creates detailed schedules for electric equipment usage
(weekday vs. weekend), differentiating by building category (Residential vs. Non-Residential)
and sub-type (e.g. Corner House, Office, Retail, etc.).

We provide two main functions:

1) create_equipment_schedule(idf, building_category, sub_type, schedule_name)
   - Creates a multi-day schedule with 'WeekDays', 'Saturday', 'Sunday'.

2) create_equipment_parasitic_schedule(idf, sched_name)
   - Creates a schedule that is always ON (1.0).
"""


def create_equipment_schedule(idf, building_category, sub_type, schedule_name="EquipSchedule"):
    """
    Creates a SCHEDULE:COMPACT object in the IDF representing a typical 
    equipment usage pattern for weekdays vs. weekends, based on 
    EQUIP_SCHEDULE_DEFINITIONS.

    Parameters:
        - idf: Eppy IDF object (or a similar interface)
        - building_category: e.g. "Residential" or "Non-Residential"
        - sub_type: e.g. "Corner House", "Office Function"
        - schedule_name: name of the schedule in IDF

    Returns:
        - The name of the new schedule object (same as schedule_name).
    """

    # Attempt to retrieve a sub-type dict. If not found, fallback to a simple 0.5 fraction all day.
    try:
        sub_dict = EQUIP_SCHEDULE_DEFINITIONS[building_category][sub_type]
    except KeyError:
        sub_dict = {
            "weekday": [(0, 24, 0.5)],
            "weekend": [(0, 24, 0.5)],
        }

    # Create a new schedule object in the IDF
    schedule = idf.newidfobject("SCHEDULE:COMPACT")
    schedule.Name = schedule_name
    schedule.Schedule_Type_Limits_Name = "Fraction"

    # We'll define a pattern that covers the full year:
    field_idx = 1

    # First line: "Through: 12/31"
    setattr(schedule, f"Field_{field_idx}", "Through: 12/31")
    field_idx += 1

    # 1) WeekDays
    setattr(schedule, f"Field_{field_idx}", "For: WeekDays")
    field_idx += 1
    for (start_hour, end_hour, fraction) in sub_dict["weekday"]:
        setattr(
            schedule,
            f"Field_{field_idx}",
            f"Until: {end_hour:02d}:00,{fraction:.2f}"
        )
        field_idx += 1

    # 2) Saturday
    setattr(schedule, f"Field_{field_idx}", "For: Saturday")
    field_idx += 1
    for (start_hour, end_hour, fraction) in sub_dict["weekend"]:
        setattr(
            schedule,
            f"Field_{field_idx}",
            f"Until: {end_hour:02d}:00,{fraction:.2f}"
        )
        field_idx += 1

    # 3) Sunday
    setattr(schedule, f"Field_{field_idx}", "For: Sunday")
    field_idx += 1
    for (start_hour, end_hour, fraction) in sub_dict["weekend"]:
        setattr(
            schedule,
            f"Field_{field_idx}",
            f"Until: {end_hour:02d}:00,{fraction:.2f}"
        )
        field_idx += 1

    return schedule.Name


def create_equipment_parasitic_schedule(idf, sched_name="EquipParasiticSchedule"):
    """
    Creates a schedule that is always ON at 1.0 for parasitic equipment loads.
    You can also rename it or adjust if you want partial load or special schedules.

    Parameters:
        - idf: Eppy IDF object
        - sched_name: the schedule name in the IDF

    Returns:
        - The name of the new schedule object
    """

    schedule = idf.newidfobject("SCHEDULE:COMPACT")
    schedule.Name = sched_name
    schedule.Schedule_Type_Limits_Name = "Fraction"

    # A simple all-day, all-year schedule at 1.0
    schedule.Field_1 = "Through: 12/31"
    schedule.Field_2 = "For: AllDays"
    schedule.Field_3 = "Until: 24:00,1.0"

    return schedule.Name

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\Elec\assign_lighting_values.py
============================================================
# Elec/assign_lighting_values.py

import random
from .lighting_lookup import lighting_lookup
from .constants import (
    DEFAULT_LIGHTING_WM2,
    DEFAULT_PARASITIC_WM2,
    DEFAULT_TD,
    DEFAULT_TN,
    # If needed:
    # DEFAULT_EQUIP_FRACTION_LOST,
)
from .overrides_helper import find_applicable_overrides


def assign_lighting_parameters(
    building_id: int,
    building_type: str,
    age_range=None,
    calibration_stage: str = "pre_calibration",
    strategy: str = "A",
    random_seed: int = None,
    user_config: list = None,     # list of override dicts from lighting.json
    assigned_log: dict = None     # optional dictionary to store final picks
):
    """
    Determines final lighting parameters for a given building,
    merging any user overrides from `lighting.json` with default 
    ranges found in lighting_lookup[calibration_stage][building_type].

    The returned dict has keys like "lights_wm2", "parasitic_wm2", 
    "tD", "tN", "lights_fraction_radiant", etc. Each key maps to a
    sub-dict of the form:
      {
        "assigned_value": float,
        "min_val": float,
        "max_val": float,
        "object_name": "LIGHTS" or "ELECTRICEQUIPMENT" etc.
      }

    Steps:
      1) Identify default ranges from `lighting_lookup[calibration_stage][building_type]`.
         If building_type not found, fallback to constants.
      2) If user_config is provided, find all rows that match (building_id, building_type, age_range).
      3) Override the relevant ranges with those rows (either fixed_value => (v,v) or min_val/max_val).
      4) Pick the final assigned value from the resulting range using strategy:
         - "A" => midpoint
         - "B" => random.uniform
         - else => pick the lower bound
      5) Construct a final dict describing the assigned values 
         and (optionally) store in assigned_log[building_id].

    Parameters
    ----------
    building_id : int
        Unique identifier for the building (e.g. ogc_fid).
    building_type : str
        A string matching the keys in lighting_lookup[stage], e.g. "Residential" or "Non-Residential".
    age_range : str, optional
        If you want to filter overrides by age_range.
    calibration_stage : str, default "pre_calibration"
        Typically "pre_calibration" or "post_calibration" (used as a top-level key in lighting_lookup).
    strategy : {"A","B"}, default "A"
        "A" => pick midpoint in [min_val, max_val], "B" => pick random in that range.
    random_seed : int, optional
        If you want reproducible random picks, pass an integer seed.
    user_config : list of dicts, optional
        The override data from lighting.json. Each dict can have fields like:
          {
             "building_id": 4136730,
             "building_type": "Residential",
             "param_name": "lights_wm2",
             "min_val": 8.0,
             "max_val": 10.0
          }
        or "fixed_value": ...
    assigned_log : dict, optional
        If provided, the final structured picks are stored as assigned_log[building_id].

    Returns
    -------
    dict
        A dictionary describing final picks, e.g.:
        {
          "lights_wm2": {
            "assigned_value": 9.0,
            "min_val": 8.0,
            "max_val": 10.0,
            "object_name": "LIGHTS"
          },
          ...
        }
    """

    # (A) Set random seed if specified
    if random_seed is not None:
        random.seed(random_seed)

    # (B) Get the "stage_dict" for the given calibration_stage
    if calibration_stage not in lighting_lookup:
        calibration_stage = "pre_calibration"
    stage_dict = lighting_lookup[calibration_stage]

    # Convert building_type to a consistent case if needed, e.g. "Residential" => "Residential"
    # and "non_residential" => "Non-Residential" if that's your dictionary's exact key.
    # Example:
    if building_type.lower() == "residential":
        building_type = "Residential"
    elif building_type.lower() == "non_residential":
        building_type = "Non-Residential"

    # (C) If building_type not in the stage dict => fallback to "defaults"
    if building_type not in stage_dict:
        # Fallback block
        fallback = {
            "lights_wm2": {
                "assigned_value": DEFAULT_LIGHTING_WM2,
                "min_val": DEFAULT_LIGHTING_WM2,
                "max_val": DEFAULT_LIGHTING_WM2,
                "object_name": "LIGHTS"
            },
            "parasitic_wm2": {
                "assigned_value": DEFAULT_PARASITIC_WM2,
                "min_val": DEFAULT_PARASITIC_WM2,
                "max_val": DEFAULT_PARASITIC_WM2,
                "object_name": "ELECTRICEQUIPMENT"
            },
            "tD": {
                "assigned_value": DEFAULT_TD,
                "min_val": DEFAULT_TD,
                "max_val": DEFAULT_TD,
                "object_name": "LIGHTS_SCHEDULE"
            },
            "tN": {
                "assigned_value": DEFAULT_TN,
                "min_val": DEFAULT_TN,
                "max_val": DEFAULT_TN,
                "object_name": "LIGHTS_SCHEDULE"
            },
            "lights_fraction_radiant": {
                "assigned_value": 0.7,
                "min_val": 0.7,
                "max_val": 0.7,
                "object_name": "LIGHTS.Fraction_Radiant"
            },
            "lights_fraction_visible": {
                "assigned_value": 0.2,
                "min_val": 0.2,
                "max_val": 0.2,
                "object_name": "LIGHTS.Fraction_Visible"
            },
            "lights_fraction_replaceable": {
                "assigned_value": 1.0,
                "min_val": 1.0,
                "max_val": 1.0,
                "object_name": "LIGHTS.Fraction_Replaceable"
            },
            "equip_fraction_radiant": {
                "assigned_value": 0.0,
                "min_val": 0.0,
                "max_val": 0.0,
                "object_name": "ELECTRICEQUIPMENT.Fraction_Radiant"
            },
            "equip_fraction_lost": {
                "assigned_value": 1.0,
                "min_val": 1.0,
                "max_val": 1.0,
                "object_name": "ELECTRICEQUIPMENT.Fraction_Lost"
            }
        }
        if assigned_log is not None:
            assigned_log[building_id] = fallback
        return fallback

    # Otherwise, retrieve the param_dict for that building_type
    param_dict = stage_dict[building_type]

    # (D) Extract default ranges
    lights_rng    = param_dict.get("LIGHTS_WM2_range", (DEFAULT_LIGHTING_WM2, DEFAULT_LIGHTING_WM2))
    parasitic_rng = param_dict.get("PARASITIC_WM2_range", (DEFAULT_PARASITIC_WM2, DEFAULT_PARASITIC_WM2))
    tD_rng        = param_dict.get("tD_range", (DEFAULT_TD, DEFAULT_TD))
    tN_rng        = param_dict.get("tN_range", (DEFAULT_TN, DEFAULT_TN))

    lights_fraction_radiant_rng     = param_dict.get("lights_fraction_radiant_range", (0.7, 0.7))
    lights_fraction_visible_rng     = param_dict.get("lights_fraction_visible_range", (0.2, 0.2))
    lights_fraction_replace_rng     = param_dict.get("lights_fraction_replaceable_range", (1.0, 1.0))

    equip_fraction_radiant_rng = param_dict.get("equip_fraction_radiant_range", (0.0, 0.0))
    equip_fraction_lost_rng    = param_dict.get("equip_fraction_lost_range", (1.0, 1.0))

    # (E) Find any user overrides that apply
    if user_config is not None:
        matches = find_applicable_overrides(building_id, building_type, age_range, user_config)
    else:
        matches = []

    # Debug: See which overrides matched
    print(f"[DEBUG lighting] bldg_id={building_id}, type='{building_type}', matched overrides => {matches}")

    # (F) Override default ranges with user-config
    for row in matches:
        pname = row.get("param_name", "").strip().lower()
        fv = row.get("fixed_value", None)  # optional direct fix
        mn = row.get("min_val", None)
        mx = row.get("max_val", None)

        # If row has a fixed_value => treat it as (fv, fv)
        if fv is not None:
            rng = (float(fv), float(fv))
        elif mn is not None and mx is not None:
            rng = (float(mn), float(mx))
        else:
            rng = None

        if rng:
            if pname == "lights_wm2":
                lights_rng = rng
            elif pname == "parasitic_wm2":
                parasitic_rng = rng
            elif pname == "td":
                tD_rng = rng
            elif pname == "tn":
                tN_rng = rng
            elif pname == "lights_fraction_radiant":
                lights_fraction_radiant_rng = rng
            elif pname == "lights_fraction_visible":
                lights_fraction_visible_rng = rng
            elif pname == "lights_fraction_replaceable":
                lights_fraction_replace_rng = rng
            elif pname == "equip_fraction_radiant":
                equip_fraction_radiant_rng = rng
            elif pname == "equip_fraction_lost":
                equip_fraction_lost_rng = rng
            # else param_name not recognized => ignore

    # Helper to pick final value from a (min,max) range
    def pick_val(r):
        if strategy == "A":   # midpoint
            return (r[0] + r[1]) / 2.0
        elif strategy == "B": # random
            return random.uniform(r[0], r[1])
        else:
            # fallback => pick min
            return r[0]

    # (G) Pick final values
    assigned_lights = pick_val(lights_rng)
    assigned_paras  = pick_val(parasitic_rng)
    assigned_tD     = pick_val(tD_rng)
    assigned_tN     = pick_val(tN_rng)

    assigned_lights_frac_rad = pick_val(lights_fraction_radiant_rng)
    assigned_lights_frac_vis = pick_val(lights_fraction_visible_rng)
    assigned_lights_frac_rep = pick_val(lights_fraction_replace_rng)
    assigned_equip_frac_rad  = pick_val(equip_fraction_radiant_rng)
    assigned_equip_frac_lost = pick_val(equip_fraction_lost_rng)

    # (H) Build final dict
    assigned = {
        "lights_wm2": {
            "assigned_value": assigned_lights,
            "min_val": lights_rng[0],
            "max_val": lights_rng[1],
            "object_name": "LIGHTS"
        },
        "parasitic_wm2": {
            "assigned_value": assigned_paras,
            "min_val": parasitic_rng[0],
            "max_val": parasitic_rng[1],
            "object_name": "ELECTRICEQUIPMENT"
        },
        "tD": {
            "assigned_value": assigned_tD,
            "min_val": tD_rng[0],
            "max_val": tD_rng[1],
            "object_name": "LIGHTS_SCHEDULE"
        },
        "tN": {
            "assigned_value": assigned_tN,
            "min_val": tN_rng[0],
            "max_val": tN_rng[1],
            "object_name": "LIGHTS_SCHEDULE"
        },

        "lights_fraction_radiant": {
            "assigned_value": assigned_lights_frac_rad,
            "min_val": lights_fraction_radiant_rng[0],
            "max_val": lights_fraction_radiant_rng[1],
            "object_name": "LIGHTS.Fraction_Radiant"
        },
        "lights_fraction_visible": {
            "assigned_value": assigned_lights_frac_vis,
            "min_val": lights_fraction_visible_rng[0],
            "max_val": lights_fraction_visible_rng[1],
            "object_name": "LIGHTS.Fraction_Visible"
        },
        "lights_fraction_replaceable": {
            "assigned_value": assigned_lights_frac_rep,
            "min_val": lights_fraction_replace_rng[0],
            "max_val": lights_fraction_replace_rng[1],
            "object_name": "LIGHTS.Fraction_Replaceable"
        },

        "equip_fraction_radiant": {
            "assigned_value": assigned_equip_frac_rad,
            "min_val": equip_fraction_radiant_rng[0],
            "max_val": equip_fraction_radiant_rng[1],
            "object_name": "ELECTRICEQUIPMENT.Fraction_Radiant"
        },
        "equip_fraction_lost": {
            "assigned_value": assigned_equip_frac_lost,
            "min_val": equip_fraction_lost_rng[0],
            "max_val": equip_fraction_lost_rng[1],
            "object_name": "ELECTRICEQUIPMENT.Fraction_Lost"
        }
    }

    # (I) Optionally store in assigned_log
    if assigned_log is not None:
        assigned_log[building_id] = assigned

    return assigned

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\Elec\constants.py
============================================================
# Elec/constants.py

"""
Global constants or default fallback values for the lighting module.
These can be overridden by user configs or Excel-based overrides.
"""

# Default power density values (W/mÂ²)
DEFAULT_LIGHTING_WM2 = 10.0
DEFAULT_PARASITIC_WM2 = 0.285

# Default burning hours if not found in the lookup
DEFAULT_TD = 2000
DEFAULT_TN = 300

# Optional: If you want fraction parameter defaults here
# (instead of defining them in the fallback block of assign_lighting_values.py),
# you can do so, e.g.:
DEFAULT_LIGHTS_FRACTION_RADIANT = 0.7
DEFAULT_LIGHTS_FRACTION_VISIBLE = 0.2
DEFAULT_LIGHTS_FRACTION_REPLACEABLE = 1.0

DEFAULT_EQUIP_FRACTION_RADIANT = 0.0
DEFAULT_EQUIP_FRACTION_LOST = 1.0

# You can import & use these defaults in assign_lighting_values.py
# or wherever you handle fraction parameters.

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\Elec\lighting_lookup.py
============================================================
# Elec/lighting_lookup.py

"""
Lighting Lookup Table (Pre/Post Calibration)
---------------------------------------------
This version includes fraction parameters for both LIGHTS
and ELECTRICEQUIPMENT objects, so that they can be overridden
just like lights_wm2 and parasitic_wm2.
"""

lighting_lookup = {
    "pre_calibration": {
        # ===============================
        # 1) RESIDENTIAL (all sub-types)
        # ===============================
        # Per NTA 8800 references (example): 
        # lights_wm2/parasitic_wm2 => 0.0
        # fraction radiant => 0.7, fraction visible => 0.2, fraction replaceable => 1.0
        # eq_obj fraction radiant => 0.0, fraction lost => 1.0
        "Residential": {
            "Corner House": {
                "LIGHTS_WM2_range": (0.0, 0.0),
                "PARASITIC_WM2_range": (0.0, 0.0),
                "tD_range": (0, 0),
                "tN_range": (0, 0),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Apartment": {
                "LIGHTS_WM2_range": (0.0, 0.0),
                "PARASITIC_WM2_range": (0.0, 0.0),
                "tD_range": (0, 0),
                "tN_range": (0, 0),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Terrace or Semi-detached House": {
                "LIGHTS_WM2_range": (0.0, 0.0),
                "PARASITIC_WM2_range": (0.0, 0.0),
                "tD_range": (0, 0),
                "tN_range": (0, 0),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Detached House": {
                "LIGHTS_WM2_range": (0.0, 0.0),
                "PARASITIC_WM2_range": (0.0, 0.0),
                "tD_range": (0, 0),
                "tN_range": (0, 0),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Two-and-a-half-story House": {
                "LIGHTS_WM2_range": (0.0, 0.0),
                "PARASITIC_WM2_range": (0.0, 0.0),
                "tD_range": (0, 0),
                "tN_range": (0, 0),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            }
        },

        # ===============================
        # 2) NON-RESIDENTIAL
        # ===============================
        "Non-Residential": {
            "Meeting Function": {
                "LIGHTS_WM2_range": (16.0, 18.0),
                "PARASITIC_WM2_range": (0.28, 0.30),
                "tD_range": (2100, 2300),
                "tN_range": (300, 400),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Healthcare Function": {
                "LIGHTS_WM2_range": (17.0, 19.0),
                "PARASITIC_WM2_range": (0.28, 0.31),
                "tD_range": (2100, 4200),
                "tN_range": (300, 1100),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Sport Function": {
                "LIGHTS_WM2_range": (16.0, 18.0),
                "PARASITIC_WM2_range": (0.28, 0.30),
                "tD_range": (2100, 2300),
                "tN_range": (700, 900),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Cell Function": {
                "LIGHTS_WM2_range": (16.0, 18.0),
                "PARASITIC_WM2_range": (0.28, 0.30),
                "tD_range": (3800, 4200),
                "tN_range": (900, 1100),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Retail Function": {
                "LIGHTS_WM2_range": (29.0, 31.0),
                "PARASITIC_WM2_range": (0.28, 0.30),
                "tD_range": (2600, 2800),
                "tN_range": (300, 500),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Industrial Function": {
                "LIGHTS_WM2_range": (16.0, 18.0),
                "PARASITIC_WM2_range": (0.28, 0.30),
                "tD_range": (2100, 2300),
                "tN_range": (300, 400),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Accommodation Function": {
                "LIGHTS_WM2_range": (16.0, 18.0),
                "PARASITIC_WM2_range": (0.28, 0.30),
                "tD_range": (3800, 4200),
                "tN_range": (900, 1100),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Office Function": {
                "LIGHTS_WM2_range": (15.0, 17.0),
                "PARASITIC_WM2_range": (0.28, 0.29),
                "tD_range": (2100, 2300),
                "tN_range": (300, 400),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Education Function": {
                "LIGHTS_WM2_range": (13.0, 16.0),
                "PARASITIC_WM2_range": (0.28, 0.30),
                "tD_range": (1500, 1700),
                "tN_range": (200, 400),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Other Use Function": {
                "LIGHTS_WM2_range": (15.0, 18.0),
                "PARASITIC_WM2_range": (0.28, 0.30),
                "tD_range": (2000, 2500),
                "tN_range": (200, 500),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            }
        }
    },

    # ----------------------------------------------------------------
    # Post-calibration stage: narrower or locked values (example only)
    # ----------------------------------------------------------------
    "post_calibration": {
        "Residential": {
            "Corner House": {
                "LIGHTS_WM2_range": (0.0, 0.0),
                "PARASITIC_WM2_range": (0.0, 0.0),
                "tD_range": (0, 0),
                "tN_range": (0, 0),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Apartment": {
                "LIGHTS_WM2_range": (0.0, 0.0),
                "PARASITIC_WM2_range": (0.0, 0.0),
                "tD_range": (0, 0),
                "tN_range": (0, 0),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Terrace or Semi-detached House": {
                "LIGHTS_WM2_range": (0.0, 0.0),
                "PARASITIC_WM2_range": (0.0, 0.0),
                "tD_range": (0, 0),
                "tN_range": (0, 0),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Detached House": {
                "LIGHTS_WM2_range": (0.0, 0.0),
                "PARASITIC_WM2_range": (0.0, 0.0),
                "tD_range": (0, 0),
                "tN_range": (0, 0),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Two-and-a-half-story House": {
                "LIGHTS_WM2_range": (0.0, 0.0),
                "PARASITIC_WM2_range": (0.0, 0.0),
                "tD_range": (0, 0),
                "tN_range": (0, 0),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            }
        },
        "Non-Residential": {
            "Meeting Function": {
                "LIGHTS_WM2_range": (17.0, 17.0),
                "PARASITIC_WM2_range": (0.285, 0.285),
                "tD_range": (2200, 2200),
                "tN_range": (300, 300),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Healthcare Function": {
                "LIGHTS_WM2_range": (18.0, 18.0),
                "PARASITIC_WM2_range": (0.29, 0.29),
                "tD_range": (4000, 4000),
                "tN_range": (1000, 1000),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Sport Function": {
                "LIGHTS_WM2_range": (17.0, 17.0),
                "PARASITIC_WM2_range": (0.285, 0.285),
                "tD_range": (2200, 2200),
                "tN_range": (800, 800),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Cell Function": {
                "LIGHTS_WM2_range": (17.0, 17.0),
                "PARASITIC_WM2_range": (0.285, 0.285),
                "tD_range": (4000, 4000),
                "tN_range": (1000, 1000),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Retail Function": {
                "LIGHTS_WM2_range": (30.0, 30.0),
                "PARASITIC_WM2_range": (0.285, 0.285),
                "tD_range": (2700, 2700),
                "tN_range": (400, 400),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Industrial Function": {
                "LIGHTS_WM2_range": (17.0, 17.0),
                "PARASITIC_WM2_range": (0.285, 0.285),
                "tD_range": (2200, 2200),
                "tN_range": (300, 300),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Accommodation Function": {
                "LIGHTS_WM2_range": (17.0, 17.0),
                "PARASITIC_WM2_range": (0.285, 0.285),
                "tD_range": (4000, 4000),
                "tN_range": (1000, 1000),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Office Function": {
                "LIGHTS_WM2_range": (16.0, 16.0),
                "PARASITIC_WM2_range": (0.285, 0.285),
                "tD_range": (2200, 2200),
                "tN_range": (300, 300),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Education Function": {
                "LIGHTS_WM2_range": (15.0, 15.0),
                "PARASITIC_WM2_range": (0.285, 0.285),
                "tD_range": (1600, 1600),
                "tN_range": (300, 300),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Other Use Function": {
                "LIGHTS_WM2_range": (16.0, 16.0),
                "PARASITIC_WM2_range": (0.285, 0.285),
                "tD_range": (2200, 2200),
                "tN_range": (300, 300),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            }
        }
    }
}

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\Elec\lighting.py
============================================================
# Elec/lighting.py

from .assign_lighting_values import assign_lighting_parameters
from .schedules import create_lighting_schedule, create_parasitic_schedule

def get_building_category_and_subtype(building_row):
    """
    Returns (building_category, sub_type) strings based on building_row.
    Adjust the logic as needed, depending on how your CSV or DB fields
    are structured.

    If building_row["building_function"] is something like "Residential"
    or "Meeting Function", use that as your sub_type.
    If building_row["building_function"] says "Residential", set building_category="Residential".
    Otherwise, assume building_category="Non-Residential".

    Update as necessary for your own classification logic.
    """
    bldg_func = building_row.get("building_function", "").strip()
    if not bldg_func:
        # fallback
        return ("Non-Residential", "Other Use Function")

    # Example simple logic:
    if "resid" in bldg_func.lower():
        building_category = "Residential"
        sub_type = bldg_func  # e.g. "Residential" or "Corner House"
    else:
        building_category = "Non-Residential"
        sub_type = bldg_func  # e.g. "Office Function", "Meeting Function"

    return (building_category, sub_type)


def add_lights_and_parasitics(
    idf,
    building_row,
    calibration_stage="pre_calibration",
    strategy="A",
    random_seed=None,
    user_config=None,
    assigned_values_log=None,
    zonelist_name="ALL_ZONES"
):
    """
    1) Determine building_category (Residential/Non-Residential) and sub_type.
    2) Retrieve assigned lighting parameters (including fraction fields).
    3) Create schedules in IDF:
       - A lighting schedule for the LIGHTS object
       - An always-on parasitic schedule for ELECTRICEQUIPMENT
    4) Add LIGHTS and ELECTRICEQUIPMENT objects referencing a ZoneList in the IDF.

    The assigned parameters and final picks are stored in assigned_values_log[ogc_fid]
    if assigned_values_log is provided.
    """

    # 1) Get building_category / sub_type
    building_category, sub_type = get_building_category_and_subtype(building_row)

    # 2) Retrieve lighting parameters
    bldg_id = int(building_row.get("ogc_fid", 0))

    assigned_dict = assign_lighting_parameters(
        building_id=bldg_id,
        building_type=sub_type,
        # Optional:
        # age_range=building_row.get("age_range", None),
        calibration_stage=calibration_stage,
        strategy=strategy,
        random_seed=random_seed,
        user_config=user_config,
        assigned_log=assigned_values_log  # logs the final sub-dict structure
    )

    # Extract main power densities
    lights_wm2 = assigned_dict["lights_wm2"]["assigned_value"]
    parasitic_wm2 = assigned_dict["parasitic_wm2"]["assigned_value"]

    # Extract fraction parameters for LIGHTS
    lights_frac_radiant = assigned_dict["lights_fraction_radiant"]["assigned_value"]
    lights_frac_visible = assigned_dict["lights_fraction_visible"]["assigned_value"]
    lights_frac_replace = assigned_dict["lights_fraction_replaceable"]["assigned_value"]

    # Extract fraction parameters for EQUIPMENT
    equip_frac_radiant = assigned_dict["equip_fraction_radiant"]["assigned_value"]
    equip_frac_lost = assigned_dict["equip_fraction_lost"]["assigned_value"]

    # 3) Create schedules
    lights_sched_name = create_lighting_schedule(
        idf,
        building_category=building_category,
        sub_type=sub_type,
        schedule_name="LightsSchedule"
    )
    paras_sched_name = create_parasitic_schedule(idf, sched_name="ParasiticSchedule")

    # 4) Add a single LIGHTS object for the entire ZoneList
    lights_obj = idf.newidfobject("LIGHTS")
    lights_obj.Name = f"Lights_{zonelist_name}"
    lights_obj.Zone_or_ZoneList_or_Space_or_SpaceList_Name = zonelist_name
    lights_obj.Schedule_Name = lights_sched_name
    lights_obj.Design_Level_Calculation_Method = "Watts/Area"
    lights_obj.Watts_per_Zone_Floor_Area = lights_wm2

    # Apply fraction fields
    lights_obj.Fraction_Radiant = lights_frac_radiant
    lights_obj.Fraction_Visible = lights_frac_visible
    lights_obj.Fraction_Replaceable = lights_frac_replace

    # Add ELECTRICEQUIPMENT object for parasitic loads
    eq_obj = idf.newidfobject("ELECTRICEQUIPMENT")
    eq_obj.Name = f"Parasitic_{zonelist_name}"
    eq_obj.Zone_or_ZoneList_or_Space_or_SpaceList_Name = zonelist_name
    eq_obj.Schedule_Name = paras_sched_name
    eq_obj.Design_Level_Calculation_Method = "Watts/Area"
    eq_obj.Watts_per_Zone_Floor_Area = parasitic_wm2

    # Apply fraction fields
    eq_obj.Fraction_Radiant = equip_frac_radiant
    eq_obj.Fraction_Lost = equip_frac_lost

    # Optionally, you can also set eq_obj.Fraction_Visible if needed,
    # but typically for "Parasitic" loads we do not.

    return lights_obj, eq_obj

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\Elec\schedule_def.py
============================================================
# Elec/schedule_def.py

import pandas as pd

"""
This file holds:
1) A default SCHEDULE_DEFINITIONS dictionary for lighting usage patterns
   (weekday vs. weekend) for Residential & Non-Residential sub-types.
2) (Optional) Functions to read & apply schedule overrides from Excel,
   which lets you adjust the (start_hour, end_hour, fraction) blocks.

You can import SCHEDULE_DEFINITIONS and pass it to your 'create_lighting_schedule'
function in schedules.py or lighting.py.
"""

# 1) Default SCHEDULE Definitions
SCHEDULE_DEFINITIONS = {
    "Residential": {
        "Corner House": {
            "weekday": [
                (0, 6, 0.05),
                (6, 8, 0.30),
                (8, 17, 0.10),
                (17, 22, 0.50),
                (22, 24, 0.05),
            ],
            "weekend": [
                (0, 8, 0.10),
                (8, 22, 0.40),
                (22, 24, 0.10),
            ],
        },
        "Apartment": {
            "weekday": [
                (0, 6, 0.05),
                (6, 8, 0.20),
                (8, 18, 0.10),
                (18, 23, 0.60),
                (23, 24, 0.05),
            ],
            "weekend": [
                (0, 9, 0.15),
                (9, 22, 0.50),
                (22, 24, 0.15),
            ],
        },
        "Terrace or Semi-detached House": {
            "weekday": [
                (0, 7, 0.05),
                (7, 9, 0.20),
                (9, 17, 0.10),
                (17, 22, 0.60),
                (22, 24, 0.05),
            ],
            "weekend": [
                (0, 9, 0.10),
                (9, 22, 0.50),
                (22, 24, 0.10),
            ],
        },
        "Detached House": {
            "weekday": [
                (0, 7, 0.05),
                (7, 9, 0.20),
                (9, 17, 0.10),
                (17, 22, 0.60),
                (22, 24, 0.05),
            ],
            "weekend": [
                (0, 9, 0.10),
                (9, 22, 0.50),
                (22, 24, 0.10),
            ],
        },
        "Two-and-a-half-story House": {
            "weekday": [
                (0, 6, 0.05),
                (6, 9, 0.20),
                (9, 18, 0.10),
                (18, 23, 0.60),
                (23, 24, 0.05),
            ],
            "weekend": [
                (0, 9, 0.10),
                (9, 22, 0.50),
                (22, 24, 0.10),
            ],
        },
    },
    "Non-Residential": {
        "Meeting Function": {
            "weekday": [
                (0, 6, 0.05),
                (6, 9, 0.50),
                (9, 12, 0.80),
                (12, 13, 0.50),
                (13, 18, 0.80),
                (18, 20, 0.50),
                (20, 24, 0.10),
            ],
            "weekend": [
                (0, 24, 0.10),
            ],
        },
        "Healthcare Function": {
            "weekday": [
                (0, 24, 0.80),  # Healthcare often 24/7
            ],
            "weekend": [
                (0, 24, 0.80),
            ],
        },
        "Sport Function": {
            "weekday": [
                (0, 6, 0.05),
                (6, 9, 0.20),
                (9, 12, 0.70),
                (12, 14, 0.50),
                (14, 22, 0.70),
                (22, 24, 0.10),
            ],
            "weekend": [
                (0, 9, 0.10),
                (9, 22, 0.70),
                (22, 24, 0.10),
            ],
        },
        "Cell Function": {
            "weekday": [
                (0, 24, 0.90),
            ],
            "weekend": [
                (0, 24, 0.90),
            ],
        },
        "Retail Function": {
            "weekday": [
                (0, 6, 0.05),
                (6, 9, 0.30),
                (9, 19, 0.90),
                (19, 21, 0.50),
                (21, 24, 0.05),
            ],
            "weekend": [
                (0, 8, 0.10),
                (8, 19, 0.80),
                (19, 22, 0.30),
                (22, 24, 0.10),
            ],
        },
        "Industrial Function": {
            "weekday": [
                (0, 6, 0.20),
                (6, 8, 0.50),
                (8, 17, 0.80),
                (17, 20, 0.50),
                (20, 24, 0.20),
            ],
            "weekend": [
                (0, 24, 0.20),
            ],
        },
        "Accommodation Function": {
            "weekday": [
                (0, 24, 0.70),
            ],
            "weekend": [
                (0, 24, 0.70),
            ],
        },
        "Office Function": {
            "weekday": [
                (0, 6, 0.10),
                (6, 9, 0.50),
                (9, 12, 0.90),
                (12, 13, 0.70),
                (13, 18, 0.90),
                (18, 20, 0.50),
                (20, 24, 0.10),
            ],
            "weekend": [
                (0, 24, 0.10),
            ],
        },
        "Education Function": {
            "weekday": [
                (0, 7, 0.05),
                (7, 8, 0.50),
                (8, 16, 0.80),
                (16, 18, 0.50),
                (18, 24, 0.05),
            ],
            "weekend": [
                (0, 24, 0.10),
            ],
        },
        "Other Use Function": {
            "weekday": [
                (0, 24, 0.30),
            ],
            "weekend": [
                (0, 24, 0.20),
            ],
        },
    },
}


# 2) (Optional) Functions to read & apply schedule overrides from Excel.

def read_schedule_overrides_from_excel(excel_path):
    """
    Example function to read schedule overrides from an Excel file.

    Expected columns (you can adjust to your needs):
      - building_category   (e.g. "Residential" or "Non-Residential")
      - sub_type            (e.g. "Apartment", "Office Function", etc.)
      - day_type            (e.g. "weekday" or "weekend")
      - start_hour
      - end_hour
      - fraction_value

    Returns a dict of form:
      overrides[building_category][sub_type][day_type] = [
         (start_hour, end_hour, fraction),
         ...
      ]
    """
    df = pd.read_excel(excel_path)
    required_cols = ["building_category", "sub_type", "day_type", 
                     "start_hour", "end_hour", "fraction_value"]
    for c in required_cols:
        if c not in df.columns:
            raise ValueError(f"Missing column '{c}' in {excel_path}")

    overrides = {}
    for _, row in df.iterrows():
        cat = str(row["building_category"]).strip()
        stype = str(row["sub_type"]).strip()
        dtype = str(row["day_type"]).strip().lower()  # "weekday" or "weekend"
        sh   = float(row["start_hour"])
        eh   = float(row["end_hour"])
        frac = float(row["fraction_value"])

        if cat not in overrides:
            overrides[cat] = {}
        if stype not in overrides[cat]:
            overrides[cat][stype] = {}
        if dtype not in overrides[cat][stype]:
            overrides[cat][stype][dtype] = []

        overrides[cat][stype][dtype].append((sh, eh, frac))

    return overrides


def apply_schedule_overrides_to_schedules(base_schedules, overrides):
    """
    Applies the schedule overrides from 'overrides' to 'base_schedules' in-place.
    'base_schedules' is typically SCHEDULE_DEFINITIONS.
    'overrides' is from read_schedule_overrides_from_excel.

    For each (cat, stype, day_type), we replace the entire list
    of (start_hour, end_hour, fraction) blocks with the override list.

    If you want partial merges or something more advanced, adapt as needed.
    """
    for cat, stype_dict in overrides.items():
        if cat not in base_schedules:
            # Create it if it doesn't exist
            base_schedules[cat] = {}
        for stype, daytypes_dict in stype_dict.items():
            if stype not in base_schedules[cat]:
                base_schedules[cat][stype] = {}

            for day_type, blocks_list in daytypes_dict.items():
                # e.g. "weekday", "weekend", or any custom day type
                base_schedules[cat][stype][day_type] = blocks_list

    # Return the updated dictionary
    return base_schedules

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\Elec\schedules.py
============================================================
# Elec/schedules.py

from .schedule_def import SCHEDULE_DEFINITIONS

"""
This module creates detailed lighting schedules for weekdays and weekends,
differentiating by building_category (Residential/Non-Residential)
and by sub_type (Apartment, Office Function, etc.).

We have two main functions:
1) create_lighting_schedule(idf, building_category, sub_type, schedule_name)
   - Creates a SCHEDULE:COMPACT with different time blocks for 'WeekDays',
     'Saturday', and 'Sunday' (or 'AllDays' if you prefer).
2) create_parasitic_schedule(idf, sched_name)
   - Creates an always-on (1.0) schedule, typically for parasitic loads.

Important:
- This code assumes you already loaded or potentially overrode
  SCHEDULE_DEFINITIONS in schedule_def.py (for instance, by calling
  `read_schedule_overrides_from_excel()` + `apply_schedule_overrides_to_schedules()`).
- If you want more advanced day-splitting, feel free to expand the logic below.
"""


def create_lighting_schedule(idf, building_category, sub_type, schedule_name="LightsSchedule"):
    """
    Create a SCHEDULE:COMPACT in the IDF using SCHEDULE_DEFINITIONS[building_category][sub_type].
    We define separate blocks for:
      - For: WeekDays
      - For: Saturday
      - For: Sunday

    If the sub_type is missing in SCHEDULE_DEFINITIONS, we fallback to a simple always-0.5 pattern.

    The final IDF object name is `schedule_name`. We return that string for convenience.
    """

    # Attempt to get sub-type dictionary from SCHEDULE_DEFINITIONS
    try:
        sub_dict = SCHEDULE_DEFINITIONS[building_category][sub_type]
    except KeyError:
        # Fallback: If not found, create a simple always-0.5 schedule
        sub_dict = {
            "weekday": [(0, 24, 0.5)],
            "weekend": [(0, 24, 0.5)],
        }

    # Some sub-types might not have a separate weekend pattern. 
    # So ensure we have 'weekday' and 'weekend' keys:
    if "weekday" not in sub_dict:
        sub_dict["weekday"] = [(0, 24, 0.5)]
    if "weekend" not in sub_dict:
        sub_dict["weekend"] = [(0, 24, 0.5)]

    # Create the schedule object
    schedule = idf.newidfobject("SCHEDULE:COMPACT")
    schedule.Name = schedule_name
    schedule.Schedule_Type_Limits_Name = "Fraction"

    # We'll define the entire year with "Through: 12/31" and break it down by day types
    # The pattern is:
    #   Field_1:  "Through: 12/31"
    #   Field_2:  "For: WeekDays"
    #   Field_3+: "Until: HH:MM,<fraction>"
    #
    # Then for Saturday, Sunday, etc.

    field_idx = 1
    setattr(schedule, f"Field_{field_idx}", "Through: 12/31")
    field_idx += 1

    # 1) WeekDays
    setattr(schedule, f"Field_{field_idx}", "For: WeekDays")
    field_idx += 1
    for (start_hour, end_hour, frac) in sub_dict["weekday"]:
        # e.g. "Until: 06:00,0.05"
        setattr(schedule, f"Field_{field_idx}",
                f"Until: {int(end_hour):02d}:00,{frac:.2f}")
        field_idx += 1

    # 2) Saturday
    setattr(schedule, f"Field_{field_idx}", "For: Saturday")
    field_idx += 1
    for (start_hour, end_hour, frac) in sub_dict["weekend"]:
        setattr(schedule, f"Field_{field_idx}",
                f"Until: {int(end_hour):02d}:00,{frac:.2f}")
        field_idx += 1

    # 3) Sunday
    setattr(schedule, f"Field_{field_idx}", "For: Sunday")
    field_idx += 1
    for (start_hour, end_hour, frac) in sub_dict["weekend"]:
        setattr(schedule, f"Field_{field_idx}",
                f"Until: {int(end_hour):02d}:00,{frac:.2f}")
        field_idx += 1

    return schedule.Name


def create_parasitic_schedule(idf, sched_name="ParasiticSchedule"):
    """
    Creates an always-on schedule (1.0) for parasitic loads (24/7).
    """
    schedule = idf.newidfobject("SCHEDULE:COMPACT")
    schedule.Name = sched_name
    schedule.Schedule_Type_Limits_Name = "Fraction"

    # Single block covering all days, 24 hours
    schedule.Field_1 = "Through: 12/31"
    schedule.Field_2 = "For: AllDays"
    schedule.Field_3 = "Until: 24:00,1.0"

    return schedule.Name

------------------------------------------------------------

