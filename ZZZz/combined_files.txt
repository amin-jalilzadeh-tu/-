File: D:\Documents\E_Plus_2030_py\idf_objects\eequip\assign_equip_values.py
============================================================
# File: D:\Documents\E_Plus_2030_py\idf_objects\eequip\assign_equip_values.py

import random
from .equip_lookup import equip_lookup
from .overrides_helper import find_applicable_overrides # if you use override logic

def assign_equipment_parameters(
    building_id: int,
    building_category: str,
    sub_type: str,
    age_range=None, # Passed to find_applicable_overrides
    calibration_stage: str = "pre_calibration",
    strategy: str = "A",
    random_seed: int = None,
    user_config: list = None, # override table (list of dicts)
    assigned_log: dict = None # optional dictionary to store final picks
):
    """
    Returns a dict with ``equip_wm2``, ``tD`` and ``tN`` picks for electric
    equipment. (Docstring from original file)
    """
    print(f"\n--- [DEBUG assign_equipment_parameters for bldg_id {building_id}] ---")
    print(f"[DEBUG assign_equip_params] INPUTS: building_category='{building_category}', sub_type='{sub_type}', calibration_stage='{calibration_stage}', strategy='{strategy}'")
    print(f"[DEBUG assign_equip_params]          age_range='{age_range}', user_config is {'Provided' if user_config else 'None'}")

    if random_seed is not None:
        random.seed(random_seed)
        print(f"[DEBUG assign_equip_params] Random seed set to: {random_seed}")

    # Normalize category strings so that lookups are consistent
    _original_building_category = building_category
    if building_category: # Check if building_category is not None or empty
        bt_low = building_category.lower()
        if bt_low == "residential":
            building_category = "Residential"
        elif bt_low == "non_residential": # Corrected from "non_residential" to match potential input casing
            building_category = "Non-Residential"
    print(f"[DEBUG assign_equip_params] Category after normalization: '{building_category}' (was '{_original_building_category}')")

    _original_sub_type = sub_type
    sub_type = sub_type.strip() if sub_type else ""
    print(f"[DEBUG assign_equip_params] Sub_type after strip: '{sub_type}' (was '{_original_sub_type}') (len: {len(sub_type)})")

    # Initialize ranges with minimal fallbacks, to be updated if lookups succeed
    equip_rng_default = (3.0, 3.0)
    tD_rng_default    = (500, 500)
    tN_rng_default    = (200, 200)

    equip_rng = equip_rng_default
    tD_rng    = tD_rng_default
    tN_rng    = tN_rng_default
    
    lookup_successful = False

    # 1) Grab the stage dictionary or fallback
    _original_calibration_stage = calibration_stage
    if calibration_stage not in equip_lookup:
        print(f"[DEBUG assign_equip_params] WARNING: calibration_stage '{calibration_stage}' not in equip_lookup keys: {list(equip_lookup.keys()) if isinstance(equip_lookup, dict) else 'Not a dict'}. Defaulting to 'pre_calibration'.")
        calibration_stage = "pre_calibration"
    
    if calibration_stage not in equip_lookup:
        print(f"[DEBUG assign_equip_params] CRITICAL FALLBACK (Stage): calibration_stage '{calibration_stage}' (even after potential default) is NOT in equip_lookup. Using hardcoded minimal fallback for ALL parameters.")
        # Ranges already initialized to minimal fallbacks
    else:
        stage_dict = equip_lookup[calibration_stage]
        print(f"[DEBUG assign_equip_params] Using calibration_stage: '{calibration_stage}'. Stage_dict keys: {list(stage_dict.keys()) if isinstance(stage_dict, dict) else 'Not a dict'}")

        # 2) Navigate to the sub-type dictionary or fallback
        if not isinstance(stage_dict, dict) or building_category not in stage_dict:
            print(f"[DEBUG assign_equip_params] FALLBACK (A - category): building_category '{building_category}' not in stage_dict for stage '{calibration_stage}' (or stage_dict is not a dict: {type(stage_dict)}). Using minimal fallback.")
            # Ranges already initialized to minimal fallbacks
        else:
            cat_dict = stage_dict[building_category]
            print(f"[DEBUG assign_equip_params] Found cat_dict for '{building_category}'. Sub-type keys in cat_dict: {list(cat_dict.keys()) if isinstance(cat_dict, dict) else 'Not a dict'}")
            
            if not isinstance(cat_dict, dict) or sub_type not in cat_dict:
                print(f"[DEBUG assign_equip_params] FALLBACK (B - sub_type): sub_type '{sub_type}' not in cat_dict for category '{building_category}' (or cat_dict is not a dict: {type(cat_dict)}). Using minimal fallback.")
                if isinstance(cat_dict, dict): print(f"   Available sub_types in cat_dict: {list(cat_dict.keys())}")
                # Ranges already initialized to minimal fallbacks
            else:
                param_dict = cat_dict[sub_type]
                if not isinstance(param_dict, dict):
                    print(f"[DEBUG assign_equip_params] FALLBACK (C - param_dict type): param_dict for '{sub_type}' is not a dictionary (type: {type(param_dict)}). Using minimal fallback.")
                    # Ranges already initialized to minimal fallbacks
                else:
                    print(f"[DEBUG assign_equip_params] SUCCESS: Found param_dict for sub_type '{sub_type}'. Keys: {list(param_dict.keys())}")
                    lookup_successful = True
                    # Get parameters with their own fallbacks if specific keys are missing
                    equip_rng = param_dict.get("EQUIP_WM2_range", equip_rng_default)
                    tD_rng    = param_dict.get("tD_range", tD_rng_default)
                    tN_rng    = param_dict.get("tN_range", tN_rng_default)
                    
                    if "EQUIP_WM2_range" not in param_dict: print(f"   [DEBUG assign_equip_params] Note: EQUIP_WM2_range missing in param_dict for '{sub_type}', used default {equip_rng_default}.")
                    if "tD_range" not in param_dict: print(f"   [DEBUG assign_equip_params] Note: tD_range missing in param_dict for '{sub_type}', used default {tD_rng_default}.")
                    if "tN_range" not in param_dict: print(f"   [DEBUG assign_equip_params] Note: tN_range missing in param_dict for '{sub_type}', used default {tN_rng_default}.")

    print(f"[DEBUG assign_equip_params] Ranges status after lookup (lookup_successful={lookup_successful}):")
    print(f"  equip_rng: {equip_rng}")
    print(f"  tD_rng: {tD_rng}")
    print(f"  tN_rng: {tN_rng}")

    # 3) Find override rows
    matches = [] # Ensure matches is defined
    if user_config is not None:
        # Assuming find_applicable_overrides exists and works correctly.
        # Add try-except if it's a source of potential errors.
        try:
            matches = find_applicable_overrides(building_id, sub_type, age_range, user_config)
            print(f"[DEBUG assign_equip_params] Found {len(matches)} applicable overrides for bldg_id={building_id}, sub_type='{sub_type}', age_range='{age_range}'.")
            if matches: print(f"   Overrides data: {matches}")
        except Exception as e:
            print(f"[DEBUG assign_equip_params] ERROR in find_applicable_overrides: {e}")
            matches = [] # Reset to empty list on error
    else:
        print(f"[DEBUG assign_equip_params] No user_config provided for overrides.")
        matches = []

    # 4) Apply overrides
    if matches:
        print(f"[DEBUG assign_equip_params] Applying {len(matches)} overrides...")
    for row_idx, row in enumerate(matches):
        # Defensive get for keys in override rows
        pname = row.get("param_name")
        mn = row.get("min_val")
        mx = row.get("max_val")

        if pname is None or mn is None or mx is None:
            print(f"  [DEBUG assign_equip_params] Override {row_idx+1} skipped: malformed row (missing param_name, min_val, or max_val): {row}")
            continue
            
        pname = pname.strip() # Ensure no leading/trailing spaces

        print(f"  [DEBUG assign_equip_params] Override {row_idx+1}: param='{pname}', min_val={mn}, max_val={mx}")
        if pname == "equip_wm2":
            equip_rng = (float(mn), float(mx))
            print(f"    Updated equip_rng to: {equip_rng}")
        elif pname == "tD":
            tD_rng = (float(mn), float(mx))
            print(f"    Updated tD_rng to: {tD_rng}")
        elif pname == "tN":
            tN_rng = (float(mn), float(mx))
            print(f"    Updated tN_rng to: {tN_rng}")
        else:
            print(f"    [DEBUG assign_equip_params] Unrecognized param_name '{pname}' in override row.")
    
    if matches: print(f"[DEBUG assign_equip_params] Ranges after potential overrides: equip_rng={equip_rng}, tD_rng={tD_rng}, tN_rng={tN_rng}")

    # 5) Strategy to pick final values
    def pick_val(param_name, r, current_strategy): # Added param_name and strategy for better logging
        val = None
        # Ensure r is a tuple of two numbers
        if not (isinstance(r, (tuple, list)) and len(r) == 2 and all(isinstance(n, (int, float)) for n in r)):
            print(f"  [DEBUG assign_equip_params] pick_val for '{param_name}': Invalid range format {r}. Using default 0.0.")
            return 0.0 # Or handle error appropriately
            
        if current_strategy == "A": # midpoint
            val = (r[0] + r[1]) / 2.0
        elif current_strategy == "B": # random
            val = random.uniform(r[0], r[1])
        else: # fallback => pick min
            val = r[0]
        print(f"  [DEBUG assign_equip_params] pick_val for '{param_name}': range={r}, strategy='{current_strategy}', picked={val}")
        return val

    assigned = {
        "equip_wm2": pick_val("equip_wm2", equip_rng, strategy),
        "tD": pick_val("tD", tD_rng, strategy),
        "tN": pick_val("tN", tN_rng, strategy)
    }
    print(f"[DEBUG assign_equip_params] Values after pick_val (pre-sanity): {assigned}")

    # Basic sanity checks so negative values or obviously unrealistic
    # picks do not slip through.
    assigned["equip_wm2"] = max(0.0, float(assigned["equip_wm2"]))
    assigned["tD"] = max(0.0, float(assigned["tD"]))
    assigned["tN"] = max(0.0, float(assigned["tN"]))
    print(f"[DEBUG assign_equip_params] Final assigned values (post-sanity): {assigned}")

    # 6) Optional logging of both the picks and underlying ranges
    if assigned_log is not None:
        log_data = {
            "assigned": assigned,
            "ranges": {
                "equip_wm2": equip_rng,
                "tD": tD_rng,
                "tN": tN_rng,
            },
            "lookup_successful": lookup_successful, # Added for insight
            "overrides_applied_count": len(matches) # Added for insight
        }
        assigned_log[building_id] = log_data
        print(f"[DEBUG assign_equip_params] Logged data for building_id {building_id}: {log_data}")

    print(f"--- [END DEBUG assign_equipment_parameters for bldg_id {building_id}] ---")
    return assigned
------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\eequip\equip_lookup.py
============================================================
# eequip/equip_lookup.py
"""
Equipment Lookup Table (Pre/Post Calibration)
---------------------------------------------
This file defines default electric equipment parameters for both 
residential and non-residential buildings.

NOTE (รอบนี้): The "EQUIP_WM2_range" values below for non-residential pre_calibration
have been FURTHER ADJUSTED to represent MORE ENERGY-EFFICIENT or typical office/plug load
scenarios. Heavy process loads (e.g., large refrigeration in retail, industrial machinery)
are typically modeled separately. These are ILLUSTRATIVE examples and MUST BE VALIDATED
against specific project requirements and local standards (e.g., NTA 8800).
The tD_range and tN_range are NOT directly used by the EnergyPlus ELECTRICEQUIPMENT
object's energy calculation in the provided scripts; schedules from schedule_def.py are used.
"""

equip_lookup = {
    "pre_calibration": {
        # ===============================
        # 1) RESIDENTIAL (example sub-types) - Values seem generally plausible
        # ===============================
        "Residential": {
            "Corner House":                 { "EQUIP_WM2_range": (2.5, 4.0), "tD_range": (400, 600), "tN_range": (100, 200) },
            "Apartment":                    { "EQUIP_WM2_range": (1.5, 3.0), "tD_range": (300, 500), "tN_range": (100, 200) },
            "Terrace or Semi-detached House":{ "EQUIP_WM2_range": (2.5, 4.0), "tD_range": (400, 600), "tN_range": (100, 200) },
            "Detached House":               { "EQUIP_WM2_range": (3.0, 5.0), "tD_range": (500, 700), "tN_range": (200, 300) },
            "Two-and-a-half-story House":   { "EQUIP_WM2_range": (3.0, 5.0), "tD_range": (500, 700), "tN_range": (200, 300) }
        },
        # ===============================
        # 2) NON-RESIDENTIAL (Values adjusted for more typical/efficient plug loads)
        # ===============================
        "Non-Residential": {
            "Office Function": { # Standard office: PCs, monitors, printers, etc.
                "EQUIP_WM2_range": (4.0, 7.0),   # Adjusted from 8-10 previously
                "tD_range": (2000, 2400),
                "tN_range": (100, 250)
            },
            "Retail Function": { # POS, back-office computers. Does NOT include large display refrigeration.
                "EQUIP_WM2_range": (3.0, 7.0),   # Adjusted from 10-12 (for general equipment)
                "tD_range": (2500, 3000),
                "tN_range": (200, 400)
            },
            "Education Function": { # Classrooms: few PCs/projector, Staff rooms: more PCs
                "EQUIP_WM2_range": (2.5, 5.0),   # Adjusted from 7-9
                "tD_range": (1400, 1800),
                "tN_range": (100, 200)
            },
            "Healthcare Function": { # General areas: nurse stations, office equip. Excludes specialized medical.
                "EQUIP_WM2_range": (4.0, 8.0),   # Adjusted from 10-12
                "tD_range": (3000, 4000),
                "tN_range": (500, 700)
            },
            "Meeting Function": { # AV equipment, laptops if BYOD
                "EQUIP_WM2_range": (2.0, 5.0),   # Adjusted from 8-10
                "tD_range": (1800, 2200),
                "tN_range": (100, 200)
            },
            "Sport Function": { # Reception PCs, small office, potentially some small fitness equip electronics
                "EQUIP_WM2_range": (1.5, 4.0),   # Adjusted from 9-11
                "tD_range": (2000, 2500),
                "tN_range": (300, 500)
            },
            "Cell Function": { # Minimal in-cell, e.g. small TV or radio.
                "EQUIP_WM2_range": (1.0, 2.5),   # Adjusted from 8-10
                "tD_range": (3500, 4000),
                "tN_range": (800, 1000)
            },
            "Industrial Function": { # Office/admin areas within industrial, not process machinery.
                "EQUIP_WM2_range": (3.0, 6.0),   # Adjusted from 12-15
                "tD_range": (2800, 3500),
                "tN_range": (300, 600)
            },
            "Accommodation Function": { # Guest rooms: TV, charging, clock. Lobby: PCs.
                "EQUIP_WM2_range": (2.0, 4.0),   # Adjusted from 6-8
                "tD_range": (2000, 2800),
                "tN_range": (400, 700)
            },
            "Other Use Function": { # Generic non-residential equipment
                "EQUIP_WM2_range": (3.0, 6.0),   # Adjusted from 5-8
                "tD_range": (1500, 2000),
                "tN_range": (100, 300)
            }
        }
    },
    "post_calibration": {
        # Post-calibration values are highly project-specific.
        # Structure from your original file is maintained.
        "Residential": {
            "Corner House": {"EQUIP_WM2_range": (4.0,4.0), "tD_range": (500,500), "tN_range": (150,150)},
            "Apartment": {"EQUIP_WM2_range": (3.0,3.0), "tD_range": (400,400), "tN_range": (150,150)},
            "Terrace or Semi-detached House": {"EQUIP_WM2_range": (4.0,4.0), "tD_range": (500,500), "tN_range": (150,150)},
            "Detached House": {"EQUIP_WM2_range": (5.0,5.0), "tD_range": (600,600), "tN_range": (250,250)},
            "Two-and-a-half-story House": {"EQUIP_WM2_range": (5.0,5.0), "tD_range": (600,600), "tN_range": (250,250)}
        },
        "Non-Residential": { # Copying one example, others would follow similar calibrated pattern
            "Office Function": {"EQUIP_WM2_range": (5.0,5.0), "tD_range": (2300,2300), "tN_range": (150,150)},
            # ... other non-residential types with their calibrated values ...
            "Meeting Function": {"EQUIP_WM2_range": (4.0,4.0), "tD_range": (2000,2000), "tN_range": (150,150)},
            "Healthcare Function": {"EQUIP_WM2_range": (7.0,7.0), "tD_range": (3800,3800), "tN_range": (600,600)},
            "Sport Function": {"EQUIP_WM2_range": (3.0,3.0), "tD_range": (2200,2200), "tN_range": (400,400)},
            "Cell Function": {"EQUIP_WM2_range": (2.0,2.0), "tD_range": (3800,3800), "tN_range": (900,900)},
            "Retail Function": {"EQUIP_WM2_range": (6.0,6.0), "tD_range": (2800,2800), "tN_range": (300,300)},
            "Industrial Function": {"EQUIP_WM2_range": (5.0,5.0), "tD_range": (3000,3000), "tN_range": (400,400)},
            "Accommodation Function": {"EQUIP_WM2_range": (3.0,3.0), "tD_range": (2500,2500), "tN_range": (500,500)},
            "Education Function": {"EQUIP_WM2_range": (4.0,4.0), "tD_range": (1600,1600), "tN_range": (150,150)},
            "Other Use Function": {"EQUIP_WM2_range": (4.0,4.0), "tD_range": (1800,1800), "tN_range": (200,200)}
        }
    }
}
------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\eequip\equipment.py
============================================================
# File: D:\Documents\E_Plus_2030_py\idf_objects\eequip\equipment.py
"""equipment.py

Adds ELECTRICEQUIPMENT objects to an IDF using default lookup tables
and optional user overrides.
"""

from idf_objects.Elec.lighting import get_building_category_and_subtype # This will use the debugged version from Elec/lighting.py
from .assign_equip_values import assign_equipment_parameters
from .schedules import create_equipment_schedule


def add_electric_equipment(
    idf,
    building_row,
    calibration_stage="pre_calibration",
    strategy="A",
    random_seed=None,
    user_config=None,
    assigned_values_log=None,
    zonelist_name="ALL_ZONES",
):
    """Create an ELECTRICEQUIPMENT object for the entire building.

    Parameters
    ----------
    idf : Eppy IDF
        The IDF object to modify.
    building_row : pd.Series or dict
        Row with at least ``ogc_fid`` and ``building_function`` fields.
    calibration_stage : str, default "pre_calibration"
        Lookup key for ``equip_lookup``.
    strategy : str, default "A"
        Selection strategy for value picking.
    random_seed : int, optional
        Seed for the random generator if strategy uses randomness.
    user_config : list of dicts, optional
        Override rows for equipment parameters.
    assigned_values_log : dict, optional
        If provided, the picked parameters are stored under
        ``assigned_values_log[building_id]``.
    zonelist_name : str, default "ALL_ZONES"
        ZoneList name to reference in the created object.
    """

    # 1) Get building_category / sub_type
    building_category, sub_type = get_building_category_and_subtype(building_row) # Uses the debugged version
    
    bldg_id = int(building_row.get("ogc_fid", 0))
    print(f"\n--- [DEBUG add_electric_equipment for bldg_id {bldg_id}] ---")
    print(f"[DEBUG add_electric_equipment] Calling get_building_category_and_subtype, received: category='{building_category}', sub_type='{sub_type}'")

    picks = assign_equipment_parameters( # Call to assign_equipment_parameters
        building_id=bldg_id,
        building_category=building_category,
        sub_type=sub_type,
        age_range=None, # Assuming age_range is not the issue for now
        calibration_stage=calibration_stage,
        strategy=strategy,
        random_seed=random_seed,
        user_config=user_config,
        assigned_log=assigned_values_log,
    )

    equip_wm2 = picks["equip_wm2"]

    sched_name = create_equipment_schedule(
        idf,
        building_category=building_category,
        sub_type=sub_type,
        schedule_name="EquipSchedule",
    )

    eq_obj = idf.newidfobject("ELECTRICEQUIPMENT")
    eq_obj.Name = f"Equip_{zonelist_name}"
    eq_obj.Zone_or_ZoneList_or_Space_or_SpaceList_Name = zonelist_name
    eq_obj.Schedule_Name = sched_name
    eq_obj.Design_Level_Calculation_Method = "Watts/Area"
    eq_obj.Watts_per_Zone_Floor_Area = equip_wm2
    
    print(f"[DEBUG add_electric_equipment] Successfully created ELECTRICEQUIPMENT object for bldg_id {bldg_id} with equip_wm2 = {equip_wm2}.")
    print(f"--- [END DEBUG add_electric_equipment for bldg_id {bldg_id}] ---")
    return eq_obj
------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\eequip\schedule_def.py
============================================================
# eequip/schedule_def.py

"""
EQUIP_SCHEDULE_DEFINITIONS
===========================
This dictionary defines typical usage patterns for electric equipment
throughout the day, differentiating weekday vs. weekend, and by building
category (Residential vs. Non-Residential) and sub-type.

NOTE (รอบนี้): The non-residential schedules below have been FURTHER REFINED
to represent more energy-conscious or typical operational patterns for general
plug loads and office-type equipment. These are ILLUSTRATIVE examples and
MUST BE VALIDATED and customized based on specific project requirements,
occupancy data, equipment types, and local standards (e.g., NTA 8800).
"""

EQUIP_SCHEDULE_DEFINITIONS = {
    "Residential": {
        # Residential equipment schedules - adjusted slightly for plausibility
        "Corner House": {
            "weekday": [(0, 6, 0.08), (6, 9, 0.35), (9, 17, 0.18), (17, 21, 0.50), (21, 24, 0.15)],
            "weekend": [(0, 7, 0.10), (7, 22, 0.45), (22, 24, 0.15)],
        },
        "Apartment": {
            "weekday": [(0, 6, 0.06), (6, 8, 0.25), (8, 18, 0.12), (18, 23, 0.45), (23, 24, 0.08)],
            "weekend": [(0, 8, 0.08), (8, 22, 0.40), (22, 24, 0.10)],
        },
        "Terrace or Semi-detached House": {
            "weekday": [(0, 6, 0.08), (6, 9, 0.35), (9, 17, 0.18), (17, 22, 0.50), (22, 24, 0.15)],
            "weekend": [(0, 7, 0.10), (7, 22, 0.45), (22, 24, 0.15)],
        },
        "Detached House": {
            "weekday": [(0, 6, 0.10), (6, 9, 0.40), (9, 17, 0.20), (17, 22, 0.55), (22, 24, 0.20)],
            "weekend": [(0, 7, 0.12), (7, 23, 0.50), (23, 24, 0.20)],
        },
        "Two-and-a-half-story House": {
            "weekday": [(0, 6, 0.08), (6, 9, 0.35), (9, 17, 0.18), (17, 22, 0.50), (22, 24, 0.15)],
            "weekend": [(0, 7, 0.10), (7, 22, 0.45), (22, 24, 0.15)],
        },
    },
    "Non-Residential": {
        "Office Function": { # Equipment (PCs, monitors) often on during work hours
            "weekday": [
                (0, 7, 0.05),   # Night standby (network gear, some PCs in sleep)
                (7, 8, 0.30),   # Arrival, boot up
                (8, 12, 0.75),  # Core work hours (PCs active)
                (12, 13, 0.50), # Lunch (some PCs sleep/idle, some active)
                (13, 17, 0.75), # Core work hours
                (17, 18, 0.40), # Winding down, some shutdown
                (18, 24, 0.05),  # Night standby
            ],
            "weekend": [ # Minimal, mainly server/network gear or essential services
                (0, 24, 0.05),
            ],
        },
        "Retail Function": { # POS, back-office. Excludes major refrigeration/process loads.
            "weekday": [
                (0, 8, 0.03),   # Closed, essential standby
                (8, 10, 0.40),  # Staff prep, systems on
                (10, 18, 0.70), # Open - active POS, back office
                (18, 19, 0.35), # Closing tasks
                (19, 24, 0.03),  # Closed
            ],
            "weekend": [
                (0, 9, 0.03),
                (9, 17, 0.65),  # Weekend opening hours
                (17, 18, 0.25),
                (18, 24, 0.03),
            ],
        },
        "Education Function": { # Computers in labs/classrooms, staff PCs
            "weekday": [
                (0, 7, 0.02),
                (7, 8, 0.30),   # Staff arrive, systems on
                (8, 12, 0.65),  # Classes, computer use
                (12, 13, 0.20), # Lunch, lower use
                (13, 16, 0.65), # Classes
                (16, 18, 0.10), # Staff finishing up
                (18, 24, 0.02),
            ],
            "weekend": [(0, 24, 0.02)], # Mostly off
        },
        "Healthcare Function": { # Office equip, nurse stations, patient monitoring (not heavy medical imaging)
            "weekday": [ # Assumes some 24/7 base for critical, higher for admin/clinic hours
                (0, 7, 0.40),   # Night essentials
                (7, 19, 0.60),  # Daytime higher activity
                (19, 22, 0.50), # Evening
                (22, 24, 0.40),
            ],
            "weekend": [
                (0, 7, 0.35),
                (7, 19, 0.55),
                (19, 22, 0.45),
                (22, 24, 0.35),
            ],
        },
        "Meeting Function": { # AV, laptops
            "weekday": [
                (0, 8, 0.02),
                (8, 9, 0.20),
                (9, 12, 0.50), # Intermittent use of AV/laptops
                (12, 13, 0.15),
                (13, 17, 0.50),
                (17, 18, 0.10),
                (18, 24, 0.02),
            ],
            "weekend": [(0, 24, 0.02)],
        },
        "Sport Function": { # Office/reception, some electronic fitness if applicable
            "weekday": [
                (0, 7, 0.01),
                (7, 16, 0.30), 
                (16, 22, 0.60), 
                (22, 24, 0.02),
            ],
            "weekend": [
                (0, 8, 0.01),
                (8, 20, 0.50), 
                (20, 24, 0.02),
            ],
        },
        "Cell Function": { # Minimal in-cell equipment
            "weekday": [(0, 24, 0.20)], # Reduced
            "weekend": [(0, 24, 0.20)],
        },
        "Industrial Function": { # Assumes office/control part of industrial, not main machinery
            "weekday": [
                (0, 6, 0.05),
                (6, 18, 0.60), # Operational hours for support equipment
                (18, 22, 0.08),
                (22, 24, 0.05),
            ],
            "weekend": [(0, 24, 0.05)],
        },
        "Accommodation Function": { # Guest room + common area office/lobby equip
            "weekday": [
                (0, 6, 0.20),
                (6, 10, 0.35),
                (10, 17, 0.20),
                (17, 23, 0.50),
                (23, 24, 0.20),
            ],
            "weekend": [
                (0, 6, 0.22),
                (6, 11, 0.40),
                (11, 17, 0.30),
                (17, 23, 0.55),
                (23, 24, 0.22),
            ],
        },
        "Other Use Function": {
            "weekday": [
                (0, 7, 0.03),
                (7, 19, 0.40), 
                (19, 24, 0.03),
            ],
            "weekend": [
                (0, 24, 0.05),
            ],
        },
    },
}

# Optional: Functions to read/apply Excel overrides (kept from original)
def read_schedule_overrides_from_excel(excel_path):
    """Read Excel overrides for schedule definitions."""
    import pandas as pd # Ensure pandas is available

    df = pd.read_excel(excel_path)
    required = [
        "building_category", "sub_type", "day_type",
        "start_hour", "end_hour", "fraction_value",
    ]
    for c in required:
        if c not in df.columns:
            raise ValueError(f"Missing column '{c}' in {excel_path}")

    overrides = {}
    for _, row in df.iterrows():
        cat = str(row["building_category"]).strip()
        stype = str(row["sub_type"]).strip()
        dtype = str(row["day_type"]).strip().lower()
        block = (float(row["start_hour"]), float(row["end_hour"]), float(row["fraction_value"]))

        overrides.setdefault(cat, {}).setdefault(stype, {}).setdefault(dtype, []).append(block)
    return overrides


def apply_schedule_overrides_to_schedules(base_schedules, overrides):
    """Merge schedule overrides into ``base_schedules`` in-place."""
    for cat, stypes in overrides.items():
        base_schedules.setdefault(cat, {})
        for stype, days in stypes.items():
            base_schedules[cat].setdefault(stype, {})
            for day_type, blocks in days.items():
                base_schedules[cat][stype][day_type] = blocks
    return base_schedules
------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\eequip\schedules.py
============================================================
# eequip/schedules.py

from .schedule_def import EQUIP_SCHEDULE_DEFINITIONS

"""
This module creates detailed schedules for electric equipment usage
(weekday vs. weekend), differentiating by building category (Residential vs. Non-Residential)
and sub-type (e.g. Corner House, Office, Retail, etc.).

We provide two main functions:

1) create_equipment_schedule(idf, building_category, sub_type, schedule_name)
   - Creates a multi-day schedule with 'WeekDays', 'Saturday', 'Sunday'.

2) create_equipment_parasitic_schedule(idf, sched_name)
   - Creates a schedule that is always ON (1.0).
"""


def create_equipment_schedule(idf, building_category, sub_type, schedule_name="EquipSchedule"):
    """
    Creates a SCHEDULE:COMPACT object in the IDF representing a typical 
    equipment usage pattern for weekdays vs. weekends, based on 
    EQUIP_SCHEDULE_DEFINITIONS.

    Parameters:
        - idf: Eppy IDF object (or a similar interface)
        - building_category: e.g. "Residential" or "Non-Residential"
        - sub_type: e.g. "Corner House", "Office Function"
        - schedule_name: name of the schedule in IDF

    Returns:
        - The name of the new schedule object (same as schedule_name).
    """

    # Attempt to retrieve a sub-type dict. If not found, fallback to a simple 0.5 fraction all day.
    try:
        sub_dict = EQUIP_SCHEDULE_DEFINITIONS[building_category][sub_type]
    except KeyError:
        sub_dict = {
            "weekday": [(0, 24, 0.5)],
            "weekend": [(0, 24, 0.5)],
        }

    # Create a new schedule object in the IDF
    schedule = idf.newidfobject("SCHEDULE:COMPACT")
    schedule.Name = schedule_name
    schedule.Schedule_Type_Limits_Name = "Fraction"

    # We'll define a pattern that covers the full year:
    field_idx = 1

    # First line: "Through: 12/31"
    setattr(schedule, f"Field_{field_idx}", "Through: 12/31")
    field_idx += 1

    # 1) WeekDays
    setattr(schedule, f"Field_{field_idx}", "For: WeekDays")
    field_idx += 1
    for (start_hour, end_hour, fraction) in sub_dict["weekday"]:
        setattr(
            schedule,
            f"Field_{field_idx}",
            f"Until: {end_hour:02d}:00,{fraction:.2f}"
        )
        field_idx += 1

    # 2) Saturday
    setattr(schedule, f"Field_{field_idx}", "For: Saturday")
    field_idx += 1
    for (start_hour, end_hour, fraction) in sub_dict["weekend"]:
        setattr(
            schedule,
            f"Field_{field_idx}",
            f"Until: {end_hour:02d}:00,{fraction:.2f}"
        )
        field_idx += 1

    # 3) Sunday
    setattr(schedule, f"Field_{field_idx}", "For: Sunday")
    field_idx += 1
    for (start_hour, end_hour, fraction) in sub_dict["weekend"]:
        setattr(
            schedule,
            f"Field_{field_idx}",
            f"Until: {end_hour:02d}:00,{fraction:.2f}"
        )
        field_idx += 1

    return schedule.Name


def create_equipment_parasitic_schedule(idf, sched_name="EquipParasiticSchedule"):
    """
    Creates a schedule that is always ON at 1.0 for parasitic equipment loads.
    You can also rename it or adjust if you want partial load or special schedules.

    Parameters:
        - idf: Eppy IDF object
        - sched_name: the schedule name in the IDF

    Returns:
        - The name of the new schedule object
    """

    schedule = idf.newidfobject("SCHEDULE:COMPACT")
    schedule.Name = sched_name
    schedule.Schedule_Type_Limits_Name = "Fraction"

    # A simple all-day, all-year schedule at 1.0
    schedule.Field_1 = "Through: 12/31"
    schedule.Field_2 = "For: AllDays"
    schedule.Field_3 = "Until: 24:00,1.0"

    return schedule.Name

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\Elec\assign_lighting_values.py
============================================================
# File: D:\Documents\E_Plus_2030_py\idf_objects\Elec\assign_lighting_values.py

import random
from .lighting_lookup import lighting_lookup
from .constants import ( # Ensure all DEFAULT constants are imported
    DEFAULT_LIGHTING_WM2, DEFAULT_PARASITIC_WM2, DEFAULT_TD, DEFAULT_TN,
    DEFAULT_LIGHTS_FRACTION_RADIANT, DEFAULT_LIGHTS_FRACTION_VISIBLE,
    DEFAULT_LIGHTS_FRACTION_REPLACEABLE, DEFAULT_EQUIP_FRACTION_RADIANT,
    DEFAULT_EQUIP_FRACTION_LOST
)
from .overrides_helper import find_applicable_overrides # Assuming this helper function exists and is correct


def assign_lighting_parameters(
    building_id: int,
    building_category: str,
    sub_type: str,
    age_range=None,
    calibration_stage: str = "pre_calibration",
    strategy: str = "A",
    random_seed: int = None,
    user_config: list = None, # list of override dicts from lighting.json
    assigned_log: dict = None # optional dictionary to store final picks
):
    """
    Determines final lighting parameters for a given building,
    merging any user overrides from ``lighting.json`` with defaults
    stored under ``lighting_lookup[calibration_stage][building_category][sub_type]``.
    """
    print(f"\n--- [DEBUG assign_lighting_parameters for bldg_id {building_id}] ---")
    print(f"[DEBUG assign_light_params] INPUTS: building_category='{building_category}', sub_type='{sub_type}', calibration_stage='{calibration_stage}', strategy='{strategy}'")

    # (A) Set random seed if specified
    if random_seed is not None:
        random.seed(random_seed)
        print(f"[DEBUG assign_light_params] Random seed set to: {random_seed}")

    # (B) Get the "stage_dict" for the given calibration_stage
    _original_calibration_stage = calibration_stage
    if calibration_stage not in lighting_lookup:
        print(f"[DEBUG assign_light_params] WARNING: calibration_stage '{calibration_stage}' not in lighting_lookup keys: {list(lighting_lookup.keys())}. Defaulting to 'pre_calibration'.")
        calibration_stage = "pre_calibration"
    
    # Define the comprehensive fallback structure (as in your original code for this file)
    # This is used if category or sub_type lookups fail at a high level.
    FULL_FALLBACK_DICT = {
        "lights_wm2": {"assigned_value": DEFAULT_LIGHTING_WM2, "min_val": DEFAULT_LIGHTING_WM2, "max_val": DEFAULT_LIGHTING_WM2, "object_name": "LIGHTS"},
        "parasitic_wm2": {"assigned_value": DEFAULT_PARASITIC_WM2, "min_val": DEFAULT_PARASITIC_WM2, "max_val": DEFAULT_PARASITIC_WM2, "object_name": "ELECTRICEQUIPMENT"},
        "tD": {"assigned_value": DEFAULT_TD, "min_val": DEFAULT_TD, "max_val": DEFAULT_TD, "object_name": "LIGHTS_SCHEDULE"},
        "tN": {"assigned_value": DEFAULT_TN, "min_val": DEFAULT_TN, "max_val": DEFAULT_TN, "object_name": "LIGHTS_SCHEDULE"},
        "lights_fraction_radiant": {"assigned_value": DEFAULT_LIGHTS_FRACTION_RADIANT, "min_val": DEFAULT_LIGHTS_FRACTION_RADIANT, "max_val": DEFAULT_LIGHTS_FRACTION_RADIANT, "object_name": "LIGHTS.Fraction_Radiant"},
        "lights_fraction_visible": {"assigned_value": DEFAULT_LIGHTS_FRACTION_VISIBLE, "min_val": DEFAULT_LIGHTS_FRACTION_VISIBLE, "max_val": DEFAULT_LIGHTS_FRACTION_VISIBLE, "object_name": "LIGHTS.Fraction_Visible"},
        "lights_fraction_replaceable": {"assigned_value": DEFAULT_LIGHTS_FRACTION_REPLACEABLE, "min_val": DEFAULT_LIGHTS_FRACTION_REPLACEABLE, "max_val": DEFAULT_LIGHTS_FRACTION_REPLACEABLE, "object_name": "LIGHTS.Fraction_Replaceable"},
        "equip_fraction_radiant": {"assigned_value": DEFAULT_EQUIP_FRACTION_RADIANT, "min_val": DEFAULT_EQUIP_FRACTION_RADIANT, "max_val": DEFAULT_EQUIP_FRACTION_RADIANT, "object_name": "ELECTRICEQUIPMENT.Fraction_Radiant"},
        "equip_fraction_lost": {"assigned_value": DEFAULT_EQUIP_FRACTION_LOST, "min_val": DEFAULT_EQUIP_FRACTION_LOST, "max_val": DEFAULT_EQUIP_FRACTION_LOST, "object_name": "ELECTRICEQUIPMENT.Fraction_Lost"}
    }

    if calibration_stage not in lighting_lookup: # Should have been caught by the default, but defensive check
        print(f"[DEBUG assign_light_params] CRITICAL FALLBACK (Stage): calibration_stage '{calibration_stage}' (even after potential default) is NOT in lighting_lookup. Using FULL_FALLBACK_DICT.")
        if assigned_log is not None: assigned_log[building_id] = FULL_FALLBACK_DICT
        print(f"--- [END DEBUG assign_lighting_parameters for bldg_id {building_id} - CRITICAL STAGE FALLBACK] ---")
        return FULL_FALLBACK_DICT
        
    stage_dict = lighting_lookup[calibration_stage]
    print(f"[DEBUG assign_light_params] Using calibration_stage: '{calibration_stage}'. Stage_dict keys: {list(stage_dict.keys()) if isinstance(stage_dict, dict) else 'Not a dict'}")

    # Normalise and strip inputs (as per your original file)
    _original_building_category = building_category
    if building_category.lower() == "residential": # Note: your original file had `if building_category.lower() == ...` which could error if building_category is None
        building_category = "Residential"
    elif building_category.lower() == "non_residential": # Same potential error if None
        building_category = "Non-Residential"
    # Safer normalization:
    # if building_category: # Check if building_category is not None or empty
    #     if building_category.lower() == "residential":
    #         building_category = "Residential"
    #     elif building_category.lower() == "non_residential":
    #         building_category = "Non-Residential"
    # For now, using your structure, assuming building_category is a valid string from get_building_category_and_subtype
    print(f"[DEBUG assign_light_params] Category after normalization: '{building_category}' (was '{_original_building_category}')")
    
    _original_sub_type = sub_type
    sub_type = sub_type.strip() if sub_type else "" # This is good
    print(f"[DEBUG assign_light_params] Sub_type after strip: '{sub_type}' (was '{_original_sub_type}') (len: {len(sub_type)})")

    # (C) Navigate to the sub_type dictionary or fallback
    param_dict = None # Initialize to be safe
    if not isinstance(stage_dict, dict) or building_category not in stage_dict:
        print(f"[DEBUG assign_light_params] FALLBACK (C1 - category): building_category '{building_category}' not in stage_dict for stage '{calibration_stage}' (or stage_dict is not a dict: {type(stage_dict)}). Returning FULL_FALLBACK_DICT.")
        if assigned_log is not None: assigned_log[building_id] = FULL_FALLBACK_DICT
        print(f"--- [END DEBUG assign_lighting_parameters for bldg_id {building_id} - FALLBACK C1] ---")
        return FULL_FALLBACK_DICT
    
    cat_dict = stage_dict[building_category]
    print(f"[DEBUG assign_light_params] Found cat_dict for '{building_category}'. Sub-type keys in cat_dict: {list(cat_dict.keys()) if isinstance(cat_dict, dict) else 'Not a dict'}")

    if not isinstance(cat_dict, dict) or sub_type not in cat_dict:
        print(f"[DEBUG assign_light_params] FALLBACK (C2 - sub_type): sub_type '{sub_type}' not in cat_dict for category '{building_category}' (or cat_dict is not a dict: {type(cat_dict)}). Returning FULL_FALLBACK_DICT.")
        if isinstance(cat_dict, dict): print(f"   Expected one of: {list(cat_dict.keys())}")
        if assigned_log is not None: assigned_log[building_id] = FULL_FALLBACK_DICT
        print(f"--- [END DEBUG assign_lighting_parameters for bldg_id {building_id} - FALLBACK C2] ---")
        return FULL_FALLBACK_DICT
        
    param_dict = cat_dict[sub_type]
    if not isinstance(param_dict, dict):
        print(f"[DEBUG assign_light_params] FALLBACK (C3 - param_dict type): param_dict for '{sub_type}' is not a dictionary (type: {type(param_dict)}). Returning FULL_FALLBACK_DICT.")
        if assigned_log is not None: assigned_log[building_id] = FULL_FALLBACK_DICT
        print(f"--- [END DEBUG assign_lighting_parameters for bldg_id {building_id} - FALLBACK C3] ---")
        return FULL_FALLBACK_DICT

    print(f"[DEBUG assign_light_params] SUCCESS: Found param_dict for sub_type '{sub_type}'. Keys: {list(param_dict.keys())}")

    # (D) Extract default ranges from found param_dict or constants if key missing in param_dict
    # These will be the starting point before overrides.
    lights_rng      = param_dict.get("LIGHTS_WM2_range", (DEFAULT_LIGHTING_WM2, DEFAULT_LIGHTING_WM2))
    parasitic_rng   = param_dict.get("PARASITIC_WM2_range", (DEFAULT_PARASITIC_WM2, DEFAULT_PARASITIC_WM2))
    tD_rng          = param_dict.get("tD_range", (DEFAULT_TD, DEFAULT_TD))
    tN_rng          = param_dict.get("tN_range", (DEFAULT_TN, DEFAULT_TN))
    lights_fraction_radiant_rng     = param_dict.get("lights_fraction_radiant_range", (DEFAULT_LIGHTS_FRACTION_RADIANT, DEFAULT_LIGHTS_FRACTION_RADIANT))
    lights_fraction_visible_rng     = param_dict.get("lights_fraction_visible_range", (DEFAULT_LIGHTS_FRACTION_VISIBLE, DEFAULT_LIGHTS_FRACTION_VISIBLE))
    lights_fraction_replace_rng     = param_dict.get("lights_fraction_replaceable_range", (DEFAULT_LIGHTS_FRACTION_REPLACEABLE, DEFAULT_LIGHTS_FRACTION_REPLACEABLE))
    equip_fraction_radiant_rng      = param_dict.get("equip_fraction_radiant_range", (DEFAULT_EQUIP_FRACTION_RADIANT, DEFAULT_EQUIP_FRACTION_RADIANT))
    equip_fraction_lost_rng         = param_dict.get("equip_fraction_lost_range", (DEFAULT_EQUIP_FRACTION_LOST, DEFAULT_EQUIP_FRACTION_LOST))

    print(f"[DEBUG assign_light_params] Initial ranges from param_dict/defaults (before overrides):")
    print(f"  LIGHTS_WM2_range: {lights_rng} {'(from param_dict)' if 'LIGHTS_WM2_range' in param_dict else '(default const)'}")
    print(f"  PARASITIC_WM2_range: {parasitic_rng} {'(from param_dict)' if 'PARASITIC_WM2_range' in param_dict else '(default const)'}")
    print(f"  tD_range: {tD_rng} {'(from param_dict)' if 'tD_range' in param_dict else '(default const)'}")
    print(f"  tN_range: {tN_rng} {'(from param_dict)' if 'tN_range' in param_dict else '(default const)'}")
    print(f"  lights_fraction_radiant_range: {lights_fraction_radiant_rng} {'(from param_dict)' if 'lights_fraction_radiant_range' in param_dict else '(default const)'}")
    print(f"  lights_fraction_visible_range: {lights_fraction_visible_rng} {'(from param_dict)' if 'lights_fraction_visible_range' in param_dict else '(default const)'}")
    print(f"  lights_fraction_replaceable_range: {lights_fraction_replace_rng} {'(from param_dict)' if 'lights_fraction_replaceable_range' in param_dict else '(default const)'}")
    print(f"  equip_fraction_radiant_range: {equip_fraction_radiant_rng} {'(from param_dict)' if 'equip_fraction_radiant_range' in param_dict else '(default const)'}")
    print(f"  equip_fraction_lost_range: {equip_fraction_lost_rng} {'(from param_dict)' if 'equip_fraction_lost_range' in param_dict else '(default const)'}")

    # (E) Find any user overrides that apply
    if user_config is not None:
        matches = find_applicable_overrides(building_id, sub_type, age_range, user_config)
    else:
        matches = []
    
    # This debug print is already in your code and is useful:
    print(f"[DEBUG lighting] bldg_id={building_id}, type='{sub_type}', matched overrides => {matches}") # Original debug line

    # (F) Override default ranges with user-config
    if matches:
        print(f"[DEBUG assign_light_params] Applying {len(matches)} overrides...")
    for row_idx, row in enumerate(matches):
        pname = row.get("param_name", "").strip().lower()
        fv = row.get("fixed_value", None) 
        mn = row.get("min_val", None)
        mx = row.get("max_val", None)
        
        current_rng = None
        if fv is not None: current_rng = (float(fv), float(fv))
        elif mn is not None and mx is not None: current_rng = (float(mn), float(mx))
        
        if current_rng:
            print(f"  [DEBUG assign_light_params] Override {row_idx+1}: param='{pname}', new_range={current_rng}")
            if pname == "lights_wm2": lights_rng = current_rng
            elif pname == "parasitic_wm2": parasitic_rng = current_rng
            elif pname == "td": tD_rng = current_rng
            elif pname == "tn": tN_rng = current_rng
            elif pname == "lights_fraction_radiant": lights_fraction_radiant_rng = current_rng
            elif pname == "lights_fraction_visible": lights_fraction_visible_rng = current_rng
            elif pname == "lights_fraction_replaceable": lights_fraction_replace_rng = current_rng
            elif pname == "equip_fraction_radiant": equip_fraction_radiant_rng = current_rng
            elif pname == "equip_fraction_lost": equip_fraction_lost_rng = current_rng
            else: print(f"    [DEBUG assign_light_params] Unrecognized param_name '{pname}' in override row.")
        else:
            print(f"  [DEBUG assign_light_params] Override {row_idx+1} for '{pname}' skipped (no fixed_value or min/max_val).")
    
    if matches: print(f"[DEBUG assign_light_params] Ranges after overrides: lights_rng={lights_rng}, parasitic_rng={parasitic_rng}, etc.")

    # (G) Pick final values
    def pick_val(param_name, r): # Added param_name for better logging
        val = None
        if strategy == "A": val = (r[0] + r[1]) / 2.0
        elif strategy == "B": val = random.uniform(r[0], r[1])
        else: val = r[0]
        print(f"  [DEBUG assign_light_params] pick_val for '{param_name}': range={r}, strategy='{strategy}', picked={val}")
        return val

    assigned_lights = pick_val("lights_wm2", lights_rng)
    assigned_paras  = pick_val("parasitic_wm2", parasitic_rng)
    assigned_tD     = pick_val("tD", tD_rng)
    assigned_tN     = pick_val("tN", tN_rng)
    assigned_lights_frac_rad = pick_val("lights_fraction_radiant", lights_fraction_radiant_rng)
    assigned_lights_frac_vis = pick_val("lights_fraction_visible", lights_fraction_visible_rng)
    assigned_lights_frac_rep = pick_val("lights_fraction_replaceable", lights_fraction_replace_rng)
    assigned_equip_frac_rad  = pick_val("equip_fraction_radiant", equip_fraction_radiant_rng)
    assigned_equip_frac_lost = pick_val("equip_fraction_lost", equip_fraction_lost_rng)
    
    # (H) Build final dict
    assigned = {
        "lights_wm2": {"assigned_value": assigned_lights, "min_val": lights_rng[0], "max_val": lights_rng[1], "object_name": "LIGHTS"},
        "parasitic_wm2": {"assigned_value": assigned_paras, "min_val": parasitic_rng[0], "max_val": parasitic_rng[1], "object_name": "ELECTRICEQUIPMENT"},
        "tD": {"assigned_value": assigned_tD, "min_val": tD_rng[0], "max_val": tD_rng[1], "object_name": "LIGHTS_SCHEDULE"},
        "tN": {"assigned_value": assigned_tN, "min_val": tN_rng[0], "max_val": tN_rng[1], "object_name": "LIGHTS_SCHEDULE"},
        "lights_fraction_radiant": {"assigned_value": assigned_lights_frac_rad, "min_val": lights_fraction_radiant_rng[0], "max_val": lights_fraction_radiant_rng[1], "object_name": "LIGHTS.Fraction_Radiant"},
        "lights_fraction_visible": {"assigned_value": assigned_lights_frac_vis, "min_val": lights_fraction_visible_rng[0], "max_val": lights_fraction_visible_rng[1], "object_name": "LIGHTS.Fraction_Visible"},
        "lights_fraction_replaceable": {"assigned_value": assigned_lights_frac_rep, "min_val": lights_fraction_replace_rng[0], "max_val": lights_fraction_replace_rng[1], "object_name": "LIGHTS.Fraction_Replaceable"},
        "equip_fraction_radiant": {"assigned_value": assigned_equip_frac_rad, "min_val": equip_fraction_radiant_rng[0], "max_val": equip_fraction_radiant_rng[1], "object_name": "ELECTRICEQUIPMENT.Fraction_Radiant"},
        "equip_fraction_lost": {"assigned_value": assigned_equip_frac_lost, "min_val": equip_fraction_lost_rng[0], "max_val": equip_fraction_lost_rng[1], "object_name": "ELECTRICEQUIPMENT.Fraction_Lost"}
    }
    print(f"[DEBUG assign_light_params] Final assigned dict structure: {assigned}")

    # (I) Optionally store in assigned_log
    if assigned_log is not None:
        assigned_log[building_id] = assigned
    
    print(f"--- [END DEBUG assign_lighting_parameters for bldg_id {building_id}] ---")
    return assigned
------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\Elec\constants.py
============================================================
# Elec/constants.py

"""
Global constants or default fallback values for the lighting module.
These can be overridden by user configs or Excel-based overrides.
"""

# Default power density values (W/m²)
DEFAULT_LIGHTING_WM2 = 10.0
DEFAULT_PARASITIC_WM2 = 0.285

# Default burning hours if not found in the lookup
DEFAULT_TD = 2000
DEFAULT_TN = 300

# Optional: If you want fraction parameter defaults here
# (instead of defining them in the fallback block of assign_lighting_values.py),
# you can do so, e.g.:
DEFAULT_LIGHTS_FRACTION_RADIANT = 0.7
DEFAULT_LIGHTS_FRACTION_VISIBLE = 0.2
DEFAULT_LIGHTS_FRACTION_REPLACEABLE = 1.0

DEFAULT_EQUIP_FRACTION_RADIANT = 0.0
DEFAULT_EQUIP_FRACTION_LOST = 1.0

# You can import & use these defaults in assign_lighting_values.py
# or wherever you handle fraction parameters.

------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\Elec\lighting_lookup.py
============================================================
# Elec/lighting_lookup.py

"""
Lighting Lookup Table (Pre/Post Calibration)
---------------------------------------------
This version includes fraction parameters for both LIGHTS
and ELECTRICEQUIPMENT objects.

NOTE (รอบนี้): The "LIGHTS_WM2_range" values below for non-residential pre_calibration
have been FURTHER ADJUSTED to represent MORE ENERGY-EFFICIENT lighting scenarios.
These are ILLUSTRATIVE examples aiming for good practice levels and MUST BE
VALIDATED against specific project requirements and local standards (e.g., NTA 8800).
The tD_range and tN_range are NOT directly used by the EnergyPlus LIGHTS object's
energy calculation in the provided scripts; schedules from schedule_def.py are used.
"""

lighting_lookup = {
    "pre_calibration": {
        # ===============================
        # 1) RESIDENTIAL (all sub-types)
        # ===============================
        # LPD values remain 0.0 as per original; implies residential lighting
        # is accounted for elsewhere or via a different methodology in your project.
        "Residential": {
            "Corner House": {
                "LIGHTS_WM2_range": (0.0, 0.0),
                "PARASITIC_WM2_range": (0.0, 0.0), # No separate parasitic if main LPD is 0
                "tD_range": (0, 0),
                "tN_range": (0, 0),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (1.0, 1.0),
            },
            "Apartment": { "LIGHTS_WM2_range": (0.0,0.0), "PARASITIC_WM2_range": (0.0,0.0), "tD_range": (0,0), "tN_range": (0,0), "lights_fraction_radiant_range": (0.7,0.7), "lights_fraction_visible_range": (0.2,0.2), "lights_fraction_replaceable_range": (1.0,1.0), "equip_fraction_radiant_range": (0.0,0.0), "equip_fraction_lost_range": (1.0,1.0)},
            "Terrace or Semi-detached House": { "LIGHTS_WM2_range": (0.0,0.0), "PARASITIC_WM2_range": (0.0,0.0), "tD_range": (0,0), "tN_range": (0,0), "lights_fraction_radiant_range": (0.7,0.7), "lights_fraction_visible_range": (0.2,0.2), "lights_fraction_replaceable_range": (1.0,1.0), "equip_fraction_radiant_range": (0.0,0.0), "equip_fraction_lost_range": (1.0,1.0)},
            "Detached House": { "LIGHTS_WM2_range": (0.0,0.0), "PARASITIC_WM2_range": (0.0,0.0), "tD_range": (0,0), "tN_range": (0,0), "lights_fraction_radiant_range": (0.7,0.7), "lights_fraction_visible_range": (0.2,0.2), "lights_fraction_replaceable_range": (1.0,1.0), "equip_fraction_radiant_range": (0.0,0.0), "equip_fraction_lost_range": (1.0,1.0)},
            "Two-and-a-half-story House": { "LIGHTS_WM2_range": (0.0,0.0), "PARASITIC_WM2_range": (0.0,0.0), "tD_range": (0,0), "tN_range": (0,0), "lights_fraction_radiant_range": (0.7,0.7), "lights_fraction_visible_range": (0.2,0.2), "lights_fraction_replaceable_range": (1.0,1.0), "equip_fraction_radiant_range": (0.0,0.0), "equip_fraction_lost_range": (1.0,1.0)}
        },

        # ===============================
        # 2) NON-RESIDENTIAL (Values further adjusted for higher efficiency)
        # ===============================
        "Non-Residential": {
            "Office Function": {
                "LIGHTS_WM2_range": (4.0, 7.0),    # Efficient office LPD
                "PARASITIC_WM2_range": (0.1, 0.15), # Lowered for efficient drivers
                "tD_range": (2000, 2500),
                "tN_range": (100, 200),
                "lights_fraction_radiant_range": (0.6, 0.7),
                "lights_fraction_visible_range": (0.2, 0.25),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0), # Parasitic equip heat gain
                "equip_fraction_lost_range": (0.0, 0.0),    # Assume parasitic heat contributes to zone
            },
            "Retail Function": { # General ambient lighting; display can be extra or averaged in
                "LIGHTS_WM2_range": (6.0, 12.0),   # Lowered significantly
                "PARASITIC_WM2_range": (0.15, 0.25),
                "tD_range": (3000, 4000),
                "tN_range": (200, 400),
                "lights_fraction_radiant_range": (0.6, 0.7),
                "lights_fraction_visible_range": (0.2, 0.25),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (0.0, 0.0),
            },
            "Education Function": { # Classrooms, libraries
                "LIGHTS_WM2_range": (3.5, 6.0),    # Efficient school lighting
                "PARASITIC_WM2_range": (0.1, 0.15),
                "tD_range": (1500, 1800),
                "tN_range": (50, 100),
                "lights_fraction_radiant_range": (0.6, 0.7),
                "lights_fraction_visible_range": (0.2, 0.25),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (0.0, 0.0),
            },
            "Healthcare Function": { # General areas; labs/surgery distinct
                "LIGHTS_WM2_range": (5.0, 9.0),    # Lowered for general patient/corridor areas
                "PARASITIC_WM2_range": (0.15, 0.25),
                "tD_range": (3000, 5000),
                "tN_range": (500, 1000),
                "lights_fraction_radiant_range": (0.6, 0.7),
                "lights_fraction_visible_range": (0.2, 0.25),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (0.0, 0.0),
            },
            "Meeting Function": {
                "LIGHTS_WM2_range": (5.0, 8.0),
                "PARASITIC_WM2_range": (0.1, 0.15),
                "tD_range": (1800, 2200),
                "tN_range": (200, 300),
                "lights_fraction_radiant_range": (0.6, 0.7),
                "lights_fraction_visible_range": (0.2, 0.25),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (0.0, 0.0),
            },
            "Sport Function": {
                "LIGHTS_WM2_range": (7.0, 11.0), # Maintained, as sports lighting can be intensive
                "PARASITIC_WM2_range": (0.15, 0.25),
                "tD_range": (2000, 2500),
                "tN_range": (500, 800),
                "lights_fraction_radiant_range": (0.5, 0.6),
                "lights_fraction_visible_range": (0.25, 0.3),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (0.0, 0.0),
            },
            "Cell Function": {
                "LIGHTS_WM2_range": (4.0, 7.0), # Lowered
                "PARASITIC_WM2_range": (0.1, 0.15),
                "tD_range": (6000, 8000),
                "tN_range": (6000, 8000),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (0.0, 0.0),
            },
            "Industrial Function": { # General lighting, not process-specific
                "LIGHTS_WM2_range": (5.0, 9.0), # Lowered
                "PARASITIC_WM2_range": (0.1, 0.2),
                "tD_range": (2500, 4000),
                "tN_range": (100, 300),
                "lights_fraction_radiant_range": (0.5, 0.6),
                "lights_fraction_visible_range": (0.25, 0.3),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (0.0, 0.0),
            },
            "Accommodation Function": { # Guest rooms / dorms
                "LIGHTS_WM2_range": (3.0, 6.0), # Lowered
                "PARASITIC_WM2_range": (0.1, 0.15),
                "tD_range": (1500, 2500),
                "tN_range": (3000, 5000),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (0.0, 0.0),
            },
            "Other Use Function": {
                "LIGHTS_WM2_range": (5.0, 8.0), # Lowered
                "PARASITIC_WM2_range": (0.1, 0.2),
                "tD_range": (2000, 2500),
                "tN_range": (100, 300),
                "lights_fraction_radiant_range": (0.7, 0.7),
                "lights_fraction_visible_range": (0.2, 0.2),
                "lights_fraction_replaceable_range": (1.0, 1.0),
                "equip_fraction_radiant_range": (0.0, 0.0),
                "equip_fraction_lost_range": (0.0, 0.0),
            }
        }
    },
    "post_calibration": {
        # Post-calibration values are highly project-specific and should be
        # determined by actual calibration efforts.
        # The structure from your original file is maintained as a placeholder.
        "Residential": {
            "Corner House": {"LIGHTS_WM2_range": (0.0,0.0), "PARASITIC_WM2_range": (0.0,0.0), "tD_range": (0,0), "tN_range": (0,0), "lights_fraction_radiant_range": (0.7,0.7), "lights_fraction_visible_range": (0.2,0.2), "lights_fraction_replaceable_range": (1.0,1.0), "equip_fraction_radiant_range": (0.0,0.0), "equip_fraction_lost_range": (1.0,1.0)},
            "Apartment": {"LIGHTS_WM2_range": (0.0,0.0), "PARASITIC_WM2_range": (0.0,0.0), "tD_range": (0,0), "tN_range": (0,0), "lights_fraction_radiant_range": (0.7,0.7), "lights_fraction_visible_range": (0.2,0.2), "lights_fraction_replaceable_range": (1.0,1.0), "equip_fraction_radiant_range": (0.0,0.0), "equip_fraction_lost_range": (1.0,1.0)},
            "Terrace or Semi-detached House": {"LIGHTS_WM2_range": (0.0,0.0), "PARASITIC_WM2_range": (0.0,0.0), "tD_range": (0,0), "tN_range": (0,0), "lights_fraction_radiant_range": (0.7,0.7), "lights_fraction_visible_range": (0.2,0.2), "lights_fraction_replaceable_range": (1.0,1.0), "equip_fraction_radiant_range": (0.0,0.0), "equip_fraction_lost_range": (1.0,1.0)},
            "Detached House": {"LIGHTS_WM2_range": (0.0,0.0), "PARASITIC_WM2_range": (0.0,0.0), "tD_range": (0,0), "tN_range": (0,0), "lights_fraction_radiant_range": (0.7,0.7), "lights_fraction_visible_range": (0.2,0.2), "lights_fraction_replaceable_range": (1.0,1.0), "equip_fraction_radiant_range": (0.0,0.0), "equip_fraction_lost_range": (1.0,1.0)},
            "Two-and-a-half-story House": {"LIGHTS_WM2_range": (0.0,0.0), "PARASITIC_WM2_range": (0.0,0.0), "tD_range": (0,0), "tN_range": (0,0), "lights_fraction_radiant_range": (0.7,0.7), "lights_fraction_visible_range": (0.2,0.2), "lights_fraction_replaceable_range": (1.0,1.0), "equip_fraction_radiant_range": (0.0,0.0), "equip_fraction_lost_range": (1.0,1.0)}
        },
        "Non-Residential": { # Copying one example, others would follow similar calibrated pattern
            "Office Function": {"LIGHTS_WM2_range": (5.0,5.0), "PARASITIC_WM2_range": (0.1,0.1), "tD_range": (2300,2300), "tN_range": (150,150), "lights_fraction_radiant_range": (0.6,0.6), "lights_fraction_visible_range": (0.25,0.25), "lights_fraction_replaceable_range": (1.0,1.0), "equip_fraction_radiant_range": (0.0,0.0), "equip_fraction_lost_range": (0.0,0.0)},
            # ... other non-residential types should be filled with actual calibrated values ...
            "Meeting Function": {"LIGHTS_WM2_range": (6.0,6.0), "PARASITIC_WM2_range": (0.1,0.1), "tD_range": (2000,2000), "tN_range": (200,200), "lights_fraction_radiant_range": (0.6,0.6), "lights_fraction_visible_range": (0.25,0.25), "lights_fraction_replaceable_range": (1.0,1.0), "equip_fraction_radiant_range": (0.0,0.0), "equip_fraction_lost_range": (0.0,0.0)},
            "Healthcare Function": {"LIGHTS_WM2_range": (7.0,7.0), "PARASITIC_WM2_range": (0.2,0.2), "tD_range": (4000,4000), "tN_range": (600,600), "lights_fraction_radiant_range": (0.65,0.65), "lights_fraction_visible_range": (0.22,0.22), "lights_fraction_replaceable_range": (1.0,1.0), "equip_fraction_radiant_range": (0.0,0.0), "equip_fraction_lost_range": (0.0,0.0)},
            "Sport Function": {"LIGHTS_WM2_range": (9.0,9.0), "PARASITIC_WM2_range": (0.2,0.2), "tD_range": (2200,2200), "tN_range": (550,550), "lights_fraction_radiant_range": (0.55,0.55), "lights_fraction_visible_range": (0.28,0.28), "lights_fraction_replaceable_range": (1.0,1.0), "equip_fraction_radiant_range": (0.0,0.0), "equip_fraction_lost_range": (0.0,0.0)},
            "Cell Function": {"LIGHTS_WM2_range": (5.0,5.0), "PARASITIC_WM2_range": (0.1,0.1), "tD_range": (7000,7000), "tN_range": (7000,7000), "lights_fraction_radiant_range": (0.7,0.7), "lights_fraction_visible_range": (0.2,0.2), "lights_fraction_replaceable_range": (1.0,1.0), "equip_fraction_radiant_range": (0.0,0.0), "equip_fraction_lost_range": (0.0,0.0)},
            "Retail Function": {"LIGHTS_WM2_range": (10.0,10.0), "PARASITIC_WM2_range": (0.2,0.2), "tD_range": (3200,3200), "tN_range": (250,250), "lights_fraction_radiant_range": (0.65,0.65), "lights_fraction_visible_range": (0.22,0.22), "lights_fraction_replaceable_range": (1.0,1.0), "equip_fraction_radiant_range": (0.0,0.0), "equip_fraction_lost_range": (0.0,0.0)},
            "Industrial Function": {"LIGHTS_WM2_range": (7.0,7.0), "PARASITIC_WM2_range": (0.1,0.1), "tD_range": (3000,3000), "tN_range": (150,150), "lights_fraction_radiant_range": (0.55,0.55), "lights_fraction_visible_range": (0.28,0.28), "lights_fraction_replaceable_range": (1.0,1.0), "equip_fraction_radiant_range": (0.0,0.0), "equip_fraction_lost_range": (0.0,0.0)},
            "Accommodation Function": {"LIGHTS_WM2_range": (4.0,4.0), "PARASITIC_WM2_range": (0.1,0.1), "tD_range": (2000,2000), "tN_range": (3500,3500), "lights_fraction_radiant_range": (0.7,0.7), "lights_fraction_visible_range": (0.2,0.2), "lights_fraction_replaceable_range": (1.0,1.0), "equip_fraction_radiant_range": (0.0,0.0), "equip_fraction_lost_range": (0.0,0.0)},
            "Education Function": {"LIGHTS_WM2_range": (4.0,4.0), "PARASITIC_WM2_range": (0.1,0.1), "tD_range": (1600,1600), "tN_range": (60,60), "lights_fraction_radiant_range": (0.65,0.65), "lights_fraction_visible_range": (0.22,0.22), "lights_fraction_replaceable_range": (1.0,1.0), "equip_fraction_radiant_range": (0.0,0.0), "equip_fraction_lost_range": (0.0,0.0)},
            "Other Use Function": {"LIGHTS_WM2_range": (6.0,6.0), "PARASITIC_WM2_range": (0.15,0.15), "tD_range": (2200,2200), "tN_range": (150,150), "lights_fraction_radiant_range": (0.7,0.7), "lights_fraction_visible_range": (0.2,0.2), "lights_fraction_replaceable_range": (1.0,1.0), "equip_fraction_radiant_range": (0.0,0.0), "equip_fraction_lost_range": (0.0,0.0)}
        }
    }
}
------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\Elec\lighting.py
============================================================
# File: D:\Documents\E_Plus_2030_py\idf_objects\Elec\lighting.py

from .assign_lighting_values import assign_lighting_parameters
from .schedules import create_lighting_schedule, create_parasitic_schedule

def get_building_category_and_subtype(building_row):
    """
    Return (building_category, sub_type) based on ``building_row``.
    It now correctly uses 'residential_type' or 'non_residential_type'
    based on the value of 'building_function', and handles potential float inputs.
    """
    
    print(f"\n--- [DEBUG get_category_subtype] ---")
    
    # Get raw values first for logging their original types
    raw_building_function = building_row.get("building_function")
    raw_residential_type = building_row.get("residential_type")
    raw_non_residential_type = building_row.get("non_residential_type")

    print(f"[DEBUG get_category_subtype] Raw building_row.get('building_function'): '{raw_building_function}' (type: {type(raw_building_function)})")
    print(f"[DEBUG get_category_subtype] Raw building_row.get('residential_type'): '{raw_residential_type}' (type: {type(raw_residential_type)})")
    print(f"[DEBUG get_category_subtype] Raw building_row.get('non_residential_type'): '{raw_non_residential_type}' (type: {type(raw_non_residential_type)})")

    # Convert to string, then strip/lower. Default to "" if key is missing before str().
    building_function_str = str(building_row.get("building_function", ""))
    residential_type_str = str(building_row.get("residential_type", ""))
    non_residential_type_str = str(building_row.get("non_residential_type", ""))

    # Debug after string conversion
    print(f"[DEBUG get_category_subtype] Stringified building_function: '{building_function_str}'")
    print(f"[DEBUG get_category_subtype] Stringified residential_type: '{residential_type_str}'")
    print(f"[DEBUG get_category_subtype] Stringified non_residential_type: '{non_residential_type_str}'")

    building_function_val = building_function_str.strip().lower()
    residential_type_val = residential_type_str.strip() # Specific types should retain their case for lookup
    non_residential_type_val = non_residential_type_str.strip() # Specific types should retain their case
    
    print(f"[DEBUG get_category_subtype] Processed building_function_val (lowercase, stripped): '{building_function_val}'")
    print(f"[DEBUG get_category_subtype] Processed residential_type_val (stripped): '{residential_type_val}'")
    print(f"[DEBUG get_category_subtype] Processed non_residential_type_val (stripped): '{non_residential_type_val}'")

    building_category = None
    sub_type_for_lookup = None
    
    # Check for "empty" or non-informative strings like "nan" or "none" after stripping
    def is_valid_type_string(s):
        if not s: return False
        s_lower = s.lower()
        return s_lower != 'nan' and s_lower != 'none' and s_lower != '<na>' # Common pandas NA string representation

    if building_function_val == "residential":
        if is_valid_type_string(residential_type_val):
            building_category = "Residential"
            sub_type_for_lookup = residential_type_val # Use the value with original casing
            print(f"[DEBUG get_category_subtype] 'building_function' is 'residential'. Using 'residential_type': '{sub_type_for_lookup}' as sub_type.")
        else:
            print(f"[DEBUG get_category_subtype] WARNING: 'building_function' is 'residential' but 'residential_type' ('{residential_type_val}') is empty or non-informative.")
            building_category = "Residential"
            sub_type_for_lookup = "Apartment" # Fallback to a default specific residential type
            print(f"[DEBUG get_category_subtype] Defaulting to category='{building_category}', sub_type='{sub_type_for_lookup}' due to problematic residential_type.")
            
    elif building_function_val == "non_residential":
        if is_valid_type_string(non_residential_type_val):
            building_category = "Non-Residential"
            sub_type_for_lookup = non_residential_type_val # Use the value with original casing
            print(f"[DEBUG get_category_subtype] 'building_function' is 'non_residential'. Using 'non_residential_type': '{sub_type_for_lookup}' as sub_type.")
        else:
            print(f"[DEBUG get_category_subtype] WARNING: 'building_function' is 'non_residential' but 'non_residential_type' ('{non_residential_type_val}') is empty or non-informative.")
            building_category = "Non-Residential"
            sub_type_for_lookup = "Other Use Function" # Fallback to a default specific non-residential type
            print(f"[DEBUG get_category_subtype] Defaulting to category='{building_category}', sub_type='{sub_type_for_lookup}' due to problematic non_residential_type.")
            
    else: 
        # building_function itself might be the specific sub-type, or it's empty/invalid.
        # Use original casing for direct_bldg_func_val before stripping.
        direct_bldg_func_val_str = str(building_row.get("building_function", ""))
        direct_bldg_func_val_stripped = direct_bldg_func_val_str.strip()
        
        print(f"[DEBUG get_category_subtype] 'building_function' ('{direct_bldg_func_val_stripped}') is not 'residential' or 'non_residential'. Attempting direct categorization of this value.")
        
        if not is_valid_type_string(direct_bldg_func_val_stripped):
            print(f"[DEBUG get_category_subtype] Direct 'building_function' ('{direct_bldg_func_val_stripped}') is empty or non-informative. Defaulting to Non-Residential, Other Use Function.")
            building_category = "Non-Residential"
            sub_type_for_lookup = "Other Use Function"
        else:
            sub_type_for_lookup = direct_bldg_func_val_stripped # This is the specific sub-type
            # Define known types here for this fallback path
            known_residential_sub_types = {
                "Apartment", "Corner House", "Detached House",
                "Terrace or Semi-detached House", "Two-and-a-half-story House",
            } # Ensure these match your lookup keys' casing
            known_non_residential_sub_types = {
                "Accommodation Function", "Cell Function", "Education Function",
                "Healthcare Function", "Industrial Function", "Meeting Function",
                "Office Function", "Other Use Function", "Retail Function", "Sport Function",
            } # Ensure these match your lookup keys' casing

            if sub_type_for_lookup in known_residential_sub_types:
                building_category = "Residential"
                print(f"[DEBUG get_category_subtype] Matched direct building_function '{sub_type_for_lookup}' to known_residential_sub_types.")
            elif sub_type_for_lookup in known_non_residential_sub_types:
                building_category = "Non-Residential"
                print(f"[DEBUG get_category_subtype] Matched direct building_function '{sub_type_for_lookup}' to known_non_residential_sub_types.")
            else:
                print(f"[DEBUG get_category_subtype] WARNING: Unknown direct building_function '{sub_type_for_lookup}'. Defaulting category to Non-Residential.")
                building_category = "Non-Residential" # Default for truly unknown specific types

    # Final safety net if logic above somehow fails to set category or sub_type adequately
    if not building_category or not is_valid_type_string(sub_type_for_lookup):
        print(f"[DEBUG get_category_subtype] CRITICAL FALLBACK: Could not determine valid category or sub_type (current sub_type: '{sub_type_for_lookup}'). Defaulting to Non-Residential, Other Use Function.")
        building_category = "Non-Residential"
        sub_type_for_lookup = "Other Use Function"

    print(f"[DEBUG get_category_subtype] Final Determined: building_category='{building_category}', sub_type_for_lookup='{sub_type_for_lookup}'")
    print(f"--- [END DEBUG get_category_subtype] ---")
    return (building_category, sub_type_for_lookup)


# The rest of your Elec/lighting.py file (add_lights_and_parasitics function) remains the same
# as the version I provided in the previous message with its own debug prints.
# Ensure it uses this updated get_building_category_and_subtype function.

def add_lights_and_parasitics(
    idf,
    building_row,
    calibration_stage="pre_calibration",
    strategy="A",
    random_seed=None,
    user_config=None,
    assigned_values_log=None,
    zonelist_name="ALL_ZONES"
):
    """
    1) Determine building_category (Residential/Non-Residential) and sub_type.
    2) Retrieve assigned lighting parameters (including fraction fields).
    3) Create schedules in IDF:
       - A lighting schedule for the LIGHTS object
       - An always-on parasitic schedule for ELECTRICEQUIPMENT
    4) Add LIGHTS and ELECTRICEQUIPMENT objects referencing a ZoneList in the IDF.

    The assigned parameters and final picks are stored in assigned_values_log[ogc_fid]
    if assigned_values_log is provided.
    """

    # 1) Get building_category / sub_type
    building_category, sub_type = get_building_category_and_subtype(building_row) 
    
    # 2) Retrieve lighting parameters
    bldg_id = int(building_row.get("ogc_fid", 0)) 
    print(f"\n--- [DEBUG add_lights_and_parasitics for bldg_id {bldg_id}] ---") 
    print(f"[DEBUG add_lights_and_parasitics] From get_building_category_and_subtype: category='{building_category}', sub_type='{sub_type}'")


    assigned_dict = assign_lighting_parameters( 
        building_id=bldg_id,
        building_category=building_category,
        sub_type=sub_type,
        age_range=building_row.get("age_range", None), 
        calibration_stage=calibration_stage,
        strategy=strategy,
        random_seed=random_seed,
        user_config=user_config,
        assigned_log=assigned_values_log 
    )

    lights_wm2 = assigned_dict["lights_wm2"]["assigned_value"]
    parasitic_wm2 = assigned_dict["parasitic_wm2"]["assigned_value"]
    lights_frac_radiant = assigned_dict["lights_fraction_radiant"]["assigned_value"]
    lights_frac_visible = assigned_dict["lights_fraction_visible"]["assigned_value"]
    lights_frac_replace = assigned_dict["lights_fraction_replaceable"]["assigned_value"]
    equip_frac_radiant = assigned_dict["equip_fraction_radiant"]["assigned_value"]
    equip_frac_lost = assigned_dict["equip_fraction_lost"]["assigned_value"]

    lights_sched_name = create_lighting_schedule(
        idf, building_category=building_category, sub_type=sub_type, schedule_name="LightsSchedule"
    )
    paras_sched_name = create_parasitic_schedule(idf, sched_name="ParasiticSchedule")

    lights_obj = idf.newidfobject("LIGHTS")
    lights_obj.Name = f"Lights_{zonelist_name}"
    lights_obj.Zone_or_ZoneList_or_Space_or_SpaceList_Name = zonelist_name
    lights_obj.Schedule_Name = lights_sched_name
    lights_obj.Design_Level_Calculation_Method = "Watts/Area"
    lights_obj.Watts_per_Zone_Floor_Area = lights_wm2
    lights_obj.Fraction_Radiant = lights_frac_radiant
    lights_obj.Fraction_Visible = lights_frac_visible
    lights_obj.Fraction_Replaceable = lights_frac_replace

    eq_obj = idf.newidfobject("ELECTRICEQUIPMENT")
    eq_obj.Name = f"Parasitic_{zonelist_name}"
    eq_obj.Zone_or_ZoneList_or_Space_or_SpaceList_Name = zonelist_name
    eq_obj.Schedule_Name = paras_sched_name
    eq_obj.Design_Level_Calculation_Method = "Watts/Area"
    eq_obj.Watts_per_Zone_Floor_Area = parasitic_wm2
    eq_obj.Fraction_Radiant = equip_frac_radiant
    eq_obj.Fraction_Lost = equip_frac_lost
    
    print(f"[DEBUG add_lights_and_parasitics] Successfully created LIGHTS and ELECTRICEQUIPMENT objects for bldg_id {bldg_id}.")
    print(f"--- [END DEBUG add_lights_and_parasitics for bldg_id {bldg_id}] ---")
    return lights_obj, eq_obj
------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\Elec\schedule_def.py
============================================================
# Elec/schedule_def.py

import pandas as pd # Keep import if excel reading functions are used

"""
This file holds:
1) A default SCHEDULE_DEFINITIONS dictionary for lighting usage patterns
   (weekday vs. weekend) for Residential & Non-Residential sub-types.
2) (Optional) Functions to read & apply schedule overrides from Excel.

NOTE (รอบนี้): The non-residential schedules below have been FURTHER REFINED
to represent more energy-conscious operational patterns. These are ILLUSTRATIVE
examples and MUST BE VALIDATED and customized based on specific project
requirements, occupancy data, control strategies, and local standards
(e.g., NTA 8800 usage profiles for the Netherlands).
"""

# 1) Default SCHEDULE Definitions
SCHEDULE_DEFINITIONS = {
    "Residential": {
        # Residential schedules - minor adjustments for potentially lower unoccupied use
        "Corner House": {
            "weekday": [(0, 6, 0.03), (6, 9, 0.25), (9, 17, 0.08), (17, 22, 0.45), (22, 24, 0.03)],
            "weekend": [(0, 7, 0.05), (7, 22, 0.35), (22, 24, 0.05)],
        },
        "Apartment": {
            "weekday": [(0, 6, 0.02), (6, 8, 0.20), (8, 18, 0.05), (18, 23, 0.40), (23, 24, 0.02)],
            "weekend": [(0, 8, 0.04), (8, 22, 0.30), (22, 24, 0.04)],
        },
        "Terrace or Semi-detached House": { # Similar to Corner House
            "weekday": [(0, 6, 0.03), (6, 9, 0.25), (9, 17, 0.08), (17, 22, 0.45), (22, 24, 0.03)],
            "weekend": [(0, 7, 0.05), (7, 22, 0.35), (22, 24, 0.05)],
        },
        "Detached House": {
            "weekday": [(0, 6, 0.04), (6, 9, 0.30), (9, 17, 0.10), (17, 22, 0.50), (22, 24, 0.04)],
            "weekend": [(0, 7, 0.06), (7, 23, 0.40), (23, 24, 0.06)],
        },
        "Two-and-a-half-story House": { # Similar to Detached or Corner House
            "weekday": [(0, 6, 0.03), (6, 9, 0.25), (9, 17, 0.08), (17, 22, 0.45), (22, 24, 0.03)],
            "weekend": [(0, 7, 0.05), (7, 22, 0.35), (22, 24, 0.05)],
        },
    },
    "Non-Residential": {
        "Office Function": { # Assumes good practice, e.g. 8:00-18:00 core hours
            "weekday": [
                (0, 7, 0.02),   # Unoccupied / Cleaning minimal
                (7, 8, 0.15),   # Early arrivals / Setup
                (8, 12, 0.80),  # Morning peak (potentially lower with daylighting)
                (12, 13, 0.30), # Lunch (reduced lighting in some areas)
                (13, 17, 0.80), # Afternoon peak
                (17, 18, 0.25), # Late leavers / Winding down
                (18, 24, 0.02),  # Unoccupied
            ],
            "weekend": [ # Minimal, for security/occasional access
                (0, 24, 0.02),
            ],
        },
        "Retail Function": { # Core hours e.g., 10:00-18:00/19:00
            "weekday": [
                (0, 8, 0.01),   # Closed, security minimal
                (8, 10, 0.20),  # Staff prep, partial lighting
                (10, 18, 0.80), # Open - peak (could be higher for specific display, lower for ambient)
                (18, 19, 0.30), # Closing
                (19, 24, 0.01),  # Closed
            ],
            "weekend": [ # Assuming Saturday is similar to weekday, Sunday potentially shorter/lower
                (0, 9, 0.01),
                (9, 17, 0.75),  # e.g. Sunday hours
                (17, 18, 0.25),
                (18, 24, 0.01),
            ],
        },
        "Education Function": { # Schools/Universities during term
            "weekday": [
                (0, 7, 0.01),   # Closed
                (7, 8, 0.20),   # Staff arrival
                (8, 12, 0.75),  # Morning classes (daylight responsive could lower this)
                (12, 13, 0.25), # Lunch break (some areas lit)
                (13, 16, 0.75), # Afternoon classes
                (16, 18, 0.15), # After school activities / cleaning
                (18, 24, 0.01),  # Closed
            ],
            "weekend": [
                (0, 24, 0.01),  # Mostly closed
            ],
        },
        "Healthcare Function": { # Highly complex; this profile attempts some variation.
                                 # Assumes lower ambient light at night in patient areas/corridors.
            "weekday": [
                (0, 6, 0.25),   # Night (essential + reduced ambient)
                (6, 20, 0.65),  # Daytime operational (average across various spaces)
                (20, 24, 0.30), # Evening/early night
            ],
            "weekend": [ # Similar pattern, potentially slightly less intensive in admin areas
                (0, 6, 0.20),
                (6, 20, 0.60),
                (20, 24, 0.25),
            ],
        },
        "Meeting Function": {
            "weekday": [
                (0, 8, 0.01),
                (8, 9, 0.25),
                (9, 12, 0.70),
                (12, 13, 0.30),
                (13, 17, 0.70),
                (17, 18, 0.20),
                (18, 24, 0.01),
            ],
            "weekend": [
                (0, 24, 0.01),
            ],
        },
        "Sport Function": {
            "weekday": [
                (0, 7, 0.01),
                (7, 16, 0.50), # Daytime use / classes
                (16, 22, 0.80), # Evening peak
                (22, 24, 0.02),
            ],
            "weekend": [
                (0, 8, 0.01),
                (8, 20, 0.70), # Weekend peak
                (20, 24, 0.02),
            ],
        },
        "Cell Function": { # Constant low level for safety/security might be needed
            "weekday": [(0, 24, 0.40)], # Assuming dimmable, efficient, not full blast 24/7
            "weekend": [(0, 24, 0.40)],
        },
        "Industrial Function": { # Assuming single or double shift, not 24/7 production
            "weekday": [
                (0, 6, 0.02),   # Unoccupied
                (6, 18, 0.70),  # Main operational hours (e.g. 1 or 2 shifts)
                (18, 22, 0.10), # Cleaning / end of day
                (22, 24, 0.02),
            ],
            "weekend": [(0, 24, 0.02)], # Mostly off
        },
        "Accommodation Function": { # Hotels: diverse use in rooms, common areas more consistent
            "weekday": [ # Weighted average behavior
                (0, 6, 0.20),   # Night (corridors, some room use)
                (6, 10, 0.40),  # Morning peak
                (10, 17, 0.25), # Daytime (rooms variable, common areas moderate)
                (17, 23, 0.60), # Evening
                (23, 24, 0.20),
            ],
            "weekend": [ # Similar pattern, potentially higher occupancy
                (0, 6, 0.25),
                (6, 11, 0.50),
                (11, 17, 0.35),
                (17, 23, 0.65),
                (23, 24, 0.25),
            ],
        },
        "Other Use Function": {
            "weekday": [
                (0, 7, 0.02),
                (7, 19, 0.50), 
                (19, 24, 0.02),
            ],
            "weekend": [
                (0, 24, 0.05), 
            ],
        },
    },
}

# Functions to read/apply Excel overrides (kept as is)
def read_schedule_overrides_from_excel(excel_path):
    df = pd.read_excel(excel_path)
    required_cols = ["building_category", "sub_type", "day_type", 
                     "start_hour", "end_hour", "fraction_value"]
    for c in required_cols:
        if c not in df.columns:
            raise ValueError(f"Missing column '{c}' in {excel_path}")
    overrides = {}
    for _, row in df.iterrows():
        cat = str(row["building_category"]).strip()
        stype = str(row["sub_type"]).strip()
        dtype = str(row["day_type"]).strip().lower()
        sh = float(row["start_hour"])
        eh = float(row["end_hour"])
        frac = float(row["fraction_value"])
        overrides.setdefault(cat, {}).setdefault(stype, {}).setdefault(dtype, []).append((sh, eh, frac))
    return overrides

def apply_schedule_overrides_to_schedules(base_schedules, overrides):
    for cat, stype_dict in overrides.items():
        base_schedules.setdefault(cat, {})
        for stype, daytypes_dict in stype_dict.items():
            base_schedules[cat].setdefault(stype, {})
            for day_type, blocks_list in daytypes_dict.items():
                base_schedules[cat][stype][day_type] = blocks_list
    return base_schedules
------------------------------------------------------------

File: D:\Documents\E_Plus_2030_py\idf_objects\Elec\schedules.py
============================================================
# Elec/schedules.py

from .schedule_def import SCHEDULE_DEFINITIONS

"""
This module creates detailed lighting schedules for weekdays and weekends,
differentiating by building_category (Residential/Non-Residential)
and by sub_type (Apartment, Office Function, etc.).

We have two main functions:
1) create_lighting_schedule(idf, building_category, sub_type, schedule_name)
   - Creates a SCHEDULE:COMPACT with different time blocks for 'WeekDays',
     'Saturday', and 'Sunday' (or 'AllDays' if you prefer).
2) create_parasitic_schedule(idf, sched_name)
   - Creates an always-on (1.0) schedule, typically for parasitic loads.

Important:
- This code assumes you already loaded or potentially overrode
  SCHEDULE_DEFINITIONS in schedule_def.py (for instance, by calling
  `read_schedule_overrides_from_excel()` + `apply_schedule_overrides_to_schedules()`).
- If you want more advanced day-splitting, feel free to expand the logic below.
"""


def create_lighting_schedule(idf, building_category, sub_type, schedule_name="LightsSchedule"):
    """
    Create a SCHEDULE:COMPACT in the IDF using SCHEDULE_DEFINITIONS[building_category][sub_type].
    We define separate blocks for:
      - For: WeekDays
      - For: Saturday
      - For: Sunday

    If the sub_type is missing in SCHEDULE_DEFINITIONS, we fallback to a simple always-0.5 pattern.

    The final IDF object name is `schedule_name`. We return that string for convenience.
    """

    # Attempt to get sub-type dictionary from SCHEDULE_DEFINITIONS
    try:
        sub_dict = SCHEDULE_DEFINITIONS[building_category][sub_type]
    except KeyError:
        # Fallback: If not found, create a simple always-0.5 schedule
        sub_dict = {
            "weekday": [(0, 24, 0.5)],
            "weekend": [(0, 24, 0.5)],
        }

    # Some sub-types might not have a separate weekend pattern. 
    # So ensure we have 'weekday' and 'weekend' keys:
    if "weekday" not in sub_dict:
        sub_dict["weekday"] = [(0, 24, 0.5)]
    if "weekend" not in sub_dict:
        sub_dict["weekend"] = [(0, 24, 0.5)]

    # Create the schedule object
    schedule = idf.newidfobject("SCHEDULE:COMPACT")
    schedule.Name = schedule_name
    schedule.Schedule_Type_Limits_Name = "Fraction"

    # We'll define the entire year with "Through: 12/31" and break it down by day types
    # The pattern is:
    #   Field_1:  "Through: 12/31"
    #   Field_2:  "For: WeekDays"
    #   Field_3+: "Until: HH:MM,<fraction>"
    #
    # Then for Saturday, Sunday, etc.

    field_idx = 1
    setattr(schedule, f"Field_{field_idx}", "Through: 12/31")
    field_idx += 1

    # 1) WeekDays
    setattr(schedule, f"Field_{field_idx}", "For: WeekDays")
    field_idx += 1
    for (start_hour, end_hour, frac) in sub_dict["weekday"]:
        # e.g. "Until: 06:00,0.05"
        setattr(schedule, f"Field_{field_idx}",
                f"Until: {int(end_hour):02d}:00,{frac:.2f}")
        field_idx += 1

    # 2) Saturday
    setattr(schedule, f"Field_{field_idx}", "For: Saturday")
    field_idx += 1
    for (start_hour, end_hour, frac) in sub_dict["weekend"]:
        setattr(schedule, f"Field_{field_idx}",
                f"Until: {int(end_hour):02d}:00,{frac:.2f}")
        field_idx += 1

    # 3) Sunday
    setattr(schedule, f"Field_{field_idx}", "For: Sunday")
    field_idx += 1
    for (start_hour, end_hour, frac) in sub_dict["weekend"]:
        setattr(schedule, f"Field_{field_idx}",
                f"Until: {int(end_hour):02d}:00,{frac:.2f}")
        field_idx += 1

    return schedule.Name


def create_parasitic_schedule(idf, sched_name="ParasiticSchedule"):
    """
    Creates an always-on schedule (1.0) for parasitic loads (24/7).
    """
    schedule = idf.newidfobject("SCHEDULE:COMPACT")
    schedule.Name = sched_name
    schedule.Schedule_Type_Limits_Name = "Fraction"

    # Single block covering all days, 24 hours
    schedule.Field_1 = "Through: 12/31"
    schedule.Field_2 = "For: AllDays"
    schedule.Field_3 = "Until: 24:00,1.0"

    return schedule.Name

------------------------------------------------------------

