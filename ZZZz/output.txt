Folder: D:\Documents\E_Plus_2030_py\idf_objects\ventilation

  File: add_ventilation.py
  --- File Contents Start ---
# ventilation/add_ventilation.py

from idf_objects.ventilation.assign_ventilation_values import (
    assign_ventilation_params_with_overrides
)
from idf_objects.ventilation.schedules import (
    create_always_on_schedule,
    create_day_night_schedule,
    create_workhours_schedule
)
from idf_objects.ventilation.create_ventilation_systems import create_ventilation_system
from idf_objects.ventilation.calc_functions import (
    calc_infiltration,
    calc_required_ventilation_flow
)
from idf_objects.ventilation.mappings import (
    safe_lower,
    map_age_range_to_year_key,
    map_infiltration_key,
    map_usage_key
)

def add_ventilation_to_idf(
    idf,
    building_row,
    calibration_stage="pre_calibration",
    strategy="A",            # "A" => pick midpoint, "B" => random, ...
    random_seed=None,
    user_config_vent=None,
    assigned_vent_log=None
):
    """
    Adds infiltration + ventilation to the IDF based on building_row data
    (using assign_ventilation_params_with_overrides). Creates infiltration
    and (optionally) ventilation objects in each zone. Also logs both
    building-level and zone-level picks to assigned_vent_log.

    Args:
        idf: geomeppy IDF object
        building_row: dict-like row containing e.g. "ogc_fid", "building_function", "age_range", "scenario", "area"
        calibration_stage: str, e.g. "pre_calibration" or "post_calibration"
        strategy: str, e.g. "A" => midpoint, "B" => random
        random_seed: int or None
        user_config_vent: list of user override dicts for ventilation
        assigned_vent_log: dict to store final building-level & zone-level picks

    Returns:
        None. (The IDF is modified in place; the picks are stored in assigned_vent_log if provided.)
    """

    # 1) Ensure key schedules exist (the default ones)
    if not idf.getobject("SCHEDULE:CONSTANT", "AlwaysOnSched"):
        create_always_on_schedule(idf, "AlwaysOnSched")
    if not idf.getobject("SCHEDULE:COMPACT", "VentSched_DayNight"):
        create_day_night_schedule(idf, "VentSched_DayNight")
    if not idf.getobject("SCHEDULE:COMPACT", "WorkHoursSched"):
        create_workhours_schedule(idf, "WorkHoursSched")

    # 2) Extract building info
    bldg_id = building_row.get("ogc_fid", 0)
    bldg_func = safe_lower(building_row.get("building_function", "residential"))
    if bldg_func not in ("residential", "non_residential"):
        bldg_func = "residential"

    age_range_str = building_row.get("age_range", "2015 and later")
    scenario = building_row.get("scenario", "scenario1")
    floor_area_m2 = building_row.get("area", 100.0)

    # 3) Decide infiltration key, usage key, etc.
    infiltration_key = map_infiltration_key(building_row)
    usage_key = map_usage_key(building_row)
    is_res = (bldg_func == "residential")

    # 4) Call the function that picks infiltration_base, year_factor, schedules, etc.
    assigned_vent = assign_ventilation_params_with_overrides(
        building_id=bldg_id,
        building_function=bldg_func,
        age_range=age_range_str,
        scenario=scenario,
        calibration_stage=calibration_stage,
        strategy=strategy,
        random_seed=random_seed,
        user_config_vent=user_config_vent,
        assigned_vent_log=None,        # We'll do the logging here instead
        infiltration_key=infiltration_key,
        year_key=map_age_range_to_year_key(age_range_str),
        is_residential=is_res,
        default_flow_exponent=0.67
    )

    # 5) Unpack the chosen building-level picks
    infiltration_base   = assigned_vent["infiltration_base"]
    infiltration_rng    = assigned_vent["infiltration_base_range"]
    year_factor         = assigned_vent["year_factor"]
    year_factor_rng     = assigned_vent["year_factor_range"]
    fan_pressure        = assigned_vent["fan_pressure"]
    fan_pressure_rng    = assigned_vent["fan_pressure_range"]
    f_ctrl              = assigned_vent["f_ctrl"]
    f_ctrl_rng          = assigned_vent["f_ctrl_range"]
    hrv_eff             = assigned_vent["hrv_eff"]
    hrv_eff_rng         = assigned_vent["hrv_eff_range"]

    infiltration_sched  = assigned_vent["infiltration_schedule_name"]
    ventilation_sched   = assigned_vent["ventilation_schedule_name"]
    system_type         = assigned_vent["system_type"]
    flow_exponent       = assigned_vent["flow_exponent"]

    # 6) Print or debug
    print(
        f"[VENT OVERRIDES] bldg={bldg_id}, infiltration_base={infiltration_base}, "
        f"year_factor={year_factor}, sys={system_type}, f_ctrl={f_ctrl}, "
        f"fanP={fan_pressure}, hrv_eff={hrv_eff}, infiltration_sched={infiltration_sched}, "
        f"vent_sched={ventilation_sched}"
    )

    # 7) Calculate total infiltration & ventilation flows for the building
    infiltration_m3_s_total = calc_infiltration(
        infiltration_base=infiltration_base,
        year_factor=year_factor,
        flow_exponent=flow_exponent,
        floor_area_m2=floor_area_m2
    )

    ### new correction

    # 7a) Adjust infiltration based on exposed walls (NTA 8800 lumps infiltration on external walls only)
    num_facades = 0
    for side_col in ["north_side","east_side","south_side","west_side"]:
        side_val = building_row.get(side_col, "shared")
        if side_val == "facade":
            num_facades += 1

    # More conservative exposure fraction calculation
    # If all walls are shared (num_facades = 0), use 0.3 as minimum
    # If all walls are facade (num_facades = 4), use 1.0
    # Linear interpolation between these points
    exposure_fraction = 0.3 + (num_facades * 0.175)  # 0.3 + (num_facades * (1.0-0.3)/4)
    infiltration_m3_s_total *= exposure_fraction

    # 7b) Adjust for roof type
    roof_type_str = building_row.get("b3_dak_type", "").lower()
    if "horizontal" in roof_type_str:
        roof_factor = 1.0  # Flat roof
    elif "slanted" in roof_type_str:
        roof_factor = 1.15  # Slanted roof has more infiltration potential
    elif "multiple horizontal" in roof_type_str:
        roof_factor = 1.1  # Multiple horizontal sections have slightly more infiltration potential
    else:
        # Default to flat roof if unknown
        roof_factor = 1.0
        print(f"[VENT WARNING] Unknown roof type '{roof_type_str}', defaulting to flat roof factor")

    infiltration_m3_s_total *= roof_factor
















    vent_flow_m3_s_total = calc_required_ventilation_flow(
        building_function=bldg_func,
        f_ctrl_val=f_ctrl,
        floor_area_m2=floor_area_m2,
        usage_key=usage_key
    )

    # 7b) Retrieve zones
    zones = idf.idfobjects["ZONE"]
    if not zones:
        print("[VENT] No zones found, skipping creation of infiltration/ventilation objects.")
        return

    n_zones = len(zones)
    infiltration_per_zone = infiltration_m3_s_total / n_zones
    vent_per_zone = vent_flow_m3_s_total / n_zones

    # 8) If we want to store building-level data in assigned_vent_log
    if assigned_vent_log is not None:
        if bldg_id not in assigned_vent_log:
            assigned_vent_log[bldg_id] = {}

        assigned_vent_log[bldg_id]["building_params"] = {
            # Numeric picks + ranges
            "infiltration_base": infiltration_base,
            "infiltration_base_range": infiltration_rng,
            "year_factor": year_factor,
            "year_factor_range": year_factor_rng,
            "fan_pressure": fan_pressure,
            "fan_pressure_range": fan_pressure_rng,
            "f_ctrl": f_ctrl,
            "f_ctrl_range": f_ctrl_rng,
            "hrv_eff": hrv_eff,
            "hrv_eff_range": hrv_eff_rng,
            # Schedules
            "infiltration_schedule_name": infiltration_sched,
            "ventilation_schedule_name": ventilation_sched,
            "system_type": system_type,
            "flow_exponent": flow_exponent,
            # Flows for entire building
            "infiltration_total_m3_s": infiltration_m3_s_total,
            "ventilation_total_m3_s": vent_flow_m3_s_total
        }

        # We'll create a sub-dict for zone-level data
        assigned_vent_log[bldg_id]["zones"] = {}

    print(
        f"[VENTILATION] Building {bldg_id}, system={system_type}, infiltration={infiltration_m3_s_total:.3f} m3/s, "
        f"vent={vent_flow_m3_s_total:.3f} m3/s, #zones={n_zones}"
    )

    # 9) For each zone => create infiltration + ventilation objects
    for zone_obj in zones:
        zone_name = zone_obj.Name

        iobj, vobj = create_ventilation_system(
            idf=idf,
            building_function=bldg_func,
            system_type=system_type,
            zone_name=zone_name,
            infiltration_m3_s=infiltration_per_zone,
            vent_flow_m3_s=vent_per_zone,
            infiltration_sched_name=infiltration_sched,
            ventilation_sched_name=ventilation_sched,
            pick_strategy="random" if strategy == "B" else "midpoint"
        )

        print(
            f"   => Created infiltration for {zone_name}: {infiltration_per_zone:.4f} m3/s, "
            f"ventilation: {vent_per_zone:.4f} m3/s"
        )

        # 9b) Log zone-level data
        if assigned_vent_log is not None:
            assigned_vent_log[bldg_id]["zones"][zone_name] = {
                "infiltration_object_name": iobj.Name,
                "infiltration_object_type": iobj.key,
                "infiltration_flow_m3_s": infiltration_per_zone,
                "infiltration_schedule_name": infiltration_sched,
                # If system_type != "D", we have vobj => ZONEVENTILATION:DESIGNFLOWRATE
                # If system_type == "D", vobj might be the same as iobj or None
                #   Actually in create_ventilation_system, iobj is infiltration, vobj is either
                #   a ZONEVENTILATION:DESIGNFLOWRATE or an IdealLoads object (for system D).
                "ventilation_object_name": vobj.Name if vobj else None,
                "ventilation_object_type": vobj.key if vobj else None,
                "ventilation_flow_m3_s": vent_per_zone if vobj else 0.0,
                "ventilation_schedule_name": ventilation_sched
            }

    # 10) If system_type == "D", optionally confirm HRV on IdealLoads
    # (The create_ventilation_system already sets sensible HRV if the IDD field exists).
    if system_type == "D" and hrv_eff > 0.0:
        for zone_obj in zones:
            zone_name = zone_obj.Name
            ideal_name = f"{zone_name} Ideal Loads"
            ideal_obj = idf.getobject("ZONEHVAC:IDEALLOADSAIRSYSTEM", ideal_name)
            if not ideal_obj:
                print(f"[VENT WARNING] {zone_name}: Ideal Loads not found for system D, can't set HRV.")
            else:
                if hasattr(ideal_obj, "Sensible_Heat_Recovery_Effectiveness"):
                    # It's presumably set in create_ventilation_system, but you could confirm or adjust:
                    print(f"      -> {zone_name} IdealLoads has HRV = {hrv_eff:.2f}")
                else:
                    print(f"      -> {zone_name} IdealLoads object lacks HRV fields in IDD.")

  --- File Contents End ---

  File: assign_ventilation_values.py
  --- File Contents Start ---
# ventilation/assign_ventilation_values.py

import random
from .ventilation_lookup import ventilation_lookup

def find_vent_overrides(
    building_id,
    building_function,
    age_range,
    scenario,
    calibration_stage,
    user_config
):
    """
    Return a list of user_config rows that match all provided criteria:
      - building_id
      - building_function
      - age_range
      - scenario
      - calibration_stage
    """
    matches = []
    if user_config:
        for row in user_config:
            # building_id match if present
            if "building_id" in row and row["building_id"] != building_id:
                continue
            # building_function match if present
            if "building_function" in row and row["building_function"] != building_function:
                continue
            # age_range match if present
            if "age_range" in row and row["age_range"] != age_range:
                continue
            # scenario match if present
            if "scenario" in row and row["scenario"] != scenario:
                continue
            # calibration_stage match if present
            if "calibration_stage" in row and row["calibration_stage"] != calibration_stage:
                continue
            matches.append(row)
    return matches


def pick_val_with_range(
    rng_tuple,
    strategy="A",
    log_dict=None,
    param_name=None
):
    """
    rng_tuple = (min_val, max_val) or None.
    strategy  = "A"=>midpoint, "B"=>random, "C"=>pick min, etc.
    log_dict  => optional dictionary for storing final picks.
    param_name=> e.g. "infiltration_base", "fan_pressure", etc.

    Returns the chosen numeric value.
    Also logs (param_name + param_name_range) if log_dict is provided.
    """
    if rng_tuple is None:
        return 0.0  # fallback => 0

    min_v, max_v = rng_tuple

    # pick final
    if strategy == "A":
        chosen = (min_v + max_v) / 2.0
    elif strategy == "B":
        chosen = random.uniform(min_v, max_v)
    elif strategy == "C":
        chosen = min_v  # pick min
    else:
        chosen = min_v  # default => pick min

    if log_dict is not None and param_name:
        # store the numeric range
        log_dict[f"{param_name}_range"] = (min_v, max_v)
        # store the final
        log_dict[param_name] = chosen

    return chosen


def assign_ventilation_params_with_overrides(
    building_id=None,
    building_function="residential",
    age_range="2015 and later",
    scenario="scenario1",
    calibration_stage="pre_calibration",
    strategy="A",         # "A" => midpoint, "B" => random, "C" => min, etc.
    random_seed=None,
    user_config_vent=None,     # possibly a list of override rows
    assigned_vent_log=None,    # dictionary to store final picks if desired
    infiltration_key=None,     # e.g. "Corner House" or "Office Function"
    year_key=None,             # e.g. "1975 - 1991"
    is_residential=True,
    default_flow_exponent=0.67
):
    """
    Returns a dict containing:
        {
          "infiltration_base": float,
          "infiltration_base_range": (min, max),
          "year_factor": float,
          "year_factor_range": (min, max),
          "system_type": str,
          "fan_pressure": float,
          "fan_pressure_range": (min, max),
          "f_ctrl": float,
          "f_ctrl_range": (min, max),
          "hrv_eff": float,
          "hrv_eff_range": (min, max),
          "infiltration_schedule_name": str,
          "ventilation_schedule_name": str,
          "flow_exponent": default_flow_exponent
        }

    Steps:
      1) Look up default ranges from ventilation_lookup (scenario, calibration_stage).
      2) Merge user overrides => modifies these ranges or sets fixed values.
      3) Use 'strategy' to pick final numeric values from each range.
      4) Return the final assigned dictionary, which includes both final picks & range info.
      5) Optionally log them to assigned_vent_log if provided.

    The infiltration_key for a residential building might be "Corner House", etc.
    For non-residential, infiltration_key might be "Office Function", etc.
    """
    if random_seed is not None:
        random.seed(random_seed)

    # 1) Ensure scenario & calibration_stage exist in ventilation_lookup
    if scenario not in ventilation_lookup:
        scenario = "scenario1"
    if calibration_stage not in ventilation_lookup[scenario]:
        calibration_stage = "pre_calibration"

    stage_dict = ventilation_lookup[scenario][calibration_stage]

    # Prepare a local dictionary for logging (if assigned_vent_log is used).
    log_dict = None
    if assigned_vent_log is not None:
        if building_id not in assigned_vent_log:
            assigned_vent_log[building_id] = {}
        log_dict = assigned_vent_log[building_id]

    # 2) Default infiltration_base range from infiltration_key
    if is_residential:
        res_infil = stage_dict["residential_infiltration_range"]
        infiltration_base_rng = res_infil.get(infiltration_key, (1.0, 1.0))  # fallback
        sys_ctrl_ranges = stage_dict["system_control_range_res"]
    else:
        nonres_infil = stage_dict["non_res_infiltration_range"]
        infiltration_base_rng = nonres_infil.get(infiltration_key, (0.5, 0.5))  # fallback
        sys_ctrl_ranges = stage_dict["system_control_range_nonres"]

    # 3) year_factor range
    year_factor_rng = stage_dict["year_factor_range"].get(year_key, (1.0, 1.0))

    # 4) Determine system_type from the system_type_map if available
    #    Otherwise fallback to "A" for residential, "D" for non-res.
    default_system_type = "A" if is_residential else "D"
    system_type_final = default_system_type

    if "system_type_map" in stage_dict:
        stm = stage_dict["system_type_map"]
        func_key = "residential" if is_residential else "non_residential"
        if func_key in stm:
            func_map = stm[func_key]
            if year_key in func_map:
                subtype_map = func_map[year_key]
                # pick system if infiltration_key is in subtype_map
                if infiltration_key in subtype_map:
                    system_type_final = subtype_map[infiltration_key]

    # 5) fan_pressure => we might pull from stage_dict["fan_pressure_range"] if needed
    #    but typically that is a single dictionary with subkeys like "res_mech", "nonres_intake", etc.
    #    We'll set a default (0.0,0.0) and let user overrides do the rest if needed.
    fan_pressure_rng = (0.0, 0.0)
    if "fan_pressure_range" in stage_dict:
        # For example, we might choose "res_mech" for residential, "nonres_intake"/"nonres_exhaust" for non-res.
        # But you can do more advanced logic if desired. We'll keep it 0 unless user overrides it.
        pass

    # 6) f_ctrl => pick from system_control_range (depending on system_type_final)
    if system_type_final in sys_ctrl_ranges:
        f_ctrl_rng = sys_ctrl_ranges[system_type_final].get("f_ctrl_range", (1.0, 1.0))
    else:
        f_ctrl_rng = (1.0, 1.0)

    # 7) HRV => only relevant if system_type=="D"
    hrv_eff_rng = (0.0, 0.0)
    if "hrv_sensible_eff_range" in stage_dict:
        hrv_eff_rng = stage_dict["hrv_sensible_eff_range"]

    # 8) apply user overrides
    matches = find_vent_overrides(
        building_id or 0,
        building_function or "residential",
        age_range or "2015 and later",
        scenario or "scenario1",
        calibration_stage,
        user_config_vent
    )

    def override_range(current_range, row):
        """
        If row has 'fixed_value', convert it to (val, val).
        If row has 'min_val' and 'max_val', return that tuple.
        Otherwise return current_range.
        """
        if "fixed_value" in row:
            val = row["fixed_value"]
            try:
                f = float(val)
                return (f, f)
            except (ValueError, TypeError):
                return current_range
        elif "min_val" in row and "max_val" in row:
            return (row["min_val"], row["max_val"])
        return current_range

    infiltration_sched_name = "AlwaysOnSched"
    ventilation_sched_name = "VentSched_DayNight"

    for row in matches:
        pname = row.get("param_name", "")
        if pname == "infiltration_base":
            infiltration_base_rng = override_range(infiltration_base_rng, row)

        elif pname == "year_factor":
            year_factor_rng = override_range(year_factor_rng, row)

        elif pname == "system_type":
            # If user sets a fixed_value => override system_type_final
            if "fixed_value" in row:
                system_type_final = row["fixed_value"]

        elif pname == "fan_pressure":
            fan_pressure_rng = override_range(fan_pressure_rng, row)

        elif pname == "f_ctrl":
            f_ctrl_rng = override_range(f_ctrl_rng, row)

        elif pname == "hrv_eff":
            hrv_eff_rng = override_range(hrv_eff_rng, row)

        elif pname == "infiltration_schedule_name":
            if "fixed_value" in row:
                infiltration_sched_name = row["fixed_value"]

        elif pname == "ventilation_schedule_name":
            if "fixed_value" in row:
                ventilation_sched_name = row["fixed_value"]

    # 9) pick final infiltration_base, year_factor, fan_pressure, f_ctrl, hrv_eff
    local_log = {}
    infiltration_base_val = pick_val_with_range(infiltration_base_rng, strategy, local_log, "infiltration_base")
    year_factor_val       = pick_val_with_range(year_factor_rng,       strategy, local_log, "year_factor")
    fan_pressure_val      = pick_val_with_range(fan_pressure_rng,      strategy, local_log, "fan_pressure")
    f_ctrl_val            = pick_val_with_range(f_ctrl_rng,            strategy, local_log, "f_ctrl")

    hrv_eff_val = 0.0
    if system_type_final == "D":
        hrv_eff_val = pick_val_with_range(hrv_eff_rng, strategy, local_log, "hrv_eff")
    else:
        local_log["hrv_eff_range"] = (0.0, 0.0)
        local_log["hrv_eff"] = 0.0

    # 10) infiltration/vent schedules => infiltration_sched_name, ventilation_sched_name
    local_log["infiltration_schedule_name"] = infiltration_sched_name
    local_log["ventilation_schedule_name"]  = ventilation_sched_name
    local_log["system_type"] = system_type_final

    # 11) Build final assigned dict
    assigned = {
        # infiltration_base
        "infiltration_base": local_log["infiltration_base"],
        "infiltration_base_range": local_log["infiltration_base_range"],

        # year_factor
        "year_factor": local_log["year_factor"],
        "year_factor_range": local_log["year_factor_range"],

        # fan_pressure
        "fan_pressure": local_log["fan_pressure"],
        "fan_pressure_range": local_log["fan_pressure_range"],

        # f_ctrl
        "f_ctrl": local_log["f_ctrl"],
        "f_ctrl_range": local_log["f_ctrl_range"],

        # hrv_eff
        "hrv_eff": local_log["hrv_eff"],
        "hrv_eff_range": local_log["hrv_eff_range"],

        # Schedules
        "infiltration_schedule_name": local_log["infiltration_schedule_name"],
        "ventilation_schedule_name": local_log["ventilation_schedule_name"],

        # System type
        "system_type": local_log["system_type"],

        # Flow exponent
        "flow_exponent": default_flow_exponent
    }

    # 12) If logging externally => store
    if log_dict is not None:
        log_dict["ventilation_params"] = assigned

    return assigned




    """
    Searches a user_config list/dict for any override entries matching the
    building_id, building_function, age_range, scenario, and calibration_stage.
    Returns a list of matching dict rows.

    Each 'row' in user_config can specify:
      - "building_id"
      - "building_function"
      - "age_range"
      - "scenario"
      - "calibration_stage"
      - plus override fields for infiltration_base, year_factor, system_type, fan_pressure, f_ctrl, hrv_eff, etc.

    If any of those fields are present in the row and do not match the
    current building, that row is skipped. Otherwise, the row is considered
    a match and is returned in the list.
    """

    """
    Return a dict with infiltration_base, year_factor, system_type, f_ctrl, fan_pressure,
    hrv_eff, infiltration_schedule_name, ventilation_schedule_name, etc.

    This function uses:
      1) The scenario & calibration_stage to locate a sub-dict in 'ventilation_lookup'
      2) The infiltration_key/year_key to get infiltration & year_factor ranges
      3) user_config_vent overrides to optionally override any of the above
      4) A picking strategy (A=midpoint, B=uniform random, C=lower bound) for final selection
      5) The building_function & usage_key to also fetch schedule_info from 'ventilation_lookup'
         => infiltration_schedule_name & ventilation_schedule_name

    Then logs final picks into assigned_vent_log if provided (dict-based log).
    """


  --- File Contents End ---

  File: calc_functions.py
  --- File Contents Start ---
# ventilation/calc_functions.py

import math

def calc_infiltration(
    infiltration_base,  # e.g. assigned["infiltration_base"] from assign_ventilation_values
    year_factor,        # assigned["year_factor"] from overrides
    flow_exponent,      # typically 0.67 (standard infiltration exponent)
    floor_area_m2       # total building area
):
    """
    Calculate infiltration in m3/s based on an 'infiltration_base' at 10 Pa.

    Steps:
      1) Multiply infiltration_base by year_factor => qv10_lea_ref (represents
         infiltration at 10 Pa for the building, e.g. in dm3/sÂ·m2 or similar).
      2) Convert qv10 => qv1 by applying exponent:
            qv1 = qv10 * (1/10)^n
         (n = flow_exponent, e.g. 0.67 per NTA 8800).
      3) Multiply qv1_lea_ref_per_m2_h by total floor area => infiltration_m3/h.
      4) Convert infiltration_m3/h => infiltration_m3/s by dividing by 3600.

    NTA 8800 basis:
      - Table 11.2 prescribes n=0.67 for leak losses (infiltration).
      - Section 11.2.5 references how infiltration is often reported at 10 Pa
        and needs converting to 1 Pa. This code parallels that approach.

    Returns infiltration in m3/s.
    """

    # 1) infiltration_base * year_factor => infiltration at 10 Pa
    qv10_lea_ref = infiltration_base * year_factor

    # 2) Convert from qv10 to qv1 by (1/10)^exponent
    qv1_lea_ref_per_m2_h = qv10_lea_ref * (1.0 / 10.0)**flow_exponent

    # 3) Multiply by floor area => infiltration in m3/h
    infiltration_m3_h = qv1_lea_ref_per_m2_h * floor_area_m2

    # 4) Convert from m3/h => m3/s
    infiltration_m3_s = infiltration_m3_h / 3600.0
    return infiltration_m3_s


def calc_required_ventilation_flow(
    building_function,
    f_ctrl_val,
    floor_area_m2,
    usage_key=None
):
    """
    Calculate the required ventilation flow (m3/s).

    Approach:
      - If residential: 0.9 dm3/s/m2 is used as base, then multiplied by
        control factor (f_ctrl_val). A minimum of ~126 m3/h is enforced.
        => 126 m3/h = 35 L/s, typical minimal design flow for dwellings.

      - If non-residential: usage_key (office_area_based, childcare, retail, etc.)
        references typical design flows (dm3/s/m2). Then multiplied by f_ctrl_val.

    NTA 8800 basis:
      - In Section 11.2.2.5 or Table 11.8, typical air supply rates are given
        for various functions. This code uses simplified example values.

    Returns flow in m3/s.
    """

    if building_function == "residential":
        # base usage flow in dm3/s
        qv_uspec = 0.9
        # multiply by floor area => dm3/s
        qv_oda_req_des_dm3_s = qv_uspec * floor_area_m2
        # convert to m3/h
        qv_oda_req_des_m3_h = qv_oda_req_des_dm3_s * 3.6

        # apply control factor
        qv_oda_req_m3_h = f_ctrl_val * qv_oda_req_des_m3_h

        # enforce minimum ~126 m3/h
        if qv_oda_req_m3_h < 126:
            qv_oda_req_m3_h = 126

        # return m3/s
        return qv_oda_req_m3_h / 3600.0

    else:
        # non-res => usage_key references typical design rates
        usage_flow_map = {
            "office_area_based": 1.0,  # dm3/s per m2
            "childcare": 4.8,
            "retail": 0.6
        }
        qv_usage = usage_flow_map.get(usage_key, 1.0)  # fallback 1.0 dm3/s/m2
        qv_oda_req_des_dm3_s = qv_usage * floor_area_m2
        qv_oda_req_des_m3_h  = qv_oda_req_des_dm3_s * 3.6

        # apply control factor
        qv_oda_req_m3_h = f_ctrl_val * qv_oda_req_des_m3_h
        return qv_oda_req_m3_h / 3600.0


def calc_fan_power(fan_pressure, fan_efficiency, flow_m3_s):
    """
    Compute fan power in W:
      P_fan = (fan_pressure * flow_m3_s) / fan_efficiency

    NTA 8800 doesn't provide a direct formula for fan power in W in exactly
    these terms, but this approach is standard fluid power:
       Pressure (Pa) * Volumetric Flow (m3/s) = Power in J/s (Watts),
       then / efficiency to account for fan energy losses.

    fan_pressure: Pa
    flow_m3_s: m3/s
    fan_efficiency: fraction (0.0 < eff <= 1.0)
    returns: fan power in Watts
    """
    if fan_efficiency <= 0:
        fan_efficiency = 0.7
    return (fan_pressure * flow_m3_s) / fan_efficiency

  --- File Contents End ---

  File: config_systems.py
  --- File Contents Start ---
# ventilation/config_systems.py

"""
Defines a dictionary SYSTEMS_CONFIG with separate entries for:
  - building_function: "residential" vs. "non_residential"
  - system_type:       "A", "B", "C", or "D"

Each system entry has:
  1) "description"                => short text label
  2) "ventilation_object_type"    => e.g. 'ZONEVENTILATION:DESIGNFLOWRATE'
  3) "ventilation_type_options"   => a list of possible Ventilation_Type strings
  4) "range_params"               => dictionary of numeric fields that are stored as (min, max) ranges
  5) "use_ideal_loads"            => boolean (True if system D uses IdealLoads, etc.)

Later, in your `create_ventilation_systems.py`, you can pick or compute final single values:
  - either pick a random or midpoint from "Fan_Pressure_Rise" range
  - or pick one of the "ventilation_type_options", etc.
"""

SYSTEMS_CONFIG = {
    "residential": {
        # -----------------------------------------------------------
        # System A
        # -----------------------------------------------------------
        "A": {
            "description": "Natural supply + Natural exhaust",
            "ventilation_object_type": "ZONEVENTILATION:DESIGNFLOWRATE",
            "ventilation_type_options": [
                "Natural"  # Could allow more, e.g. "Intake", "Exhaust" if you want
            ],
            "range_params": {
                # If you want a zero fan pressure for natural, but let's keep an example range
                "Fan_Pressure_Rise": (0.0, 0.0),
                "Fan_Total_Efficiency": (0.6, 0.8)
            },
            "use_ideal_loads": False
        },

        # -----------------------------------------------------------
        # System B
        # -----------------------------------------------------------
        "B": {
            "description": "Mechanical supply + Natural infiltration",
            "ventilation_object_type": "ZONEVENTILATION:DESIGNFLOWRATE",
            "ventilation_type_options": [
                "Intake"
            ],
            "range_params": {
                "Fan_Pressure_Rise": (40.0, 60.0),
                "Fan_Total_Efficiency": (0.65, 0.75)
            },
            "use_ideal_loads": False
        },

        # -----------------------------------------------------------
        # System C
        # -----------------------------------------------------------
        "C": {
            "description": "Natural supply + Mechanical exhaust",
            "ventilation_object_type": "ZONEVENTILATION:DESIGNFLOWRATE",
            "ventilation_type_options": [
                "Exhaust"
            ],
            "range_params": {
                "Fan_Pressure_Rise": (40.0, 60.0),
                "Fan_Total_Efficiency": (0.65, 0.75)
            },
            "use_ideal_loads": False
        },

        # -----------------------------------------------------------
        # System D
        # -----------------------------------------------------------
        "D": {
            "description": "Balanced mechanical (supply + exhaust), with HRV",
            "ventilation_object_type": "ZONEHVAC:IDEALLOADSAIRSYSTEM",
            "ventilation_type_options": [
                "Balanced"
            ],
            "range_params": {
                "Fan_Pressure_Rise": (50.0, 80.0),
                "Fan_Total_Efficiency": (0.7, 0.85),
                # Example for HRV fields if you want them here:
                "Sensible_Heat_Recovery_Effectiveness": (0.70, 0.80),
                "Latent_Heat_Recovery_Effectiveness": (0.0, 0.0)
            },
            "use_ideal_loads": True
        }
    },

    "non_residential": {
        # -----------------------------------------------------------
        # System A
        # -----------------------------------------------------------
        "A": {
            "description": "Natural supply + Natural exhaust",
            "ventilation_object_type": "ZONEVENTILATION:DESIGNFLOWRATE",
            "ventilation_type_options": [
                "Natural"
            ],
            "range_params": {
                "Fan_Pressure_Rise": (0.0, 0.0),
                "Fan_Total_Efficiency": (0.5, 0.6)
            },
            "use_ideal_loads": False
        },

        # -----------------------------------------------------------
        # System B
        # -----------------------------------------------------------
        "B": {
            "description": "Mechanical supply + Natural exhaust",
            "ventilation_object_type": "ZONEVENTILATION:DESIGNFLOWRATE",
            "ventilation_type_options": [
                "Intake"
            ],
            "range_params": {
                "Fan_Pressure_Rise": (90.0, 110.0),
                "Fan_Total_Efficiency": (0.65, 0.75)
            },
            "use_ideal_loads": False
        },

        # -----------------------------------------------------------
        # System C
        # -----------------------------------------------------------
        "C": {
            "description": "Natural supply + Mechanical exhaust",
            "ventilation_object_type": "ZONEVENTILATION:DESIGNFLOWRATE",
            "ventilation_type_options": [
                "Exhaust"
            ],
            "range_params": {
                "Fan_Pressure_Rise": (140.0, 160.0),
                "Fan_Total_Efficiency": (0.70, 0.80)
            },
            "use_ideal_loads": False
        },

        # -----------------------------------------------------------
        # System D
        # -----------------------------------------------------------
        "D": {
            "description": "Balanced mechanical supply & exhaust (with optional HRV)",
            "ventilation_object_type": "ZONEHVAC:IDEALLOADSAIRSYSTEM",
            "ventilation_type_options": [
                "Balanced"
            ],
            "range_params": {
                "Fan_Pressure_Rise": (100.0, 120.0),
                "Fan_Total_Efficiency": (0.65, 0.80),
                "Sensible_Heat_Recovery_Effectiveness": (0.75, 0.85),
                "Latent_Heat_Recovery_Effectiveness": (0.0, 0.0)
            },
            "use_ideal_loads": True
        }
    }
}

  --- File Contents End ---

  File: create_ventilation_systems.py
  --- File Contents Start ---
# ventilation/create_ventilation_systems.py

import random
from idf_objects.ventilation.config_systems import SYSTEMS_CONFIG

def create_ventilation_system(
    idf,
    building_function,      # 'residential' or 'non_residential'
    system_type,            # 'A', 'B', 'C', or 'D'
    zone_name,
    infiltration_m3_s,
    vent_flow_m3_s,
    infiltration_sched_name="AlwaysOnSched",
    ventilation_sched_name="VentSched_DayNight",
    pick_strategy="midpoint"  # or "random"
):
    """
    Creates two objects for the zone:
      1) A ZONEINFILTRATION:DESIGNFLOWRATE object (always).
      2) Depending on system_type:
         - A/B/C => a ZONEVENTILATION:DESIGNFLOWRATE object
         - D     => modifies an existing ZONEHVAC:IDEALLOADSAIRSYSTEM
                    (already added by add_HVAC_Ideal_to_all_zones, if used)

    Returns (infiltration_obj, vent_obj_or_ideal_obj).
    """

    # -------------------------------------------------------
    # 1) Grab the config for this system
    # -------------------------------------------------------
    if building_function not in SYSTEMS_CONFIG:
        building_function = "residential"
    if system_type not in SYSTEMS_CONFIG[building_function]:
        system_type = "A"

    config = SYSTEMS_CONFIG[building_function][system_type]

    # -------------------------------------------------------
    # 2) Helper to pick a single value from a (min, max) range
    # -------------------------------------------------------
    def pick_val(rng):
        """
        rng is (min_val, max_val).
        pick_strategy == 'midpoint' => return average
        pick_strategy == 'random'   => return random.uniform(...)
        """
        if pick_strategy == "random":
            return random.uniform(rng[0], rng[1])
        else:
            # default => midpoint
            return (rng[0] + rng[1]) / 2.0

    # -------------------------------------------------------
    # 3) Create infiltration object (ZONEINFILTRATION:DESIGNFLOWRATE)
    # -------------------------------------------------------
    iobj = idf.newidfobject("ZONEINFILTRATION:DESIGNFLOWRATE")
    iobj.Name = f"Infil_{building_function}_{system_type}_{zone_name}"

    # Some E+ versions use .Zone_or_ZoneList_or_Space_or_SpaceList_Name
    # others use .Zone_or_ZoneList_Name
    if hasattr(iobj, "Zone_or_ZoneList_or_Space_or_SpaceList_Name"):
        iobj.Zone_or_ZoneList_or_Space_or_SpaceList_Name = zone_name
    else:
        iobj.Zone_or_ZoneList_Name = zone_name

    # Assign infiltration schedule and flow
    iobj.Schedule_Name = infiltration_sched_name
    iobj.Design_Flow_Rate_Calculation_Method = "Flow/Zone"
    iobj.Design_Flow_Rate = infiltration_m3_s

    # -------------------------------------------------------
    # 4) Prepare final param values from config["range_params"]
    #    e.g. fan pressure, heat recovery, etc.
    # -------------------------------------------------------
    chosen_params = {}
    range_dict = config.get("range_params", {})
    for param_name, rng in range_dict.items():
        chosen_val = pick_val(rng)
        chosen_params[param_name] = chosen_val

    # Choose from the ventilation_type_options if present
    ventilation_type_list = config.get("ventilation_type_options", [])
    if ventilation_type_list:
        chosen_vent_type = random.choice(ventilation_type_list)
    else:
        chosen_vent_type = "Natural"  # fallback if none provided

    # -------------------------------------------------------
    # 5) If system D => update an existing IdealLoads object
    #    else => create a ZONEVENTILATION:DESIGNFLOWRATE
    # -------------------------------------------------------
    if config["use_ideal_loads"]:
        # System D => Balanced mechanical => find the existing IdealLoads object
        ideal_name = f"{zone_name} Ideal Loads"
        ideal_obj = idf.getobject("ZONEHVAC:IDEALLOADSAIRSYSTEM", ideal_name)

        if ideal_obj:
            # Example: set fields in the IdealLoads that exist in chosen_params
            # e.g. if param_name == "Sensible_Heat_Recovery_Effectiveness"
            for param_field, final_val in chosen_params.items():
                # We must confirm the IDD field name matches param_field
                if hasattr(ideal_obj, param_field):
                    setattr(ideal_obj, param_field, final_val)

            # If desired, you could limit the air flow to 'vent_flow_m3_s' here:
            #   ideal_obj.Heating_Limit = "LimitFlowRate"
            #   ideal_obj.Maximum_Heating_Air_Flow_Rate = vent_flow_m3_s
            #   ideal_obj.Cooling_Limit = "LimitFlowRate"
            #   ideal_obj.Maximum_Cooling_Air_Flow_Rate = vent_flow_m3_s

            return iobj, ideal_obj
        else:
            print(f"[VENT WARNING] {zone_name} Ideal Loads not found; system D creation skipped.")
            return iobj, None

    else:
        # Systems A, B, C => create a ZONEVENTILATION:DESIGNFLOWRATE
        vobj = idf.newidfobject(config["ventilation_object_type"])
        vobj.Name = f"Vent_{building_function}_{system_type}_{zone_name}"
        if hasattr(vobj, "Zone_or_ZoneList_or_Space_or_SpaceList_Name"):
            vobj.Zone_or_ZoneList_or_Space_or_SpaceList_Name = zone_name
        else:
            vobj.Zone_or_ZoneList_Name = zone_name

        # Assign the chosen (or default) ventilation schedule and flow
        vobj.Schedule_Name = ventilation_sched_name
        vobj.Design_Flow_Rate_Calculation_Method = "Flow/Zone"
        vobj.Design_Flow_Rate = vent_flow_m3_s

        # Insert system-specific fields if they exist in the object
        if hasattr(vobj, "Ventilation_Type"):
            vobj.Ventilation_Type = chosen_vent_type

        if hasattr(vobj, "Fan_Pressure_Rise") and "Fan_Pressure_Rise" in chosen_params:
            vobj.Fan_Pressure_Rise = chosen_params["Fan_Pressure_Rise"]

        if hasattr(vobj, "Fan_Total_Efficiency") and "Fan_Total_Efficiency" in chosen_params:
            vobj.Fan_Total_Efficiency = chosen_params["Fan_Total_Efficiency"]

        return iobj, vobj

  --- File Contents End ---

  File: mappings.py
  --- File Contents Start ---
# ventilation/mappings.py

def safe_lower(val):
    """Helper to safely lowercase a string."""
    if isinstance(val, str):
        return val.lower()
    return ""

def map_age_range_to_year_key(age_range_str):
    """
    Converts a building_row's age_range into one of the 7 keys used in 
    ventilation_lookup (e.g. "< 1945", "1945 - 1964", etc.).

    If the input doesn't match exactly, we fallback to "2015 and later".
    """
    valid_keys = {
        "< 1945": "< 1945",
        "1945 - 1964": "1945 - 1964",
        "1965 - 1974": "1965 - 1974",
        "1975 - 1991": "1975 - 1991",
        "1992 - 2005": "1992 - 2005",
        "2006 - 2014": "2006 - 2014",
        "2015 and later": "2015 and later"
    }
    return valid_keys.get(age_range_str, "2015 and later")

def map_infiltration_key(building_row):
    """
    Returns a string key that matches the infiltration range in your
    ventilation_lookup. We no longer rely on any perimeter logic.

    - If building_function == "residential", we use the "residential_type" field
      (e.g. "Corner House", "Apartment", etc.). If not found, fallback "other_res".

    - If building_function == "non_residential", we use the "non_residential_type"
      (e.g. "Office Function", "Meeting Function", etc.). If not found, fallback "other_nonres".
    """
    bldg_func = safe_lower(building_row.get("building_function", "residential"))
    if bldg_func == "residential":
        # Exact sub-type, e.g. "Corner House"
        res_type = building_row.get("residential_type", "other_res")
        # Match exactly what's in the lookup keys:
        valid_res_types = {
            "Corner House", 
            "Apartment", 
            "Terrace or Semi-detached House", 
            "Detached House", 
            "Two-and-a-half-story House"
        }
        if res_type not in valid_res_types:
            return "other_res"
        return res_type
    else:
        # Non-res
        nonres_type = building_row.get("non_residential_type", "other_nonres")
        valid_nonres_types = {
            "Meeting Function",
            "Healthcare Function",
            "Sport Function",
            "Cell Function",
            "Retail Function",
            "Industrial Function",
            "Accommodation Function",
            "Office Function",
            "Education Function",
            "Other Use Function"
        }
        if nonres_type not in valid_nonres_types:
            return "other_nonres"
        return nonres_type

def map_usage_key(building_row):
    """
    For calculating required ventilation flows in non-res buildings.
    If the building is residential => return None.
    Otherwise, return a usage_key that is recognized by calc_required_ventilation_flow.

    Here, you can customize how each non_residential_type maps to a usage flow.
    """
    bldg_func = safe_lower(building_row.get("building_function", "residential"))
    if bldg_func == "residential":
        return None
    else:
        # Example usage mapping:
        usage_map = {
            "Meeting Function": "office_area_based",
            "Healthcare Function": "office_area_based",
            "Sport Function": "office_area_based",
            "Cell Function": "office_area_based",
            "Retail Function": "retail",
            "Industrial Function": "retail",
            "Accommodation Function": "office_area_based",
            "Office Function": "office_area_based",
            "Education Function": "office_area_based",
            "Other Use Function": "retail"
        }
        nonres_type = building_row.get("non_residential_type", "Other Use Function")
        return usage_map.get(nonres_type, "retail")

# We no longer need a 'map_ventilation_system' function, because system A/B/C/D
# is now determined by the system_type_map in ventilation_lookup. 
# That logic is handled in assign_ventilation_params_with_overrides (or a helper).

  --- File Contents End ---

  File: schedules.py
  --- File Contents Start ---
# ventilation/schedules.py

from geomeppy import IDF

def create_always_on_schedule(idf, sched_name="AlwaysOnSched"):
    """
    Creates a SCHEDULE:CONSTANT with a Fraction = 1.0
    for infiltration or ventilation that runs 24/7.
    """
    # Check if already exists
    existing = idf.getobject("SCHEDULE:CONSTANT", sched_name.upper())
    if existing:
        return existing  # No need to recreate

    schedule = idf.newidfobject("SCHEDULE:CONSTANT")
    schedule.Name = sched_name
    schedule.Schedule_Type_Limits_Name = "Fraction"
    schedule.Hourly_Value = 1.0
    return schedule


def create_day_night_schedule(idf, sched_name="VentSched_DayNight"):
    """
    Day/Night schedule that is 0.5 at night, 1.0 during day.
    Example: 06:00-22:00 => 1.0, else => 0.5
    """
    # Check if already exists
    existing = idf.getobject("SCHEDULE:COMPACT", sched_name.upper())
    if existing:
        return existing

    schedule = idf.newidfobject("SCHEDULE:COMPACT")
    schedule.Name = sched_name
    schedule.Schedule_Type_Limits_Name = "Fraction"

    schedule.Field_1 = "Through: 12/31"
    schedule.Field_2 = "For: AllDays"
    schedule.Field_3 = "Until: 06:00,0.5"
    schedule.Field_4 = "Until: 22:00,1.0"
    schedule.Field_5 = "Until: 24:00,0.5"
    return schedule


def create_workhours_schedule(idf, sched_name="WorkHoursSched"):
    """
    Workhours schedule: 
      - 0.2 fraction from midnight to 09:00,
      - 1.0 from 09:00 to 17:00,
      - 0.2 from 17:00 to midnight,
      - weekends/holidays => 0.2 all day
    """
    # Check if already exists
    existing = idf.getobject("SCHEDULE:COMPACT", sched_name.upper())
    if existing:
        return existing

    schedule = idf.newidfobject("SCHEDULE:COMPACT")
    schedule.Name = sched_name
    schedule.Schedule_Type_Limits_Name = "Fraction"

    schedule.Field_1 = "Through: 12/31"
    schedule.Field_2 = "For: Weekdays"
    schedule.Field_3 = "Until: 09:00,0.2"
    schedule.Field_4 = "Until: 17:00,1.0"
    schedule.Field_5 = "Until: 24:00,0.2"
    schedule.Field_6 = "For: Saturday Sunday Holiday"
    schedule.Field_7 = "Until: 24:00,0.2"
    return schedule


# ------------------------------------------------------------------------
# NEW HELPER FUNCTIONS FOR DYNAMIC SCHEDULES
# ------------------------------------------------------------------------

def create_schedule_from_pattern(idf, sched_name, pattern, schedule_type_limits="Fraction"):
    """
    Creates a SCHEDULE:COMPACT in the IDF from a single pattern of
    (start_hour, end_hour, fraction_value) tuples for ALL days.

    :param idf: geomeppy IDF instance
    :param sched_name: name of the schedule in E+
    :param pattern: list of (start_hour, end_hour, value), e.g. [(0,6,0.5), (6,22,1.0), (22,24,0.5)]
    :param schedule_type_limits: e.g. "Fraction" or "OnOff"
    :returns: the new or existing SCHEDULE:COMPACT object
    """
    # Check if schedule already exists
    existing = idf.getobject("SCHEDULE:COMPACT", sched_name.upper())
    if existing:
        return existing

    sched_obj = idf.newidfobject("SCHEDULE:COMPACT")
    sched_obj.Name = sched_name
    sched_obj.Schedule_Type_Limits_Name = schedule_type_limits

    # We'll define just one set of rules "Through: 12/31", "For: AllDays"
    # If you want to differentiate weekdays vs. weekends in the same schedule,
    # see create_schedule_from_weekday_weekend_pattern() below.
    field_idx = 1
    sched_obj[f"Field_{field_idx}"] = "Through: 12/31"
    field_idx += 1

    sched_obj[f"Field_{field_idx}"] = "For: AllDays"
    field_idx += 1

    # Now loop over the pattern, building lines like "Until: HH:MM, fraction"
    for (start_hr, end_hr, val) in pattern:
        # E+ SCHEDULE:COMPACT lines are sequential. We just say "Until: end_hr"
        # The fraction applies from previous end_hr to new end_hr.
        # For the first chunk, it starts at midnight implicitly.
        # e.g. "Until: 06:00,0.5"
        line_str = f"Until: {end_hr:02d}:00,{val}"
        sched_obj[f"Field_{field_idx}"] = line_str
        field_idx += 1

    return sched_obj


def create_schedule_from_weekday_weekend_pattern(idf, sched_name, weekday_pattern, weekend_pattern, 
                                                 schedule_type_limits="Fraction"):
    """
    Creates a SCHEDULE:COMPACT with two sets of rules:
    - One for Weekdays
    - One for Saturday Sunday Holiday

    :param idf: geomeppy IDF instance
    :param sched_name: name of the schedule in E+
    :param weekday_pattern: list of (start_hr, end_hr, fraction) for M-F
    :param weekend_pattern: list of (start_hr, end_hr, fraction) for Sat/Sun/Holiday
    :param schedule_type_limits: e.g. "Fraction"
    :returns: new or existing SCHEDULE:COMPACT
    """
    existing = idf.getobject("SCHEDULE:COMPACT", sched_name.upper())
    if existing:
        return existing

    sched_obj = idf.newidfobject("SCHEDULE:COMPACT")
    sched_obj.Name = sched_name
    sched_obj.Schedule_Type_Limits_Name = schedule_type_limits

    # First chunk: Through: 12/31, For: Weekdays
    field_idx = 1
    sched_obj[f"Field_{field_idx}"] = "Through: 12/31"
    field_idx += 1

    sched_obj[f"Field_{field_idx}"] = "For: Weekdays"
    field_idx += 1

    for (start_hr, end_hr, val) in weekday_pattern:
        line_str = f"Until: {end_hr:02d}:00,{val}"
        sched_obj[f"Field_{field_idx}"] = line_str
        field_idx += 1

    # Next chunk: For Saturday Sunday Holiday
    sched_obj[f"Field_{field_idx}"] = "For: Saturday Sunday Holiday"
    field_idx += 1

    for (start_hr, end_hr, val) in weekend_pattern:
        line_str = f"Until: {end_hr:02d}:00,{val}"
        sched_obj[f"Field_{field_idx}"] = line_str
        field_idx += 1

    return sched_obj


def ensure_dynamic_schedule(idf, sched_name, weekday_pattern=None, weekend_pattern=None):
    """
    A convenience function that:
     - if only weekday_pattern is provided, creates schedule from that pattern for all days;
     - if both weekday & weekend patterns provided, creates a weekday/weekend schedule.

    :param idf: geomeppy IDF
    :param sched_name: string
    :param weekday_pattern: list of (start_hr, end_hr, fraction)
    :param weekend_pattern: list of (start_hr, end_hr, fraction)
    :return: the schedule object
    """
    existing = idf.getobject("SCHEDULE:COMPACT", sched_name.upper())
    if existing:
        return existing

    if weekday_pattern and not weekend_pattern:
        # same pattern for all days
        return create_schedule_from_pattern(idf, sched_name, weekday_pattern)

    elif weekday_pattern and weekend_pattern:
        return create_schedule_from_weekday_weekend_pattern(idf, sched_name, weekday_pattern, weekend_pattern)

    else:
        # fallback => always on
        return create_always_on_schedule(idf, sched_name)

  --- File Contents End ---

  File: ventilation_lookup.py
  --- File Contents Start ---
# ventilation_lookup.py

"""
This file defines a large nested dictionary called `ventilation_lookup`
that organizes infiltration/ventilation parameters AND the chosen system type
by:
  1) scenario ("scenario1" or "scenario2")
  2) calibration stage ("pre_calibration" or "post_calibration")

Within each stage, we have:
  - residential_infiltration_range
  - non_res_infiltration_range
  - year_factor_range
  - system_control_range_res
  - system_control_range_nonres
  - fan_pressure_range (optional)
  - hrv_sensible_eff_range
  - system_type_map (dictating system A/B/C/D)
"""

ventilation_lookup = {
    # -------------------------------------------------------------------------
    # SCENARIO 1
    # -------------------------------------------------------------------------
    "scenario1": {
        # =====================================================================
        # A) PRE-CALIBRATION
        # =====================================================================
        "pre_calibration": {
            # -----------------------------------------------------------
            # 1) Infiltration ranges (for Residential subâtypes)
            # -----------------------------------------------------------
            "residential_infiltration_range": {
                "Corner House": (1.2, 1.4),
                "Apartment": (0.8, 1.0),
                "Terrace or Semi-detached House": (1.0, 1.2),
                "Detached House": (1.2, 1.5),
                "Two-and-a-half-story House": (1.1, 1.3),
                "other_res": (1.0, 1.2)
            },

            # -----------------------------------------------------------
            # 2) Infiltration ranges (for Non-Residential subâtypes)
            # -----------------------------------------------------------
            "non_res_infiltration_range": {
                "Meeting Function": (0.5, 0.7),
                "Healthcare Function": (0.6, 0.8),
                "Sport Function": (0.4, 0.6),
                "Cell Function": (0.5, 0.7),
                "Retail Function": (0.6, 0.8),
                "Industrial Function": (0.6, 0.9),
                "Accommodation Function": (0.5, 0.7),
                "Office Function": (0.6, 0.8),
                "Education Function": (0.6, 0.8),
                "Other Use Function": (0.5, 0.7),
                "other_nonres": (0.5, 0.7)
            },

            # -----------------------------------------------------------
            # 3) Year-of-construction factor ranges (7 age bands)
            # -----------------------------------------------------------
            "year_factor_range": {
                "< 1945": (2.0, 2.3),
                "1945 - 1964": (1.8, 2.0),
                "1965 - 1974": (1.5, 1.7),
                "1975 - 1991": (1.3, 1.5),
                "1992 - 2005": (1.1, 1.3),
                "2006 - 2014": (0.9, 1.1),
                "2015 and later": (0.7, 0.9)
            },

            # -----------------------------------------------------------
            # 4) System control factors (f_ctrl range) for each system
            # -----------------------------------------------------------
            "system_control_range_res": {
                "A": {"f_ctrl_range": (0.90, 1.00)},
                "B": {"f_ctrl_range": (0.50, 0.60)},
                "C": {"f_ctrl_range": (0.80, 0.90)},
                "D": {"f_ctrl_range": (0.95, 1.05)}
            },
            "system_control_range_nonres": {
                "A": {"f_ctrl_range": (0.90, 1.00)},
                "B": {"f_ctrl_range": (0.80, 0.90)},
                "C": {"f_ctrl_range": (0.60, 0.70)},
                "D": {"f_ctrl_range": (0.75, 0.85)}
            },

            # -----------------------------------------------------------
            # 5) Optional fan pressure ranges (if used)
            # -----------------------------------------------------------
            "fan_pressure_range": {
                "res_mech": (40, 60),
                "nonres_intake": (90, 110),
                "nonres_exhaust": (140, 160)
            },

            # -----------------------------------------------------------
            # 6) HRV sensible efficiency
            # -----------------------------------------------------------
            "hrv_sensible_eff_range": (0.70, 0.80),

            # -----------------------------------------------------------
            # 7) system_type_map - new table picking A/B/C/D
            # -----------------------------------------------------------
            "system_type_map": {
                "residential": {
                    "< 1945": {
                        "Corner House": "A",
                        "Apartment": "C",
                        "Terrace or Semi-detached House": "B",
                        "Detached House": "C",
                        "Two-and-a-half-story House": "A"
                    },
                    "1945 - 1964": {
                        "Corner House": "B",
                        "Apartment": "A",
                        "Terrace or Semi-detached House": "C",
                        "Detached House": "D",
                        "Two-and-a-half-story House": "C"
                    },
                    "1965 - 1974": {
                        "Corner House": "A",
                        "Apartment": "B",
                        "Terrace or Semi-detached House": "C",
                        "Detached House": "D",
                        "Two-and-a-half-story House": "C"
                    },
                    "1975 - 1991": {
                        "Corner House": "C",
                        "Apartment": "C",
                        "Terrace or Semi-detached House": "B",
                        "Detached House": "C",
                        "Two-and-a-half-story House": "A"
                    },
                    "1992 - 2005": {
                        "Corner House": "B",
                        "Apartment": "A",
                        "Terrace or Semi-detached House": "C",
                        "Detached House": "D",
                        "Two-and-a-half-story House": "D"
                    },
                    "2006 - 2014": {
                        "Corner House": "D",
                        "Apartment": "D",
                        "Terrace or Semi-detached House": "C",
                        "Detached House": "C",
                        "Two-and-a-half-story House": "A"
                    },
                    "2015 and later": {
                        "Corner House": "D",
                        "Apartment": "C",
                        "Terrace or Semi-detached House": "A",
                        "Detached House": "B",
                        "Two-and-a-half-story House": "D"
                    }
                },
                "non_residential": {
                    "< 1945": {
                        "Meeting Function": "A",
                        "Healthcare Function": "D",
                        "Sport Function": "C",
                        "Cell Function": "C",
                        "Retail Function": "B",
                        "Industrial Function": "B",
                        "Accommodation Function": "A",
                        "Office Function": "C",
                        "Education Function": "A",
                        "Other Use Function": "B"
                    },
                    "1945 - 1964": {
                        "Meeting Function": "C",
                        "Healthcare Function": "D",
                        "Sport Function": "B",
                        "Cell Function": "C",
                        "Retail Function": "B",
                        "Industrial Function": "A",
                        "Accommodation Function": "D",
                        "Office Function": "D",
                        "Education Function": "B",
                        "Other Use Function": "A"
                    },
                    "1965 - 1974": {
                        "Meeting Function": "B",
                        "Healthcare Function": "C",
                        "Sport Function": "B",
                        "Cell Function": "C",
                        "Retail Function": "C",
                        "Industrial Function": "C",
                        "Accommodation Function": "B",
                        "Office Function": "B",
                        "Education Function": "D",
                        "Other Use Function": "A"
                    },
                    "1975 - 1991": {
                        "Meeting Function": "C",
                        "Healthcare Function": "D",
                        "Sport Function": "B",
                        "Cell Function": "C",
                        "Retail Function": "B",
                        "Industrial Function": "A",
                        "Accommodation Function": "D",
                        "Office Function": "D",
                        "Education Function": "B",
                        "Other Use Function": "A"
                    },
                    "1992 - 2005": {
                        "Meeting Function": "A",
                        "Healthcare Function": "D",
                        "Sport Function": "C",
                        "Cell Function": "C",
                        "Retail Function": "B",
                        "Industrial Function": "B",
                        "Accommodation Function": "A",
                        "Office Function": "C",
                        "Education Function": "A",
                        "Other Use Function": "B"
                    },
                    "2006 - 2014": {
                        "Meeting Function": "C",
                        "Healthcare Function": "D",
                        "Sport Function": "B",
                        "Cell Function": "C",
                        "Retail Function": "B",
                        "Industrial Function": "A",
                        "Accommodation Function": "D",
                        "Office Function": "D",
                        "Education Function": "B",
                        "Other Use Function": "A"
                    },
                    "2015 and later": {
                        "Meeting Function": "A",
                        "Healthcare Function": "D",
                        "Sport Function": "C",
                        "Cell Function": "C",
                        "Retail Function": "B",
                        "Industrial Function": "B",
                        "Accommodation Function": "A",
                        "Office Function": "C",
                        "Education Function": "A",
                        "Other Use Function": "B"
                    }
                }
            }
        },  # end pre_calibration

        # =====================================================================
        # B) POST-CALIBRATION
        # =====================================================================
        "post_calibration": {
              ...
              ...
              ...
              ...
              ...
                    }
                }
            }
        }
    }
}

  --- File Contents End ---

  File: ventilation_overrides_from_excel.py
  --- File Contents Start ---
# ventilation/ventilation_overrides_from_excel.py

import pandas as pd
import copy
import math

def read_ventilation_overrides_from_excel(excel_path):
    """
    Reads an Excel file with columns:
        - calibration_stage
        - main_key
        - sub_key
        - param_name
        - min_val
        - max_val
        - fixed_value

    Returns a nested dict: override_data[stage][main_key][sub_key][param_name] = ...
    
    Where the "..." can be:
      - a tuple (min, max) if numeric
      - a single string or numeric if 'fixed_value' is provided and is non-NaN
        (we store it as (val, val) if numeric, or keep as a plain string if textual).
    
    This can override infiltration ranges, year_factor ranges, OR new schedule info.
    For schedule overrides, 'main_key' might be "schedule_info",
    sub_key might be e.g. "residential", param_name might be "default_infiltration_schedule",
    and fixed_value could be e.g. "InfilResSched".

    Example row:
        calibration_stage = "pre_calibration"
        main_key          = "schedule_info"
        sub_key           = "residential"
        param_name        = "default_infiltration_schedule"
        min_val           = NaN
        max_val           = NaN
        fixed_value       = "MyInfilResSched"

    The resulting override_data will have:
        override_data["pre_calibration"]["schedule_info"]["residential"]["default_infiltration_schedule"] = "MyInfilResSched"
    """
    df = pd.read_excel(excel_path)

    required_cols = ["calibration_stage","main_key","sub_key","param_name","min_val","max_val","fixed_value"]
    for c in required_cols:
        if c not in df.columns:
            raise ValueError(f"Missing column '{c}' in {excel_path}")

    override_data = {}

    for _, row in df.iterrows():
        stage = str(row["calibration_stage"]).strip()
        mkey  = str(row["main_key"]).strip()       # e.g. "residential_infiltration_range" or "schedule_info"
        skey  = str(row["sub_key"]).strip()        # e.g. "A_corner" or "residential" or ""
        pname = str(row["param_name"]).strip()     # e.g. "f_ctrl_range", "default_infiltration_schedule", or ""

        fv = row["fixed_value"]  # could be numeric or string
        mn = row["min_val"]      # typically numeric or NaN
        mx = row["max_val"]      # typically numeric or NaN

        if stage not in override_data:
            override_data[stage] = {}
        if mkey not in override_data[stage]:
            override_data[stage][mkey] = {}

        # Decide how to store
        # 1) If fixed_value is not NaN => store that
        #    - If it's purely numeric, we store as (fv,fv) for consistency with min,max range
        #    - If it's a string, we'll store it as a plain string override
        # 2) Else if min_val and max_val are numeric => store as (min_val,max_val)
        # 3) Otherwise skip if all are NaN

        # Helper to test if something is numeric
        def is_number(x):
            try:
                float(x)
                return True
            except (ValueError, TypeError):
                return False

        if pd.notna(fv):
            # If the fixed_value is numeric => store as a numeric tuple (fv,fv)
            if is_number(fv):
                val_tuple = (float(fv), float(fv))
                final_value = val_tuple
            else:
                # It's likely a string => store it directly as that string
                final_value = str(fv).strip()
        elif pd.notna(mn) and pd.notna(mx) and is_number(mn) and is_number(mx):
            val_tuple = (float(mn), float(mx))
            final_value = val_tuple
        else:
            # skip if no valid data
            continue

        # Insert into override_data
        # Cases:
        #    (a) skey == "" and pname == "" => override_data[stage][mkey] = final_value
        #    (b) skey != "" and pname == "" => override_data[stage][mkey][skey] = final_value
        #    (c) skey + pname => override_data[stage][mkey][skey][pname] = final_value
        if skey == "" and pname == "":
            override_data[stage][mkey] = final_value
        elif skey != "" and pname == "":
            if not isinstance(override_data[stage][mkey], dict):
                override_data[stage][mkey] = {}
            override_data[stage][mkey][skey] = final_value
        else:
            # if we have a param_name => store in stage[mkey][skey][pname]
            if skey not in override_data[stage][mkey] or not isinstance(override_data[stage][mkey][skey], dict):
                override_data[stage][mkey][skey] = {}
            override_data[stage][mkey][skey][pname] = final_value

    return override_data


def apply_ventilation_overrides_to_lookup(default_lookup, override_data):
    """
    Merges override_data into default_lookup (similar to ventilation_lookup).
    
    override_data structure:
      override_data[stage][main_key][sub_key][param_name] = final_value
        (final_value can be a tuple (min,max), or a string for schedules)

    For each stage in override_data:
      - If stage doesn't exist in default_lookup, we create it.
      - For each main_key in override_data => if it's a tuple or string, override
        directly. If it's a dict => merge deeper.
    
    Example usage:
      new_lookup = apply_ventilation_overrides_to_lookup(ventilation_lookup, override_data)
    """
    # If you prefer not to mutate default_lookup in place, do a copy
    new_lookup = copy.deepcopy(default_lookup)

    for stage, stage_dict in override_data.items():
        if stage not in new_lookup:
            new_lookup[stage] = {}

        for mkey, val_mkey in stage_dict.items():
            # val_mkey might be:
            #   - a numeric tuple or string => direct override
            #   - a dict => deeper merges (subkeys, param_names)

            if not isinstance(val_mkey, dict):
                # So if it's a tuple or a string => direct override
                new_lookup[stage][mkey] = val_mkey
                continue

            # if it's a dict => we merge it
            if mkey not in new_lookup[stage]:
                new_lookup[stage][mkey] = {}

            for subk, subv in val_mkey.items():
                # subv might be a tuple, string, or another dict
                if not isinstance(subv, dict):
                    # direct override
                    new_lookup[stage][mkey][subk] = subv
                else:
                    # deeper dict => e.g. {param_name: (min,max) or string}
                    if subk not in new_lookup[stage][mkey]:
                        new_lookup[stage][mkey][subk] = {}
                    for param_key, param_val in subv.items():
                        # param_val could be tuple or string
                        new_lookup[stage][mkey][subk][param_key] = param_val

    return new_lookup

  --- File Contents End ---

================================================================================

Folder: D:\Documents\E_Plus_2030_py\idf_objects\ventilation\__pycache__

================================================================================

