Folder: D:\Documents\E_Plus_2030_py/fenez

  File: assign_fenestration_values.py
  --- File Contents Start ---
# fenez/assign_fenestration_values.py

from .materials_config import get_extended_materials_data, compute_wwr

def assign_fenestration_parameters(
    building_row,
    scenario="scenario1",
    calibration_stage="pre_calibration",
    strategy="A",
    random_seed=None,
    user_config_fenez=None,
    assigned_fenez_log=None,
    use_computed_wwr=False,
    include_doors_in_wwr=False
):
    bldg_func = building_row.get("building_function", "residential")
    if bldg_func.lower() == "residential":
        building_type = building_row.get("residential_type", "UnknownHouseType")
    else:
        building_type = building_row.get("non_residential_type", "UnknownNonResType")

    age_range = building_row.get("age_range", "2015 and later")
    building_id = building_row.get("ogc_fid", None)

    # Retrieve extended data
    data = get_extended_materials_data(
        building_function=bldg_func,
        building_type=building_type,
        age_range=age_range,
        scenario=scenario,
        calibration_stage=calibration_stage,
        strategy=strategy,
        random_seed=random_seed,
        user_config_fenez=user_config_fenez
    )

    if not use_computed_wwr:
        final_wwr = data["wwr"]
    else:
        elements_dict = data.get("elements", {})
        final_wwr = compute_wwr(elements_dict, include_doors=include_doors_in_wwr)

    # Store in assigned_fenez_log as a single float, no range
    if assigned_fenez_log is not None and building_id is not None:
        if building_id not in assigned_fenez_log:
            assigned_fenez_log[building_id] = {}
        assigned_fenez_log[building_id]["fenez_wwr"] = final_wwr

    return final_wwr

  --- File Contents End ---

  File: data_materials_non_residential.py
  --- File Contents Start ---
# fenez/data_materials_non_residential.py

"""
We define a dictionary for non_residential_materials_data
keyed by (non_residential_type, age_range, scenario, calibration_stage).

Each entry can have:
 - older fields like "roughness", "wwr_range"
 - overall references: "material_opaque_lookup", "material_window_lookup"
 - plus per-element sub-dicts for 'ground_floor', 'walls', 'windows', 'doors', etc.
"""

non_residential_materials_data = {
    # Example: Meeting Function, 2015 and later, scenario1, pre_calibration
    ("Meeting Function", "2015 and later", "scenario1", "pre_calibration"): {
        "roughness": "MediumRough",
        "wwr_range": (0.3, 0.35),
        "material_opaque_lookup": "Concrete_200mm",
        "material_window_lookup": "Glazing_Clear_3mm",

        # Also define sub-elements if you want
        "ground_floor": {
            "area_m2": 120.0,
            "R_value_range": (2.5, 3.0),
            "U_value_range": (0.33, 0.4),
            "material_opaque_lookup": "InsulationBoard_R2"
        },
        "exterior_wall": {
            "area_m2": 300.0,
            "R_value_range": (2.0, 2.5),
            "U_value_range": (0.40, 0.50),
            "material_opaque_lookup": "Concrete_200mm"
        },
        "flat_roof": {
            "area_m2": 200.0,
            "R_value_range": (3.0, 3.5),
            "U_value_range": (0.28, 0.33),
            "material_opaque_lookup": "Concrete_200mm"
        },
        "windows": {
            "area_m2": 80.0,
            "U_value_range": (2.2, 2.4),
            "material_window_lookup": "Glazing_Clear_3mm"
        },
        "doors": {
            "area_m2": 10.0,
            "U_value_range": (3.0, 3.2),
            "material_opaque_lookup": "DoorPanel_Range"
        }
    },

    # Another example: Meeting Function, 2015 and later, scenario1, post_calibration
    ("Meeting Function", "2015 and later", "scenario1", "post_calibration"): {
        "roughness": "Smooth",
        "wwr_range": (0.32, 0.32),
        "material_opaque_lookup": "Concrete_200mm",
        "material_window_lookup": "Glazing_Clear_3mm_Post",

        "ground_floor": {
            "area_m2": 120.0,
            "R_value_range": (3.0, 3.0),
            "U_value_range": (0.33, 0.33),
            "material_opaque_lookup": "InsulationBoard_R2"
        },
        "exterior_wall": {
            "area_m2": 300.0,
            "R_value_range": (2.3, 2.3),
            "U_value_range": (0.36, 0.36),
            "material_opaque_lookup": "Concrete_200mm"
        },
        "flat_roof": {
            "area_m2": 200.0,
            "R_value_range": (3.0, 3.0),
            "U_value_range": (0.3, 0.3),
            "material_opaque_lookup": "Concrete_200mm"
        },
        "windows": {
            "area_m2": 80.0,
            "U_value_range": (2.1, 2.1),
            "material_window_lookup": "Glazing_Clear_3mm_Post"
        },
        "doors": {
            "area_m2": 10.0,
            "U_value_range": (3.0, 3.0),
            "material_opaque_lookup": "DoorPanel_Range"
        }
    },

    # add more combos for other non_res types, ages, scenarios, stages
}

  --- File Contents End ---

  File: data_materials_residential.py
  --- File Contents Start ---
# fenez/data_materials_residential.py

residential_materials_data = {
    # Example: Two-and-a-half-story House, <1965, scenario1, pre_calibration
    ("Two-and-a-half-story House", "<1965", "scenario1", "pre_calibration"): {
        "roughness": "MediumRough",
        "wwr_range": (0.2, 0.3),

        # older style top-level references
        "material_opaque_lookup": "Concrete_200mm",
        "material_window_lookup": "Glazing_Clear_3mm_Post",

        # new sub-elements
        "ground_floor": {
            "area_m2": 68.95,
            "R_value_range": (2.5, 2.5),
            "U_value_range": (0.36, 0.36),
            "material_opaque_lookup": "InsulationBoard_R2"
        },
        "solid_wall": {
            "area_m2": 103.3,
            "R_value_range": (2.5, 2.5),
            "U_value_range": (0.37, 0.37),
            "material_opaque_lookup": "Concrete_200mm"
        },
        "sloping_flat_roof": {
            "area_m2": 84.14,
            "R_value_range": (2.5, 2.5),
            "U_value_range": (0.37, 0.37),
            "material_opaque_lookup": "Concrete_200mm"
        },
        "windows": {
            "area_m2": 27.22,
            "U_value_range": (2.9, 2.9),
            "material_window_lookup": "Glazing_Clear_3mm"
        },
        "doors": {
            "area_m2": 6.93,
            "U_value_range": (3.4, 3.4),
            "material_opaque_lookup": "DoorPanel_Range"
        }
    },

    # Another example for scenario2 or different age range
    ("Two-and-a-half-story House", "<1965", "scenario1", "post_calibration"): {
        "roughness": "Smooth",
        "wwr_range": (0.25, 0.25),

        "material_opaque_lookup": "Concrete_200mm",
        "material_window_lookup": "Glazing_Clear_3mm_Post",

        "ground_floor": {
            "area_m2": 70.0,
            "R_value_range": (3.0, 3.0),
            "U_value_range": (0.33, 0.33),
            "material_opaque_lookup": "InsulationBoard_R2"
        },
        "solid_wall": {
            "area_m2": 105.0,
            "R_value_range": (3.0, 3.0),
            "U_value_range": (0.33, 0.33),
            "material_opaque_lookup": "Concrete_200mm"
        },
        "sloping_flat_roof": {
            "area_m2": 82.0,
            "R_value_range": (3.0, 3.0),
            "U_value_range": (0.33, 0.33),
            "material_opaque_lookup": "Concrete_200mm"
        },
        "windows": {
            "area_m2": 25.0,
            "U_value_range": (2.7, 3.0),
            "material_window_lookup": "Glazing_Clear_3mm"
        },
        "doors": {
            "area_m2": 7.0,
            "U_value_range": (3.2, 3.4),
            "material_opaque_lookup": "DoorPanel_Range"
        }
    },

    # more combos...
}

  --- File Contents End ---

  File: dict_override_excel.py
  --- File Contents Start ---
# fenez/dict_override_excel.py

import pandas as pd
import copy
import math

def override_dictionaries_from_excel(
    excel_path,
    default_res_data,
    default_nonres_data,
    default_roughness="MediumRough",
    fallback_wwr_range=(0.2, 0.3)
):
    """
    Reads an Excel file containing envelope data (including min_wwr, max_wwr, 
    calibration_stage, etc.) and uses it to override or extend the default 
    dictionaries for residential and non_residential materials.

    Parameters
    ----------
    excel_path : str
        Path to the Excel file, e.g. 'D:\\Documents\\E_Plus_2027_py\\envelop.xlsx'
    default_res_data : dict
        The original residential_materials_data dictionary
    default_nonres_data : dict
        The original non_residential_materials_data dictionary
    default_roughness : str
        Fallback roughness if none is provided in the Excel
    fallback_wwr_range : tuple
        Fallback WWR range (min, max) if Excel does not specify

    Returns
    -------
    new_res_data : dict
        Updated residential data dictionary
    new_nonres_data : dict
        Updated non-residential data dictionary

    Notes
    -----
    - The Excel must contain certain columns:
        building_function, building_type, year_range, scenario, calibration_stage,
        element, area_m2, R_value_min, R_value_max, U_value_min, U_value_max,
        roughness, material_opaque_lookup, material_window_lookup, min_wwr, max_wwr
    - Rows with building_function='residential' will override entries in 
      residential_materials_data; rows with 'non_residential' override non_res.
    - You can add or remove elements (like 'doors', 'windows', 'walls', etc.) 
      by specifying the 'element' column.
    """

    # Make deep copies so we don't mutate the originals
    new_res_data = copy.deepcopy(default_res_data)
    new_nonres_data = copy.deepcopy(default_nonres_data)

    # Load Excel
    df = pd.read_excel(excel_path)

    # Ensure expected columns exist
    required_cols = [
        "building_function",
        "building_type",
        "year_range",
        "scenario",
        "calibration_stage",
        "element",
        "area_m2",
        "R_value_min",
        "R_value_max",
        "U_value_min",
        "U_value_max",
        "roughness",
        "material_opaque_lookup",
        "material_window_lookup",
        "min_wwr",
        "max_wwr"
    ]
    missing_cols = [c for c in required_cols if c not in df.columns]
    if missing_cols:
        raise ValueError(f"Excel file is missing required columns: {missing_cols}")

    # Go row by row and override
    for _, row in df.iterrows():
        bfunc = str(row["building_function"]).strip().lower()  # 'residential' or 'non_residential'
        btype = str(row["building_type"]).strip()
        yrange = str(row["year_range"]).strip()
        scen   = str(row["scenario"]).strip()
        stage  = str(row["calibration_stage"]).strip()

        # Decide which dictionary to modify
        if bfunc == "residential":
            current_dict = new_res_data
        else:
            current_dict = new_nonres_data

        dict_key = (btype, yrange, scen, stage)

        # Create or fetch the entry
        if dict_key not in current_dict:
            current_dict[dict_key] = {
                "roughness": default_roughness,
                "wwr_range": fallback_wwr_range
            }
        data_entry = current_dict[dict_key]

        # Possibly override the top-level roughness
        rough_val = str(row["roughness"]).strip()
        if rough_val.lower() != "nan":
            data_entry["roughness"] = rough_val

        # Possibly override the top-level wwr_range if we have min_wwr & max_wwr
        if not pd.isna(row["min_wwr"]) and not pd.isna(row["max_wwr"]):
            min_wwr = float(row["min_wwr"])
            max_wwr = float(row["max_wwr"])
            data_entry["wwr_range"] = (min_wwr, max_wwr)

        # Now handle the sub-element (doors, ground_floor, windows, etc.)
        elem_name = str(row["element"]).strip()
        if elem_name not in data_entry:
            data_entry[elem_name] = {}

        elem_dict = data_entry[elem_name]

        # area
        if not pd.isna(row["area_m2"]):
            elem_dict["area_m2"] = float(row["area_m2"])

        # R_value_range
        rmin = row["R_value_min"]
        rmax = row["R_value_max"]
        if not pd.isna(rmin) and not pd.isna(rmax):
            elem_dict["R_value_range"] = (float(rmin), float(rmax))

        # U_value_range
        umin = row["U_value_min"]
        umax = row["U_value_max"]
        if not pd.isna(umin) and not pd.isna(umax):
            elem_dict["U_value_range"] = (float(umin), float(umax))

        # Overwrite or store roughness for that element if you want (optional):
        elem_dict["roughness"] = data_entry["roughness"]

        # material_opaque_lookup
        opq_lookup = row["material_opaque_lookup"]
        if pd.notna(opq_lookup):
            elem_dict["material_opaque_lookup"] = str(opq_lookup).strip()

        # material_window_lookup
        win_lookup = row["material_window_lookup"]
        if pd.notna(win_lookup):
            elem_dict["material_window_lookup"] = str(win_lookup).strip()

    return new_res_data, new_nonres_data

  --- File Contents End ---

  File: fenestration.py
  --- File Contents Start ---
# fenez/fenestration.py

def add_fenestration(
    idf,
    building_row,
    scenario="scenario1",
    calibration_stage="pre_calibration",
    strategy="A",
    random_seed=None,
    user_config_fenez=None,
    assigned_fenez_log=None,
    use_computed_wwr=False,
    include_doors_in_wwr=False
):
    """
    1) Retrieve the final WWR using assign_fenestration_parameters(...).
    2) Remove existing FENESTRATIONSURFACE:DETAILED from the IDF.
    3) Use geomeppy's IDF.set_wwr(...) to add new window surfaces
       referencing a known "Window1C" construction (created by your materials.py).
    """

    from geomeppy import IDF as GeppyIDF
    from .assign_fenestration_values import assign_fenestration_parameters

    # 1) Compute or retrieve final WWR
    wwr = assign_fenestration_parameters(
        building_row=building_row,
        scenario=scenario,
        calibration_stage=calibration_stage,
        strategy=strategy,
        random_seed=random_seed,
        user_config_fenez=user_config_fenez,    # <-- Pass in override config
        assigned_fenez_log=assigned_fenez_log,
        use_computed_wwr=use_computed_wwr,
        include_doors_in_wwr=include_doors_in_wwr
    )

    # 2) Remove any existing fenestration objects
    fenestrations = idf.idfobjects["FENESTRATIONSURFACE:DETAILED"]
    del fenestrations[:]  # Clear list

    # 3) Use geomeppy's set_wwr(...) to create new window surfaces
    #    We assume a "Window1C" construction is already defined in your materials
    GeppyIDF.set_wwr(idf, wwr=wwr, construction="Window1C")

    print(f"[add_fenestration] Building: {building_row.get('ogc_fid','?')} => WWR={wwr:.3f}, used Window1C")

  --- File Contents End ---

  File: materials.py
  --- File Contents Start ---
# fenez/materials.py

from geomeppy import IDF
from .materials_config import get_extended_materials_data

def _store_material_picks(assigned_fenez_log, building_id, label, mat_data):
    """
    A helper to store final material picks in assigned_fenez_log[building_id][label].
    Skips any keys that end with '_range'.
    E.g. label might be 'top_opq' or 'top_win' or 'element_floor', etc.
    """
    if not mat_data:
        return

    # Only store final picks (no ranges)
    filtered = {}
    for k, v in mat_data.items():
        if k.endswith("_range"):
            continue
        filtered[k] = v

    if building_id not in assigned_fenez_log:
        assigned_fenez_log[building_id] = {}

    # Example: store under assigned_fenez_log[1234]["fenez_top_opq"] = {...}
    assigned_fenez_log[building_id][f"fenez_{label}"] = filtered


def update_construction_materials(
    idf,
    building_row,
    scenario="scenario1",
    calibration_stage="pre_calibration",
    strategy="A",
    random_seed=None,
    user_config_fenez=None,
    assigned_fenez_log=None
):
    """
    1) Calls get_extended_materials_data(...) => returns a dict with final picks 
       (no longer just ranges).
    2) Removes all existing Materials & Constructions from the IDF (clean slate).
    3) Creates new Opaque & Window materials (if present), plus multiple named Constructions.
    4) Logs assigned final picks (no range) into assigned_fenez_log if provided.
    """

    # 1) Identify building function & type
    bldg_func = building_row.get("building_function", "residential")
    if bldg_func.lower() == "residential":
        bldg_type = building_row.get("residential_type", "")
    else:
        bldg_type = building_row.get("non_residential_type", "")

    age_range = building_row.get("age_range", "2015 and later")
    building_id = building_row.get("ogc_fid", None)  # or "pand_id" if that is the ID

    # 2) Retrieve extended materials data
    data = get_extended_materials_data(
        building_function=bldg_func,
        building_type=bldg_type,
        age_range=age_range,
        scenario=scenario,
        calibration_stage=calibration_stage,
        strategy=strategy,
        random_seed=random_seed,
        user_config_fenez=user_config_fenez
    )

    mat_opq = data.get("material_opaque", None)
    mat_win = data.get("material_window", None)

    # If logging final picks, store them now, skipping _range
    if assigned_fenez_log is not None and building_id is not None:
        # Store top-level opaque material
        _store_material_picks(
            assigned_fenez_log=assigned_fenez_log,
            building_id=building_id,
            label="top_opq",
            mat_data=mat_opq
        )
        # Store top-level window material
        _store_material_picks(
            assigned_fenez_log=assigned_fenez_log,
            building_id=building_id,
            label="top_win",
            mat_data=mat_win
        )

        # Also store final picks for sub-elements if you want them all in the CSV
        for elem_name, elem_data in data.get("elements", {}).items():
            # If there's a "material_opaque" or "material_window" inside an element
            opq_sub = elem_data.get("material_opaque", None)
            win_sub = elem_data.get("material_window", None)

            _store_material_picks(
                assigned_fenez_log=assigned_fenez_log,
                building_id=building_id,
                label=f"{elem_name}_opq",
                mat_data=opq_sub
            )
            _store_material_picks(
                assigned_fenez_log=assigned_fenez_log,
                building_id=building_id,
                label=f"{elem_name}_win",
                mat_data=win_sub
            )

            # Also store final numeric R_value or U_value, area, etc., if present
            # (We do it under the same dictionary in assigned_fenez_log)
            # For instance:
            if elem_data.get("R_value") is not None:
                assigned_fenez_log[building_id][f"fenez_{elem_name}_R_value"] = elem_data["R_value"]
            if elem_data.get("U_value") is not None:
                assigned_fenez_log[building_id][f"fenez_{elem_name}_U_value"] = elem_data["U_value"]
            if elem_data.get("area_m2") is not None:
                assigned_fenez_log[building_id][f"fenez_{elem_name}_area_m2"] = elem_data["area_m2"]

    # 3) Remove existing Materials & Constructions in the IDF
    for obj_type in [
        "MATERIAL",
        "MATERIAL:NOMASS",
        "WINDOWMATERIAL:GLAZING",
        "WINDOWMATERIAL:SIMPLEGLAZINGSYSTEM",
        "CONSTRUCTION"
    ]:
        for obj in idf.idfobjects[obj_type][:]:
            idf.removeidfobject(obj)

    # The rest is unchanged from your earlier code, creating new Material/Construction objects:

    opq_name = None
    win_name = None

    # Create Opaque Material
    if mat_opq:
        obj_type = mat_opq["obj_type"].upper()
        if obj_type == "MATERIAL":
            mat_obj = idf.newidfobject("MATERIAL")
            mat_obj.Name = mat_opq["Name"]
            mat_obj.Roughness = mat_opq["Roughness"]
            mat_obj.Thickness = mat_opq["Thickness"]
            mat_obj.Conductivity = mat_opq["Conductivity"]
            mat_obj.Density = mat_opq["Density"]
            mat_obj.Specific_Heat = mat_opq["Specific_Heat"]
            mat_obj.Thermal_Absorptance = mat_opq["Thermal_Absorptance"]
            mat_obj.Solar_Absorptance   = mat_opq["Solar_Absorptance"]
            mat_obj.Visible_Absorptance = mat_opq["Visible_Absorptance"]
            opq_name = mat_obj.Name

        elif obj_type == "MATERIAL:NOMASS":
            mat_obj = idf.newidfobject("MATERIAL:NOMASS")
            mat_obj.Name = mat_opq["Name"]
            mat_obj.Roughness = mat_opq["Roughness"]
            mat_obj.Thermal_Resistance = mat_opq["Thermal_Resistance"]
            mat_obj.Thermal_Absorptance = mat_opq["Thermal_Absorptance"]
            mat_obj.Solar_Absorptance   = mat_opq["Solar_Absorptance"]
            mat_obj.Visible_Absorptance = mat_opq["Visible_Absorptance"]
            opq_name = mat_obj.Name

    # Create Window Material
    if mat_win:
        wtype = mat_win["obj_type"].upper()
        if wtype == "WINDOWMATERIAL:GLAZING":
            wmat = idf.newidfobject("WINDOWMATERIAL:GLAZING")
            wmat.Name = mat_win["Name"]
            wmat.Optical_Data_Type = mat_win["Optical_Data_Type"]
            wmat.Thickness = mat_win["Thickness"]
            wmat.Solar_Transmittance_at_Normal_Incidence = mat_win["Solar_Transmittance"]
            wmat.Front_Side_Solar_Reflectance_at_Normal_Incidence = mat_win["Front_Solar_Reflectance"]
            wmat.Back_Side_Solar_Reflectance_at_Normal_Incidence  = mat_win["Back_Solar_Reflectance"]
            wmat.Visible_Transmittance_at_Normal_Incidence        = mat_win["Visible_Transmittance"]
            wmat.Front_Side_Visible_Reflectance_at_Normal_Incidence = mat_win["Front_Visible_Reflectance"]
            wmat.Back_Side_Visible_Reflectance_at_Normal_Incidence  = mat_win["Back_Visible_Reflectance"]
            wmat.Infrared_Transmittance_at_Normal_Incidence         = mat_win["IR_Transmittance"]
            wmat.Front_Side_Infrared_Hemispherical_Emissivity       = mat_win["Front_IR_Emissivity"]
            wmat.Back_Side_Infrared_Hemispherical_Emissivity        = mat_win["Back_IR_Emissivity"]
            wmat.Conductivity = mat_win["Conductivity"]
            wmat.Dirt_Correction_Factor_for_Solar_and_Visible_Transmittance = mat_win["Dirt_Correction_Factor"]
            wmat.Solar_Diffusing = mat_win["Solar_Diffusing"]
            win_name = wmat.Name

        elif wtype == "WINDOWMATERIAL:SIMPLEGLAZINGSYSTEM":
            wmat = idf.newidfobject("WINDOWMATERIAL:SIMPLEGLAZINGSYSTEM")
            wmat.Name = mat_win["Name"]
            # If you have UFactor/SHGC in mat_win, set them as well
            win_name = wmat.Name

    # Create Constructions
    if opq_name:
        # Exterior walls
        c_ext = idf.newidfobject("CONSTRUCTION")
        c_ext.Name = "Ext_Walls1C"
        c_ext.Outside_Layer = opq_name
        # ... similarly for interior walls, adiabatic walls, roof, ceiling, ground floor, etc.
        c_int = idf.newidfobject("CONSTRUCTION")
        c_int.Name = "Int_Walls1C"
        c_int.Outside_Layer = opq_name

        c_adiab = idf.newidfobject("CONSTRUCTION")
        c_adiab.Name = "Adiabatic_Walls1C"
        c_adiab.Outside_Layer = opq_name

        c_roof = idf.newidfobject("CONSTRUCTION")
        c_roof.Name = "Roof1C"
        c_roof.Outside_Layer = opq_name

        c_ceil = idf.newidfobject("CONSTRUCTION")
        c_ceil.Name = "Ceiling1C"
        c_ceil.Outside_Layer = opq_name

        c_grnd = idf.newidfobject("CONSTRUCTION")
        c_grnd.Name = "GroundFloor1C"
        c_grnd.Outside_Layer = opq_name

        c_ifloor = idf.newidfobject("CONSTRUCTION")
        c_ifloor.Name = "IntFloor1C"
        c_ifloor.Outside_Layer = opq_name

    if win_name:
        c_win = idf.newidfobject("CONSTRUCTION")
        c_win.Name = "Window1C"
        c_win.Outside_Layer = win_name

    print(f"[update_construction_materials] Created Opaque Material={opq_name}, "
          f"Window Material={win_name}")
    print("=> Constructions created: Ext_Walls1C, Int_Walls1C, Adiabatic_Walls1C, Roof1C, "
          "Ceiling1C, GroundFloor1C, IntFloor1C (if opq), and Window1C (if window).")


def assign_constructions_to_surfaces(idf):
    """
    Assign each BUILDINGSURFACE:DETAILED to a suitable construction name
    depending on Surface_Type and Outside_Boundary_Condition.
    """

    for surface in idf.idfobjects["BUILDINGSURFACE:DETAILED"]:
        s_type = surface.Surface_Type.upper()
        bc = surface.Outside_Boundary_Condition.upper()

        if s_type == "WALL":
            if bc == "OUTDOORS":
                surface.Construction_Name = "Ext_Walls1C"
            elif bc == "SURFACE":
                surface.Construction_Name = "Int_Walls1C"
            elif bc == "ADIABATIC":
                surface.Construction_Name = "Adiabatic_Walls1C"
            else:
                surface.Construction_Name = "Ext_Walls1C"

        elif s_type == "ROOF":
            surface.Construction_Name = "Roof1C"

        elif s_type == "CEILING":
            surface.Construction_Name = "Ceiling1C"

        elif s_type == "FLOOR":
            if bc == "GROUND":
                surface.Construction_Name = "GroundFloor1C"
            elif bc in ["ADIABATIC", "SURFACE"]:
                surface.Construction_Name = "IntFloor1C"
            else:
                surface.Construction_Name = "GroundFloor1C"

        else:
            surface.Construction_Name = "Ext_Walls1C"

    # If not using geomeppy's set_wwr(...) to define fenestration surfaces,
    # you could also set fenestration surfaces' construction here:
    for fen in idf.idfobjects["FENESTRATIONSURFACE:DETAILED"]:
        fen.Construction_Name = "Window1C"

    print("[assign_constructions_to_surfaces] => Surfaces assigned.")

  --- File Contents End ---

  File: materials_config.py
  --- File Contents Start ---
# fenez/materials_config.py

import random

###############################################################################
#  Material lookup dictionary
#  Here you define available material "templates" (with ranges),
#  which your building data references by name.
###############################################################################
material_lookup = {
    "Concrete_200mm": {
        "obj_type": "MATERIAL",
        "Name": "Concrete_200mm",
        "Roughness": "MediumRough",
        "Thickness_range": (0.195, 0.205),
        "Conductivity_range": (1.5, 1.7),
        "Density_range": (2250, 2350),
        "Specific_Heat_range": (850, 950),
        "Thermal_Absorptance_range": (0.9, 0.9),
        "Solar_Absorptance_range": (0.7, 0.7),
        "Visible_Absorptance_range": (0.7, 0.7)
    },

    "InsulationBoard_R2": {
        "obj_type": "MATERIAL:NOMASS",
        "Name": "InsulationBoard_R2",
        "Roughness": "MediumRough",
        "Thermal_Resistance_range": (0.34, 0.36),
        "Thermal_Absorptance_range": (0.9, 0.9),
        "Solar_Absorptance_range": (0.7, 0.7),
        "Visible_Absorptance_range": (0.7, 0.7)
    },

    "Glazing_Clear_3mm": {
        "obj_type": "WINDOWMATERIAL:GLAZING",
        "Name": "Glazing_Clear_3mm",
        "Optical_Data_Type": "SpectralAverage",
        "Thickness_range": (0.003, 0.003),
        "Solar_Transmittance_range": (0.76, 0.78),
        "Front_Solar_Reflectance_range": (0.07, 0.08),
        "Back_Solar_Reflectance_range": (0.07, 0.08),
        "Visible_Transmittance_range": (0.86, 0.88),
        "Front_Visible_Reflectance_range": (0.06, 0.07),
        "Back_Visible_Reflectance_range": (0.06, 0.07),
        "IR_Transmittance": 0.0,
        "Front_IR_Emissivity_range": (0.84, 0.84),
        "Back_IR_Emissivity_range": (0.84, 0.84),
        "Conductivity_range": (0.95, 1.05),
        "Dirt_Correction_Factor_range": (1.0, 1.0),
        "Solar_Diffusing": "No"
    },

    "Glazing_Clear_3mm_Post": {
        "obj_type": "WINDOWMATERIAL:GLAZING",
        "Name": "Glazing_Clear_3mm_Post",
        "Optical_Data_Type": "SpectralAverage",
        "Thickness_range": (0.003, 0.003),
        "Solar_Transmittance_range": (0.75, 0.75),
        "Front_Solar_Reflectance_range": (0.07, 0.07),
        "Back_Solar_Reflectance_range": (0.07, 0.07),
        "Visible_Transmittance_range": (0.85, 0.85),
        "Front_Visible_Reflectance_range": (0.07, 0.07),
        "Back_Visible_Reflectance_range": (0.07, 0.07),
        "IR_Transmittance": 0.0,
        "Front_IR_Emissivity_range": (0.84, 0.84),
        "Back_IR_Emissivity_range": (0.84, 0.84),
        "Conductivity_range": (1.0, 1.0),
        "Dirt_Correction_Factor_range": (1.0, 1.0),
        "Solar_Diffusing": "No"
    },

    "DoorPanel_Range": {
        "obj_type": "MATERIAL",
        "Name": "DoorPanel_Range",
        "Roughness": "MediumSmooth",
        "Thickness_range": (0.04, 0.05),
        "Conductivity_range": (0.4, 0.5),
        "Density_range": (600, 700),
        "Specific_Heat_range": (1200, 1300),
        "Thermal_Absorptance_range": (0.9, 0.9),
        "Solar_Absorptance_range": (0.7, 0.7),
        "Visible_Absorptance_range": (0.7, 0.7)
    },

    # [ADDED] Example new entries for ceiling, roof, ground, etc.
    "Ceiling_Insulation_R3": {
        "obj_type": "MATERIAL",
        "Name": "Ceiling_Insulation_R3",
        "Roughness": "MediumRough",
        "Thickness_range": (0.02, 0.03),
        "Conductivity_range": (0.035, 0.045),
        "Density_range": (20, 25),
        "Specific_Heat_range": (1400, 1500),
        "Thermal_Absorptance_range": (0.9, 0.9),
        "Solar_Absorptance_range": (0.7, 0.7),
        "Visible_Absorptance_range": (0.7, 0.7)
    },

    "Roof_Insulation_R5": {
        "obj_type": "MATERIAL",
        "Name": "Roof_Insulation_R5",
        "Roughness": "MediumRough",
        "Thickness_range": (0.04, 0.05),
        "Conductivity_range": (0.03, 0.04),
        "Density_range": (25, 30),
        "Specific_Heat_range": (1400, 1500),
        "Thermal_Absorptance_range": (0.9, 0.9),
        "Solar_Absorptance_range": (0.7, 0.7),
        "Visible_Absorptance_range": (0.7, 0.7)
    },

    "AdiabaticWall_Generic": {
        "obj_type": "MATERIAL",
        "Name": "AdiabaticWall_Generic",
        "Roughness": "MediumSmooth",
        "Thickness_range": (0.15, 0.20),
        "Conductivity_range": (0.30, 0.40),
        "Density_range": (200, 300),
        "Specific_Heat_range": (1000, 1100),
        "Thermal_Absorptance_range": (0.9, 0.9),
        "Solar_Absorptance_range": (0.7, 0.7),
        "Visible_Absorptance_range": (0.7, 0.7)
    },

    "GroundContactFloor_Generic": {
        "obj_type": "MATERIAL",
        "Name": "GroundContactFloor_Generic",
        "Roughness": "MediumRough",
        "Thickness_range": (0.10, 0.12),
        "Conductivity_range": (1.0, 1.2),
        "Density_range": (2100, 2300),
        "Specific_Heat_range": (850, 900),
        "Thermal_Absorptance_range": (0.9, 0.9),
        "Solar_Absorptance_range": (0.7, 0.7),
        "Visible_Absorptance_range": (0.7, 0.7)
    },
}


###############################################################################
#  Residential and Non-residential data are imported from your separate modules
###############################################################################
from .data_materials_residential import residential_materials_data
from .data_materials_non_residential import non_residential_materials_data


def pick_val(rng, strategy="A"):
    """
    Helper to pick a single float from (min,max).
    If rng=(x,x), return x.
    If strategy="A", pick the midpoint. If "B", pick random uniform in the range.
    """
    if rng[0] == rng[1]:
        return rng[0]
    if strategy == "A":
        return (rng[0] + rng[1]) / 2.0
    elif strategy == "B":
        return random.uniform(rng[0], rng[1])
    else:
        # fallback
        return rng[0]


def assign_material_from_lookup(mat_def: dict, strategy="A"):
    """
    Takes a dict from material_lookup, which has fields like "Thickness_range",
    "Conductivity_range", etc. Returns a copy with final numeric picks assigned.
    """
    final_mat = dict(mat_def)  # shallow copy
    obj_type = final_mat["obj_type"].upper()

    if obj_type == "MATERIAL":
        final_mat["Thickness"] = pick_val(final_mat.get("Thickness_range", (0.2, 0.2)), strategy)
        final_mat["Conductivity"] = pick_val(final_mat.get("Conductivity_range", (1.4, 1.4)), strategy)
        final_mat["Density"] = pick_val(final_mat.get("Density_range", (2300, 2300)), strategy)
        final_mat["Specific_Heat"] = pick_val(final_mat.get("Specific_Heat_range", (900, 900)), strategy)
        final_mat["Thermal_Absorptance"] = pick_val(
            final_mat.get("Thermal_Absorptance_range", (0.9, 0.9)), strategy
        )
        final_mat["Solar_Absorptance"] = pick_val(
            final_mat.get("Solar_Absorptance_range", (0.7, 0.7)), strategy
        )
        final_mat["Visible_Absorptance"] = pick_val(
            final_mat.get("Visible_Absorptance_range", (0.7, 0.7)), strategy
        )

    elif obj_type == "MATERIAL:NOMASS":
        final_mat["Thermal_Resistance"] = pick_val(
            final_mat.get("Thermal_Resistance_range", (0.35, 0.35)), strategy
        )
        final_mat["Thermal_Absorptance"] = pick_val(
            final_mat.get("Thermal_Absorptance_range", (0.9, 0.9)), strategy
        )
        final_mat["Solar_Absorptance"] = pick_val(
            final_mat.get("Solar_Absorptance_range", (0.7, 0.7)), strategy
        )
        final_mat["Visible_Absorptance"] = pick_val(
            final_mat.get("Visible_Absorptance_range", (0.7, 0.7)), strategy
        )

    elif obj_type == "WINDOWMATERIAL:GLAZING":
        final_mat["Thickness"] = pick_val(final_mat.get("Thickness_range", (0.003, 0.003)), strategy)
        final_mat["Solar_Transmittance"] = pick_val(
            final_mat.get("Solar_Transmittance_range", (0.76, 0.76)), strategy
        )
        final_mat["Front_Solar_Reflectance"] = pick_val(
            final_mat.get("Front_Solar_Reflectance_range", (0.07, 0.07)), strategy
        )
        final_mat["Back_Solar_Reflectance"] = pick_val(
            final_mat.get("Back_Solar_Reflectance_range", (0.07, 0.07)), strategy
        )
        final_mat["Visible_Transmittance"] = pick_val(
            final_mat.get("Visible_Transmittance_range", (0.86, 0.86)), strategy
        )
        final_mat["Front_Visible_Reflectance"] = pick_val(
            final_mat.get("Front_Visible_Reflectance_range", (0.06, 0.06)), strategy
        )
        final_mat["Back_Visible_Reflectance"] = pick_val(
            final_mat.get("Back_Visible_Reflectance_range", (0.06, 0.06)), strategy
        )
        final_mat["Front_IR_Emissivity"] = pick_val(
            final_mat.get("Front_IR_Emissivity_range", (0.84, 0.84)), strategy
        )
        final_mat["Back_IR_Emissivity"] = pick_val(
            final_mat.get("Back_IR_Emissivity_range", (0.84, 0.84)), strategy
        )
        final_mat["Conductivity"] = pick_val(
            final_mat.get("Conductivity_range", (1.0, 1.0)), strategy
        )
        final_mat["Dirt_Correction_Factor"] = pick_val(
            final_mat.get("Dirt_Correction_Factor_range", (1.0, 1.0)), strategy
        )

    elif obj_type == "WINDOWMATERIAL:SIMPLEGLAZINGSYSTEM":
        # e.g. pick UFactor, SHGC, etc., if present in the dictionary
        pass

    return final_mat


def compute_wwr(elements_dict, include_doors=False):
    """
    Compute WWR => (window area) / (external wall area).
    If include_doors=True, add door area to the 'window' portion.
    """
    external_wall_area = 0.0
    # Example: check multiple wall keys if your data has them
    if "solid_wall" in elements_dict:
        external_wall_area += elements_dict["solid_wall"].get("area_m2", 0.0)
    if "exterior_wall" in elements_dict:
        external_wall_area += elements_dict["exterior_wall"].get("area_m2", 0.0)
    if "sloping_flat_roof" in elements_dict:  # or some other roof/wall combos
        pass
    # etc. (add more if your data structure requires)

    window_area = elements_dict.get("windows", {}).get("area_m2", 0.0)
    if include_doors and "doors" in elements_dict:
        window_area += elements_dict["doors"].get("area_m2", 0.0)

    if external_wall_area > 0:
        return window_area / external_wall_area
    else:
        return 0.0


def get_extended_materials_data(
    building_function: str,
    building_type: str,      # e.g. "Two-and-a-half-story House" or "Meeting Function"
    age_range: str,
    scenario: str,
    calibration_stage: str,
    strategy: str = "A",
    random_seed=None,
    user_config_fenez=None   # [ADDED] optional user override
):
    """
    1) Looks up either residential_materials_data or non_residential_materials_data
       by (building_type, age_range, scenario, calibration_stage).
    2) Picks from wwr_range => final wwr.
    3) Also grabs top-level 'material_opaque_lookup', 'material_window_lookup' if any.
    4) Then for sub-elements => ground_floor, windows, doors => picks R_value, U_value, area, etc.
       plus references to 'material_opaque_lookup' or 'material_window_lookup' if present.
    5) If user_config_fenez is provided, it can override some or all picks at the end.
    6) Returns a dictionary => {
         "roughness": ...,
         "wwr": ...,
         "material_opaque": ...,
         "material_window": ...,
         "elements": {...}
       }
    """

    if random_seed is not None:
        random.seed(random_seed)

    # Decide data source
    if building_function.lower() == "residential":
        ds = residential_materials_data
        dict_key = (building_type, age_range, scenario, calibration_stage)
    else:
        ds = non_residential_materials_data
        dict_key = (building_type, age_range, scenario, calibration_stage)

    if dict_key not in ds:
        # fallback if no matching entry
        output_fallback = {
            "roughness": "MediumRough",
            "wwr": 0.3,
            "material_opaque": None,
            "material_window": None,
            "elements": {}
        }
        # Optionally let user_config_fenez override even in fallback scenario
        if user_config_fenez is not None and "wwr" in user_config_fenez:
            output_fallback["wwr"] = user_config_fenez["wwr"]
        return output_fallback

    data_entry = ds[dict_key]

    # 1) pick wwr
    wwr_val = pick_val(data_entry.get("wwr_range", (0.3, 0.3)), strategy)
    # 2) get roughness
    rough_str = data_entry.get("roughness", "MediumRough")

    # 3) if top-level references exist
    mat_opq_key = data_entry.get("material_opaque_lookup", None)
    final_opq = None
    if mat_opq_key and mat_opq_key in material_lookup:
        final_opq = assign_material_from_lookup(material_lookup[mat_opq_key], strategy)

    mat_win_key = data_entry.get("material_window_lookup", None)
    final_win = None
    if mat_win_key and mat_win_key in material_lookup:
        final_win = assign_material_from_lookup(material_lookup[mat_win_key], strategy)

    # 4) sub-elements => gather them
    elements = {}
    # Common keys we look for
    possible_elements = [
        "ground_floor", "solid_wall", "sloping_flat_roof", "exterior_wall",
        "flat_roof", "windows", "doors"
    ]

    for elem_name in possible_elements:
        if elem_name in data_entry:
            subd = data_entry[elem_name]
            out_sub = dict(subd)  # shallow copy

            # pick R_value
            if "R_value_range" in subd:
                out_sub["R_value"] = pick_val(subd["R_value_range"], strategy)
            # pick U_value
            if "U_value_range" in subd:
                out_sub["U_value"] = pick_val(subd["U_value_range"], strategy)

            # if subd has its own material_opaque_lookup or material_window_lookup
            if "material_opaque_lookup" in subd:
                mokey = subd["material_opaque_lookup"]
                if mokey in material_lookup:
                    out_sub["material_opaque"] = assign_material_from_lookup(
                        material_lookup[mokey], strategy
                    )
            if "material_window_lookup" in subd:
                mwkey = subd["material_window_lookup"]
                if mwkey in material_lookup:
                    out_sub["material_window"] = assign_material_from_lookup(
                        material_lookup[mwkey], strategy
                    )

            elements[elem_name] = out_sub

    # 5) Build final output
    result = {
        "roughness": rough_str,
        "wwr": wwr_val,
        "material_opaque": final_opq,
        "material_window": final_win,
        "elements": elements
    }

    # 6) [ADDED] user_config_fenez override
    if user_config_fenez is not None:
        # For instance, if user_config_fenez contains a direct override for wwr
        if "wwr" in user_config_fenez:
            result["wwr"] = user_config_fenez["wwr"]

        # If user_config_fenez has a top-level material_opaque_lookup override
        if "material_opaque_lookup" in user_config_fenez:
            new_opq_key = user_config_fenez["material_opaque_lookup"]
            if new_opq_key in material_lookup:
                result["material_opaque"] = assign_material_from_lookup(material_lookup[new_opq_key], strategy)

        # If user_config_fenez has a top-level material_window_lookup override
        if "material_window_lookup" in user_config_fenez:
            new_win_key = user_config_fenez["material_window_lookup"]
            if new_win_key in material_lookup:
                result["material_window"] = assign_material_from_lookup(material_lookup[new_win_key], strategy)

        # If user_config_fenez wants to override an element's material
        if "elements" in user_config_fenez:
            # e.g. user_config_fenez["elements"] might be a dict with keys like "roof", "walls" etc.
            for elem_key, elem_val in user_config_fenez["elements"].items():
                # Create or update that element
                if elem_key not in result["elements"]:
                    result["elements"][elem_key] = {}
                # override R_value, U_value, area_m2, or material_opaque_lookup, etc.
                if "R_value" in elem_val:
                    result["elements"][elem_key]["R_value"] = elem_val["R_value"]
                if "U_value" in elem_val:
                    result["elements"][elem_key]["U_value"] = elem_val["U_value"]
                if "area_m2" in elem_val:
                    result["elements"][elem_key]["area_m2"] = elem_val["area_m2"]

                if "material_opaque_lookup" in elem_val:
                    mk = elem_val["material_opaque_lookup"]
                    if mk in material_lookup:
                        result["elements"][elem_key]["material_opaque"] = assign_material_from_lookup(
                            material_lookup[mk], strategy
                        )
                if "material_window_lookup" in elem_val:
                    mwk = elem_val["material_window_lookup"]
                    if mwk in material_lookup:
                        result["elements"][elem_key]["material_window"] = assign_material_from_lookup(
                            material_lookup[mwk], strategy
                        )

    return result

  --- File Contents End ---

================================================================================

Folder: D:\Documents\E_Plus_2030_py/fenez\__pycache__

================================================================================

